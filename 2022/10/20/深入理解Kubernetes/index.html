<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/Blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Blog/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="jp8hRIs_fXYSSevDoEZ1giHKjclja45PG5Hg07ivzIM">

<link rel="stylesheet" href="/Blog/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"unparalleled-calvin.github.io","root":"/Blog/","images":"/Blog/images","scheme":"Pisces","darkmode":false,"version":"8.13.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/Blog/js/config.js"></script>

    <meta name="description" content="深入理解Kubernetes   张磊著 第一章 云原生大事记 CloudFoundry公司开辟了PaaS(Platform as a Service)的市场，已有容器、沙箱等实现 来自于dotCloud公司Docker项目的发布颠覆了CloudFoundary复杂的打包流程，以image的概念将操作系统与文件目录打包到一起，从而可以快速地在任意机器部署环境 Docker在短时间内吸引了大量开发者">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Kubernetes">
<meta property="og:url" content="https://unparalleled-calvin.github.io/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/index.html">
<meta property="og:site_name" content="Calvin Cui">
<meta property="og:description" content="深入理解Kubernetes   张磊著 第一章 云原生大事记 CloudFoundry公司开辟了PaaS(Platform as a Service)的市场，已有容器、沙箱等实现 来自于dotCloud公司Docker项目的发布颠覆了CloudFoundary复杂的打包流程，以image的概念将操作系统与文件目录打包到一起，从而可以快速地在任意机器部署环境 Docker在短时间内吸引了大量开发者">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://unparalleled-calvin.github.io/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/86e52f8f403c4661a3dcdb1482b9ce1d.jpg">
<meta property="og:image" content="https://unparalleled-calvin.github.io/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/8ea3266543164081af35dc4061d65cca.jpg">
<meta property="og:image" content="https://unparalleled-calvin.github.io/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/image-20230209140836991.jpg">
<meta property="og:image" content="https://unparalleled-calvin.github.io/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/image-20230211101318181.jpg">
<meta property="og:image" content="https://unparalleled-calvin.github.io/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/image-20230211101442521.jpg">
<meta property="og:image" content="https://unparalleled-calvin.github.io/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/netfilter.jpg">
<meta property="og:image" content="https://unparalleled-calvin.github.io/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/image-20230214135305115.jpg">
<meta property="og:image" content="https://unparalleled-calvin.github.io/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/image-20230214161132561.jpg">
<meta property="article:published_time" content="2022-10-20T14:59:06.000Z">
<meta property="article:modified_time" content="2024-12-22T05:13:49.000Z">
<meta property="article:author" content="Calvin Cui">
<meta property="article:tag" content="Container">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unparalleled-calvin.github.io/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/86e52f8f403c4661a3dcdb1482b9ce1d.jpg">


<link rel="canonical" href="https://unparalleled-calvin.github.io/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://unparalleled-calvin.github.io/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/","path":"2022/10/20/深入理解Kubernetes/","title":"深入理解Kubernetes"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>深入理解Kubernetes | Calvin Cui</title>
  






  <noscript>
    <link rel="stylesheet" href="/Blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/Blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Calvin Cui</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/Blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/Blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/Blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">44</span></a></li><li class="menu-item menu-item-categories"><a href="/Blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">5</span></a></li><li class="menu-item menu-item-archives"><a href="/Blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">44</span></a></li><li class="menu-item menu-item-readings"><a href="/Blog/readings/" rel="section"><i class="fa fa-book fa-fw"></i>Readings</a></li><li class="menu-item menu-item-films"><a href="/Blog/films/" rel="section"><i class="fa fa-film fa-fw"></i>Films</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%91%E5%8E%9F%E7%94%9F%E5%A4%A7%E4%BA%8B%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">第一章 云原生大事记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">第二章 容器技术基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Namespace"><span class="nav-number">2.1.</span> <span class="nav-text">Namespace</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cgroups"><span class="nav-number">2.2.</span> <span class="nav-text">Cgroups</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#File-System"><span class="nav-number">2.3.</span> <span class="nav-text">File System</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98"><span class="nav-number">2.4.</span> <span class="nav-text">Linux容器实战</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Volume"><span class="nav-number">2.5.</span> <span class="nav-text">Volume</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-Kubernetes%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">第三章 Kubernetes设计与架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-Kunernetes%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="nav-number">4.</span> <span class="nav-text">第四章 Kunernetes集群搭建与配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#kubeadm"><span class="nav-number">4.1.</span> <span class="nav-text">kubeadm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#k8s%E5%BA%94%E7%94%A8"><span class="nav-number">4.2.</span> <span class="nav-text">k8s应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-Kubernetes%E7%BC%96%E6%8E%92%E5%8E%9F%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">第五章 Kubernetes编排原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Pod"><span class="nav-number">5.1.</span> <span class="nav-text">为什么需要Pod</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Pod%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.2.</span> <span class="nav-text">深入解析Pod对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pod%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6"><span class="nav-number">5.3.</span> <span class="nav-text">Pod对象使用进阶</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%9C%E6%8E%A7%E5%88%B6%E5%99%A8%E2%80%9D%E6%80%9D%E6%83%B3"><span class="nav-number">5.4.</span> <span class="nav-text">“控制器”思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E5%89%AF%E6%9C%AC%E4%B8%8E%E6%B0%B4%E5%B9%B3%E6%8B%93%E5%B1%95"><span class="nav-number">5.5.</span> <span class="nav-text">作业副本与水平拓展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3StatefulSet%EF%BC%9A%E6%8B%93%E6%89%91%E7%8A%B6%E6%80%81"><span class="nav-number">5.6.</span> <span class="nav-text">深入理解StatefulSet：拓扑状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3StatefulSet%EF%BC%9A%E5%AD%98%E5%82%A8%E7%8A%B6%E6%80%81"><span class="nav-number">5.7.</span> <span class="nav-text">深入理解StatefulSet：存储状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%8C%96%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%EF%BC%9ADaemonSet"><span class="nav-number">5.8.</span> <span class="nav-text">容器化守护进程：DaemonSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%92%AC%E5%8A%A8%E7%A6%BB%E7%BA%BF%E4%B8%9A%E5%8A%A1%EF%BC%9AJob%E4%B8%8ECronJob"><span class="nav-number">5.9.</span> <span class="nav-text">撬动离线业务：Job与CronJob</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8FAPI%E4%B8%8EKubernetes%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F"><span class="nav-number">5.10.</span> <span class="nav-text">声明式API与Kubernetes编程范式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8FAPI%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">5.11.</span> <span class="nav-text">声明式API的工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#API%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E7%9A%84%E5%85%B7%E4%BD%93%E5%8E%9F%E7%90%86"><span class="nav-number">5.12.</span> <span class="nav-text">API编程范式的具体原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%EF%BC%9ARBAC"><span class="nav-number">5.13.</span> <span class="nav-text">基于角色的权限控制：RBAC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%AA%E6%98%8E%E7%9A%84%E5%BE%AE%E5%88%9B%E6%96%B0%EF%BC%9AOperator%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%A7%A3%E8%AF%BB"><span class="nav-number">5.14.</span> <span class="nav-text">聪明的微创新：Operator工作原理解读</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kubernetes%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86"><span class="nav-number">6.</span> <span class="nav-text">Kubernetes存储原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8%EF%BC%9APV%E5%92%8CPVC%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">6.1.</span> <span class="nav-text">持久化存储：PV和PVC的设计与实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9C%AC%E5%9C%B0%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE"><span class="nav-number">6.2.</span> <span class="nav-text">深入理解本地持久化数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AD%98%E5%82%A8%E6%8F%92%E4%BB%B6%EF%BC%9AFlexVolume%E4%B8%8ECSI"><span class="nav-number">6.3.</span> <span class="nav-text">开发自己的存储插件：FlexVolume与CSI</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kubernetes%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text">Kubernetes网络原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E6%9C%BA%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">7.1.</span> <span class="nav-text">单机容器网络的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%AE%B9%E5%99%A8%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">7.2.</span> <span class="nav-text">深入解析容器跨主机网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kubernetes%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8ECNI%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6"><span class="nav-number">7.3.</span> <span class="nav-text">Kubernetes网络模型与CNI网络插件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E8%AF%BBKubernetes%E4%B8%89%E5%B1%82%E7%BD%91%E7%BB%9C%E6%96%B9%E6%A1%88"><span class="nav-number">7.4.</span> <span class="nav-text">解读Kubernetes三层网络方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kubernetes%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB%EF%BC%9ANetworkPolicy"><span class="nav-number">7.5.</span> <span class="nav-text">Kubernetes中的网络隔离：NetworkPolicy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E5%AE%B9%E5%99%A8%E4%B8%8D%E5%AE%B9%E6%98%93%EF%BC%9AService%E3%80%81DNS%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="nav-number">7.6.</span> <span class="nav-text">找到容器不容易：Service、DNS与服务发现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E5%A4%96%E7%95%8C%E8%BF%9E%E9%80%9AService%E4%B8%8EService%E8%B0%83%E8%AF%95%E2%80%9C%E4%B8%89%E6%9D%BF%E6%96%A7%E2%80%9D"><span class="nav-number">7.7.</span> <span class="nav-text">从外界连通Service与Service调试“三板斧”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kubernetes%E4%B8%AD%E7%9A%84Ingress%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.8.</span> <span class="nav-text">Kubernetes中的Ingress对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kubernetes%E7%9A%84%E8%B5%84%E6%BA%90%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text">Kubernetes的资源模型与资源管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Kubernetes%E7%9A%84%E8%B5%84%E6%BA%90%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-1"><span class="nav-number">8.1.</span> <span class="nav-text">Kubernetes的资源模型与资源管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kubernetes%E7%9A%84%E9%BB%98%E8%AE%A4%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-number">8.2.</span> <span class="nav-text">Kubernetes的默认调度器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kubernetes%E9%BB%98%E8%AE%A4%E8%B0%83%E5%BA%A6%E5%99%A8%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E8%A7%A3%E6%9E%90"><span class="nav-number">8.3.</span> <span class="nav-text">Kubernetes默认调度器调度策略解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kubernetes%E9%BB%98%E8%AE%A4%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E6%8A%A2%E5%8D%A0%E6%9C%BA%E5%88%B6"><span class="nav-number">8.4.</span> <span class="nav-text">Kubernetes默认调度器的优先级和抢占机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kubernetes-GPU%E7%AE%A1%E7%90%86%E4%B8%8EDevice-Plugin%E6%9C%BA%E5%88%B6"><span class="nav-number">8.5.</span> <span class="nav-text">Kubernetes GPU管理与Device Plugin机制</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Calvin Cui"
      src="/Blog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Calvin Cui</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Unparalleled-Calvin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Unparalleled-Calvin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:CalvinCui@foxmail.com" title="E-mail → mailto:CalvinCui@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/438414714" title="BiliBili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;438414714" rel="noopener" target="_blank"><i class="fa-brands fa-bilibili fa-fw"></i>BiliBili</a>
      </span>
      <span class="links-of-author-item">
        <a href="/Blog/WeChatOfficialAccount/" title="Platform → &#x2F;WeChatOfficialAccount&#x2F;"><i class="fa-brands fa-weixin fa-fw"></i>Platform</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://unparalleled-calvin.github.io/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.jpg">
      <meta itemprop="name" content="Calvin Cui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin Cui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="深入理解Kubernetes | Calvin Cui">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入理解Kubernetes
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-10-20 22:59:06" itemprop="dateCreated datePublished" datetime="2022-10-20T22:59:06+08:00">2022-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-12-22 13:13:49" itemprop="dateModified" datetime="2024-12-22T13:13:49+08:00">2024-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Blog/categories/%E6%8A%80%E6%9C%AF%E8%A7%86%E9%87%8E/" itemprop="url" rel="index"><span itemprop="name">技术视野</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>深入理解Kubernetes   张磊著</p>
<h3 id="第一章-云原生大事记"><a href="#第一章-云原生大事记" class="headerlink" title="第一章 云原生大事记"></a>第一章 云原生大事记</h3><ul>
<li>CloudFoundry公司开辟了PaaS(Platform as a Service)的市场，已有容器、沙箱等实现</li>
<li>来自于dotCloud公司Docker项目的发布颠覆了CloudFoundary复杂的打包流程，以image的概念将操作系统与文件目录打包到一起，从而可以快速地在任意机器部署环境</li>
<li>Docker在短时间内吸引了大量开发者，出现了一批以Docker为核心的项目，一般自称为CaaS(Container as a service)。之后dotCloud更名为Docker公司，并开发了Swarm项目，试图回到PaaS(因为有更多的商业机会)</li>
<li>由于众多开发者不满意Docker公司越来越大的话语权，因此多方协同之下成立了<code>OCI</code>(Open Container Initiative)，意在将容器运行时和镜像的实现剥离出Docker，但效果不大。然后Google、Red Hat又牵头成立了<code>CNCF</code>(Cloud Native Computing Foundation)基金会，为Kubernetes的发展提供了良好条件：<ul>
<li>Red Hat的众多开发者为项目提供了足够大的人力</li>
<li>Kubernetes在构建之初就在各层开放了众多插件接口，从而快速引入了一大批之后发挥重要作用的项目</li>
</ul>
</li>
<li>试图将开源项目封闭与自己产品的Docker公司没能击败Kubernetes，最终进行了商业转型，并将容器运行时部分<code>Containerd</code>捐赠给CDCF。</li>
</ul>
<h3 id="第二章-容器技术基础"><a href="#第二章-容器技术基础" class="headerlink" title="第二章 容器技术基础"></a>第二章 容器技术基础</h3><h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><p>启动一个容器，并执行<code>/bin/sh</code></p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> busybox /bin/sh</code></pre>

<p>可以发现在容器中，&#x2F;bin&#x2F;sh是PID为1的进程。Docker借助Linux的<code>Namespace</code>来进行<strong>内核资源的隔离</strong>，构建单独的进程空间，因此一个PID Namepsace中的进程在计算自己的PID号时只会在本空间下计算。</p>
<blockquote>
<p>除了PID Namespace，还有Mount，UTS，IPC，Network，User等Namespace，从而实现对进程相关资源的隔离。实际上所有的计算和资源都是原来机器上的，根本不像虚拟机的Hypervisor还需要模拟一套硬件系统。</p>
</blockquote>
<p>当然这种os<strong>障眼法式</strong>的隔离在提供了敏捷和便利的同时也带来了非常大的安全问题，例如一些危险的系统调用等等。</p>
<h4 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h4><p>Docker借助Linux的<code>Cgroups</code>来<strong>限制容器进程组可用的资源</strong>，包括CPU、内存、磁盘、网络带宽等</p>
<p>Cgoups将资源限制以挂载文件的形式表示，一般在<code>/sys/fs/cgroup/xx</code>下，例如可以在<code>cpu</code>项下新建一个文件夹，在其中写入相关的配置，并将进程号写入对应<code>tasks</code>文件中。</p>
<p>这些资源限制在使用docker run命令时就可以指定，直接写入子系统文件中。</p>
<blockquote>
<p>Cgroups并未对<code>/proc</code>文件系统做限制，因此在容器中甚至可以读取其中文件查看宿主机的信息，这无疑是非常危险的。</p>
</blockquote>
<h4 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h4><p>在进程被<code>clone</code>之初，所有的信息，例如文件目录都继承于父进程(即便是有Mount Namespace也是继承了父进程的)，因此需要对其进程<strong>重挂载</strong>的操作。Linux提供了<code>chroot</code>命令来对进程启动时的根目录进行重新挂载(Docker实际会使用功能类似的<code>pivot_root</code>)</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">chroot</span> <span class="token variable">$new_path</span> /bin/bash</code></pre>

<p>而Mount Namespace就是根据chroot改进而来的。</p>
<p>所以一般来说，在容器启动时，会为其挂载一份完整的文件系统。但是操作系统的内核还是在机器启动时载入内存的，因此容器中的os文件<strong>只有外壳，而没有灵魂</strong>，实际上用的内核资源还是原来的。因此对内核的所有操作，实际上会影响所有共享这些资源的进程。</p>
<p>我们看到，一个容器实际上包含一整个rootfs，那么倘若需要对其做出少量有意义更改，是否需要另外打包出一份文件呢？实际上Docker利用<code>AuFS</code>(Advanced unionFS，在Linux UnionFS上改进的版本)来将不同的文件挂载到某个目录下，以实现<strong>layer</strong>的概念。增量更新只需要用挂载就可以实现不同版本的rootfs了！</p>
<p>实际实现时，Docker会将所有的增量联合挂载在<code>/var/lib/docker/aufs/mnt/&lt;ID&gt;</code>。</p>
<p>rootfs实际上分为多个层级</p>
<table>
<thead>
<tr>
<th>层</th>
<th>权限</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>可读写层</td>
<td>rw</td>
<td>可以增加文件或“删除”只读层的文件(增量式的遮挡)</td>
</tr>
<tr>
<td>Init层</td>
<td>ro+wh(write out)</td>
<td>Init容器时os中需要修改的一部分，例如<code>/ect/hosts</code>等，单独从只读层拿出来形成一层</td>
</tr>
<tr>
<td>只读层</td>
<td>ro+wh</td>
<td>5层(5个文件夹)增量os文件</td>
</tr>
</tbody></table>
<h4 id="Linux容器实战"><a href="#Linux容器实战" class="headerlink" title="Linux容器实战"></a>Linux容器实战</h4><blockquote>
<p>中国用户请为docker的deamon加上如下配置项实现换源：</p>
<pre class="language-json" data-language="json"><code class="language-json"><span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
   <span class="token string">"http://hub-mirror.c.163.com"</span><span class="token punctuation">,</span>
   <span class="token string">"https://docker.mirrors.ustc.edu.cn/"</span>
 <span class="token punctuation">]</span></code></pre>
</blockquote>
<p>Dockerfile原语</p>
<table>
<thead>
<tr>
<th>原语</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FROM …</td>
<td>使用某个基础镜像</td>
</tr>
<tr>
<td>ADD src dst</td>
<td>将<strong>容器外</strong>src目录下所有内容复制到<strong>容器中</strong>dst目录下</td>
</tr>
<tr>
<td>WORKDIR …</td>
<td>将工作目录切换到容器中的…目录，用RUN cd … 无法起到相同效果</td>
</tr>
<tr>
<td>RUN …</td>
<td>执行一条shell命令</td>
</tr>
<tr>
<td>EXPOSE …</td>
<td>向外界暴露容器端口</td>
</tr>
<tr>
<td>ENV … …</td>
<td>设置环境变量</td>
</tr>
<tr>
<td>CMD [“…”, “…”]</td>
<td>入口ENTRYPOINT的参数，默认ENTRYPOINT隐藏入口为<code>/bin/sh -c</code>。<br />可以将shell命令与参数放入列表，用于容器启动。如果没有CMD则需启动时指定要执行的进程。</td>
</tr>
</tbody></table>
<ul>
<li><p>规定好Dockerfile后，在目录下执行命令进行helloworld镜像的搭建</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> build <span class="token parameter variable">-t</span> helloworld <span class="token builtin class-name">.</span> </code></pre>
</li>
<li><p>用一个容器运行该镜像，并把本机5000端口映射到容器80端口</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token number">5000</span>:80 helloworld</code></pre>
</li>
<li><p>在容器内运行指令(比如&#x2F;bin&#x2F;sh)</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token variable">$&#123;container_id&#125;</span> /bin/sh</code></pre>

<p>  Docker如何实现进入容器呢？(即怎么使一个新的进程加入某个namespace)？在容器进程对应的<code>/proc/$&#123;pid&#125;/ns/...</code>有对应的ns文件，Linux提供<code>setns()</code>函数来打开一个ns文件并将当前进程加入对应Namespace。另外，也可以在run时指定<code>--net</code>来加入某个容器的net Namespace。</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--net</span> container:<span class="token variable">$&#123;container_id&#125;</span> <span class="token variable">$&#123;image_name&#125;</span> <span class="token variable">$&#123;cmd&#125;</span></code></pre>

<p>  当指定<code>--net=host</code>则会加入主机net Namespace。</p>
</li>
<li><p>将正在运行的容器打包更新某镜像</p>
  <pre class="language-shell'" data-language="shell'"><code class="language-shell'">docker commit $&#123;container_id&#125; helloworld</code></pre>
<p>  实际操作就是在可读写层进行写入和write out操作从而对镜像进行修改</p>
</li>
</ul>
<h4 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h4><p>docker可以利用volume将宿主机的目录挂载到容器中</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-v</span> /test <span class="token punctuation">..</span>. <span class="token comment"># 会在宿主机创建一个临时文件夹并挂载到容器/test</span>
<span class="token function">docker</span> run <span class="token parameter variable">-v</span> <span class="token punctuation">..</span>.:/test <span class="token punctuation">..</span>. <span class="token comment"># 会将宿主机的...目录挂载到容器/test</span></code></pre>

<p>上文讲过，虽然有Mount Namespace的存在，但是进程创建之初，文件系统的挂载与宿主机是一模一样的，因此在没有修改根目录之前，容器可以看到宿主机上所有文件和挂载，因此只需要在chroot之前使用Linux的<code>bind mount</code>机制将目录挂载即可(本质上就是指向同一个inode)，此时由于Mount Namespace的存在，宿主机并不会看到容器的挂载。</p>
<h3 id="第三章-Kubernetes设计与架构"><a href="#第三章-Kubernetes设计与架构" class="headerlink" title="第三章 Kubernetes设计与架构"></a>第三章 Kubernetes设计与架构</h3><style>.sfxbkdmeuqlu{zoom: 33%;}</style>

<p>Kubernetes起源于谷歌技术栈最底层的<code>Brog</code>，从设计之初就借鉴了Brog的经验。master节点负责调度，node节点负责计算。在master节点上，有三个核心部件：负责API的<code>kube-apiserver</code>、负责调度的<code>kube-scheduler</code>以及负责容器编排的<code>kube-controller-manager</code>。计算节点上，核心功能就是<code>kubelet</code>，它能够通过<code>CRI</code>(容器运行时接口)进行对容器的远程调用。</p>
<p>以统一的方式抽象底层基础设施能力(计算、存储、网络)，定义任务编排的各种关系(亲密关系，访问关系、代理关系)，将这些抽象以声明式API的方式对外暴露，从而允许平台构建者基于这些抽象进一步<strong>构建自己的PaaS乃至任何上层平台</strong>。</p>
<p>Kubernetes将需要频繁交互的容器划分进一个<code>Pod</code>，这些容器共享Network Namespace以及Volume，能够高效地交换信息。同时定义出了</p>
<ul>
<li>Pod，Job，CronJob等任务编排对象，描述试图管理的应用</li>
<li>Service，Ingress，Horizontal Pod Autoscalar等运维能力对象，进行具体的运维</li>
</ul>
<p>实际使用时仅仅需要编写配置文件，这就是<strong>声明式API</strong></p>
<h3 id="第四章-Kunernetes集群搭建与配置"><a href="#第四章-Kunernetes集群搭建与配置" class="headerlink" title="第四章 Kunernetes集群搭建与配置"></a>第四章 Kunernetes集群搭建与配置</h3><h4 id="kubeadm"><a href="#kubeadm" class="headerlink" title="kubeadm"></a>kubeadm</h4><blockquote>
<p>注：kubeadm在中国难以使用，推荐用kubeasz进行安装，详情请参考另一篇博客</p>
</blockquote>
<p>诞生于2017年，解决kubernetes在部署时需要编译出每个组件以及进行繁琐配置的问题。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">kubeadm init <span class="token comment"># 创建一个master节点</span>
kubeadm <span class="token function">join</span> <span class="token operator">&lt;</span>master节点的IP和端口<span class="token operator">></span> <span class="token comment"># 加入一个node节点</span></code></pre>

<p>为何不用容器部署kubernetes镜像呢？容器受限于Namespace创建的隔离景象，难以直接操作宿主机。</p>
<blockquote>
<p>中国用户如何安装kubeadm？</p>
<p>环境：ubuntu 22.04</p>
<ul>
<li><p>添加阿里源</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main"</span> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/apt/sources.list.d/kubernetes.list</code></pre>
</li>
<li><p>尝试<code>sudo apt-get update </code>，如果出现<code>GPG error,... No public key ...</code>错误，将此处公钥内容填写到下方命令中</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> gpg <span class="token parameter variable">--keyserver</span> keyserver.ubuntu.com <span class="token parameter variable">--recv</span> <span class="token variable">$&#123;public_key&#125;</span>
<span class="token function">sudo</span> gpg <span class="token parameter variable">--export</span> <span class="token parameter variable">--armor</span> <span class="token variable">$&#123;public_key&#125;</span> <span class="token operator">|</span> <span class="token function">sudo</span> apt-key <span class="token function">add</span> -</code></pre>
</li>
<li><p>再次尝试<code>sudo apt-get update</code>，成功后<code>sudo apt-get install kubeadm</code>(包含了kubeadm, kubelet和kubectl)</p>
</li>
</ul>
</blockquote>
<p>kubeadm的工作流程</p>
<ul>
<li><p><code>kubeadm init</code></p>
<ul>
<li>Preflight Check：检查内核等诸多依赖和资源是否可用</li>
<li>生成各种证书(位于master节点的<code>/ect/kubernetes/pki</code>下，用于Https通信等)和目录</li>
<li>生成其余组件访问kube-apiserver的配置文件(位于<code>/ect/kubernetes/xxx.conf</code>)</li>
<li>为master组件生成Pod配置文件，以<code>Static Pod</code>的方式被部署(将配置文件放入特定目录<code>/ect/kubernetes/manifests</code>，当<strong>kuberlet</strong>启动时会加载并启动目录中的容器)</li>
<li>master容器启动后，kubeadm检查<code>localhost:6443/healthz</code>组件的健康来检查URL</li>
<li>生成<code>booststrap token</code>供新节点加入集群</li>
</ul>
</li>
<li><p><code>kubeadm join</code></p>
<ul>
<li><p>为了和kube-apiserver进行交互，至少要进行一次不安全通信，此时为了自动化地建立可信连接，因此使用bootstrap token进行安全验证</p>
<blockquote>
<p>kubeadm join是由用户发起的，因此是可信的</p>
</blockquote>
</li>
<li><p>第一次通信后拿到了安全证书等等，新节点上的kubelet就可以与apiserver进行安全交互了</p>
</li>
</ul>
</li>
</ul>
<p>使用<code>kubeadm init --config xx.yaml</code>以自定义各个组件的参数配置等</p>
<h4 id="k8s应用"><a href="#k8s应用" class="headerlink" title="k8s应用"></a>k8s应用</h4><p>一个描述需要部署的容器的yaml样例</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment <span class="token comment">#该API对象的类型是Deployment，可以管理多个Pod副本并滚动更新应用</span>
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deployment
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span> <span class="token comment">#管理2个Pod副本，共3个Pod</span>
  <span class="token key atrule">template</span><span class="token punctuation">:</span>   <span class="token comment">#描述Pod副本的内容</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>
        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">containers</span><span class="token punctuation">:</span> <span class="token comment">#Pod所包含的容器列表</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.7.9 <span class="token comment">#容器所用的镜像</span>
        <span class="token key atrule">ports</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>
      <span class="token key atrule">volumes</span><span class="token punctuation">:</span> <span class="token comment">#Pod所包含的Volume列表</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>vol
        <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>
          <span class="token key atrule">path</span><span class="token punctuation">:</span> /var/data <span class="token comment">#宿主机将被使用的目录，可以在Pod中使用volumeMounts来挂载，以及mountPath来指定挂载路径</span></code></pre>

<p>可以通过<code>kubectl create -f 配置文件.yaml</code>进行API对象的创建，以及<code>kubectl replace -f 配置文件.yaml</code>进行API对象的更新。</p>
<p>推荐使用<code>kubectl apply -f 配置文件.yaml</code>统一处理</p>
<blockquote>
<p>因此当应用发生变化时更新镜像即可，当编排发生变化时更新配置文件即可</p>
</blockquote>
<p>使用<code>kubectl delete -f 配置文件.yaml</code>删除API对象</p>
<h3 id="第五章-Kubernetes编排原理"><a href="#第五章-Kubernetes编排原理" class="headerlink" title="第五章 Kubernetes编排原理"></a>第五章 Kubernetes编排原理</h3><h4 id="为什么需要Pod"><a href="#为什么需要Pod" class="headerlink" title="为什么需要Pod"></a>为什么需要Pod</h4><p>预先建立<strong>逻辑上</strong>的“组”，然后成组地调度容器，这样可以避免资源不足带来的死锁或者回滚机制带来的复杂度。</p>
<p>所谓逻辑上的组，有两点</p>
<ul>
<li>共享网络</li>
<li>共享Volume</li>
</ul>
<p>这可以通过加入Namespace的方式来实现。</p>
<p>为了体现Pod内容器的<strong>公平性</strong>，每个Pod先建立一个<strong>Infra容器</strong>，然后让其他容器加入它。</p>
<p>可以说，<strong>Pod就是Infra</strong>，生命周期、网络都与Infra无异</p>
<p>一个使用Pod来组合war程序包与tomcat服务器的例子：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> javaweb
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">initContainers</span><span class="token punctuation">:</span> <span class="token comment">#整体执行上先于后面containers包含的容器，里面包含的容器按照先后顺序依次执行</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> geektime/sample<span class="token punctuation">:</span>v2
    <span class="token key atrule">name</span><span class="token punctuation">:</span> war
    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"cp"</span><span class="token punctuation">,</span> <span class="token string">"/sample.war"</span><span class="token punctuation">,</span> <span class="token string">"/app"</span><span class="token punctuation">]</span> <span class="token comment">#将文件拷贝到app目录</span>
    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /app
      <span class="token key atrule">name</span><span class="token punctuation">:</span> app<span class="token punctuation">-</span>volume <span class="token comment">#将app-volume挂载到app目录上</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> geektime/tomcat<span class="token punctuation">:</span><span class="token number">7.0</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> tomcat
    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"/root/apache-tomcat-7.0.42-v2/bin/shart.sh"</span><span class="token punctuation">]</span>
    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /root/apache<span class="token punctuation">-</span>tomcat<span class="token punctuation">-</span>7.0.42<span class="token punctuation">-</span>v2/webapps
      <span class="token key atrule">name</span><span class="token punctuation">:</span> app<span class="token punctuation">-</span>volume <span class="token comment">#将app-volume挂载到webapps目录上，实现文件共享</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>
      <span class="token key atrule">hostPort</span><span class="token punctuation">:</span> <span class="token number">8081</span> 
  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> app<span class="token punctuation">-</span>volume
    <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">#用临时空文件夹初始化app-volume</span></code></pre>

<h4 id="深入解析Pod对象"><a href="#深入解析Pod对象" class="headerlink" title="深入解析Pod对象"></a>深入解析Pod对象</h4><p><code>spec</code>下一些重要的字段：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span> <span class="token comment">#只会被调度到携带了这对键值对标签的node上去</span>
    <span class="token key atrule">key</span><span class="token punctuation">:</span> value
  <span class="token key atrule">nodeName</span><span class="token punctuation">:</span> <span class="token punctuation">...</span> <span class="token comment">#默认由调度器来设置，如果设置了，调度时将会忽略该对象(y)</span>
  <span class="token key atrule">hostAliases</span><span class="token punctuation">:</span> <span class="token comment">#定义Pod的hosts文件的内容</span>
  <span class="token punctuation">-</span> <span class="token key atrule">ip</span><span class="token punctuation">:</span> <span class="token string">"...."</span>
    <span class="token key atrule">hostnames</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token string">"..."</span>
    <span class="token punctuation">-</span> <span class="token string">"..."</span>
  <span class="token key atrule">shareProcessNamespace</span><span class="token punctuation">:</span> true/false <span class="token comment">#是否Pod间共享PID Namespace</span>
  <span class="token key atrule">hostNetwork</span><span class="token punctuation">:</span> true/false <span class="token comment">#是否共享主机网络</span>
  <span class="token key atrule">hostIPC</span><span class="token punctuation">:</span> true/false <span class="token comment">#是否共享主机IPC</span>
  <span class="token key atrule">hostPID</span><span class="token punctuation">:</span> true/false <span class="token comment">#是否共享主机PID</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span> <span class="token comment">#定义包含的容器</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
    <span class="token key atrule">imagePullPolocy</span><span class="token punctuation">:</span> always <span class="token comment">#这是缺省值，可以改为never或ifNotPresent</span>
    <span class="token key atrule">lifecycle</span><span class="token punctuation">:</span> <span class="token comment">#定义容器状态变化时的hooks</span>
      <span class="token key atrule">postStart</span><span class="token punctuation">:</span> <span class="token comment">#容器被启动之后，但可能此时ENTRYPOINT还没有结束(异步)</span>
        <span class="token key atrule">exec</span><span class="token punctuation">:</span>
          <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">...</span><span class="token punctuation">]</span>
      <span class="token key atrule">preStop</span><span class="token punctuation">:</span> <span class="token comment">#一定在容器停止之前执行完毕(同步)</span>
        <span class="token punctuation">...</span></code></pre>

<h4 id="Pod对象使用进阶"><a href="#Pod对象使用进阶" class="headerlink" title="Pod对象使用进阶"></a>Pod对象使用进阶</h4><p><strong>Projected Volume</strong>：这种volume为容器提供预先定制的数据</p>
<ul>
<li><p>Secret</p>
<p>可以帮你把Pod要访问的加密数据<strong>存放到etcd中</strong></p>
<p>创建Secret对象：</p>
<ul>
<li><p><code>kubectl create secret generic $&#123;name&#125; --from-file=$&#123;filename&#125;</code>，将name对应的value放到filename中，这里的value是<strong>明文</strong></p>
</li>
<li><p>也可以使用yaml文件来创建</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret
<span class="token key atrule">type</span><span class="token punctuation">:</span> Opaque
<span class="token key atrule">data</span><span class="token punctuation">:</span>
  <span class="token key atrule">key</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>value<span class="token punctuation">&#125;</span> <span class="token comment">#这里是经过base64加密的密文</span>
  <span class="token punctuation">...</span></code></pre></li>
</ul>
<p>通过<code>kubectl get secrets</code>直接看到所有的Secret对象</p>
<p>使用Secret对象：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">volumes</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
  <span class="token key atrule">projected</span><span class="token punctuation">:</span> <span class="token comment">#类型不为emptyDir，也不为hostPath，而是projected</span>
    <span class="token key atrule">sources</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">secret</span><span class="token punctuation">:</span>
      <span class="token key atrule">name</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>name<span class="token punctuation">&#125;</span> <span class="token comment">#刚刚创建的secret的名称</span></code></pre>

<p>最后在挂载点会有name对应的文件，文件内容为value，并且是与etcd一致实时更新的</p>
</li>
<li><p>ConfigMap</p>
<p>和secret类似，但是是明文内容</p>
<p>创建ConfigMap对象：</p>
<ul>
<li><code>kubectl create configmap $&#123;name&#125; --from-file=$&#123;filename&#125;</code>，文件中每行为key&#x3D;value格式</li>
</ul>
<p>通过<code>kubectl get configmaps $&#123;name&#125; -o yaml</code>以yaml形式显示name的configmap</p>
</li>
<li><p>DownwardAPI</p>
<p>让Pod中的容器可以直接获取Pod的信息</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">volumes</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
  <span class="token key atrule">projected</span><span class="token punctuation">:</span>
    <span class="token key atrule">sources</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">downwardAPI</span><span class="token punctuation">:</span>
      <span class="token key atrule">items</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>path<span class="token punctuation">&#125;</span> <span class="token comment">#位于$&#123;挂载点&#125;/$&#123;path&#125;内</span>
        <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span> <span class="token comment">#还可以使用resourceFieldRef</span>
          <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> <span class="token punctuation">...</span> <span class="token comment">#具体条目请参考官方文档</span></code></pre>
</li>
<li><p>ServiceAccountToken</p>
<p>一个特殊的Secret。默认情况下，k8s为每一个Pod挂载了一个Secret Volume，存储Service Account Token用以操作k8s API本身，名字为**default-token-…**。service account是具有一定权限，例如get&#x2F;write的账户</p>
</li>
</ul>
<p><strong>restartPolocy</strong>：当<strong>容器</strong>出现异常后，Pod会重新创建这个容器</p>
<blockquote>
<p>只有Pod里的所有容器都出现异常以后，Pod才会出现异常，否则为Running，并在Ready字段显示可用容器数</p>
</blockquote>
<p>定义路径在pod.spec.restartPolicy，可选值为Always【默认】&#x2F;OnFailure&#x2F;Never</p>
<p>例如一次性执行的容器Pod就没必要设为always</p>
<blockquote>
<p>可以通过<code>kubectl describe pod ...</code>来查看Pod的信息，如果出现了fail&amp;restart等情况，在event字段里会有记录</p>
</blockquote>
<p><strong>PodPreset</strong>：用于预置一些Pod的配置，方便直接再预定义上直接修改</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> settings.k8s.io/v1alpha1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> PodPreset <span class="token comment">#PodPreset类型</span>
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> allow<span class="token punctuation">-</span>database
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
      $<span class="token punctuation">&#123;</span>label<span class="token punctuation">&#125;</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>value<span class="token punctuation">&#125;</span> <span class="token comment">#Preset要作用的Pod</span>
  <span class="token key atrule">env</span><span class="token punctuation">:</span> <span class="token comment">#定义一些环境变量</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> DB_PORT
    <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"6379"</span>
  <span class="token punctuation">...</span></code></pre>

<p>使用方式：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">kubectl create <span class="token parameter variable">-f</span> <span class="token variable">$&#123;preset file&#125;</span>
kubectl create <span class="token parameter variable">-f</span> <span class="token variable">$&#123;file&#125;</span> <span class="token comment">#label与preset的spec规定一致</span></code></pre>

<p>当同时使用多个preset后，后面的会拓展前面的，但不会覆盖相同字段</p>
<h4 id="“控制器”思想"><a href="#“控制器”思想" class="headerlink" title="“控制器”思想"></a>“控制器”思想</h4><p>控制器会执行一个循环，当发现相关Pod状态与预期不符时，会执行一些纠正操作。例如Deployment会按相关Pod的副本数是否为给定值，少则补充多则删除。其yaml文件大多为控制器定义+template的格式</p>
<h4 id="作业副本与水平拓展"><a href="#作业副本与水平拓展" class="headerlink" title="作业副本与水平拓展"></a>作业副本与水平拓展</h4><p>Deployment实际上控制的是ReplicaSet这个API对象(由deployment自动生成)，由它继而控制下属的Pod。</p>
<p>想要水平拓展的话，可以通过<code>kubectl scale deployment $&#123;name&#125; --replicas=$&#123;num&#125;</code>来修改Pod副本的个数</p>
<p>使用<code>kubectl edit deployment/$&#123;name&#125;</code>可以修改etcd中配置文件【例如Pod中容器的定义】，之后自动进行滚动更新</p>
<blockquote>
<p>背后的下载配置文件以及再次提交是自动完成的</p>
</blockquote>
<p>更新时，会生成一个新的ReplicaSet，老的里kill一个Pod，新的里创建一个Pod，如此滚动更新</p>
<p>可以配置允许离线的Pod数，默认值为总数目(replica+1)的25%</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>
  <span class="token key atrule">strategy</span><span class="token punctuation">:</span>
    <span class="token key atrule">type</span><span class="token punctuation">:</span> RollingUpdate
    <span class="token key atrule">roolingUpdate</span><span class="token punctuation">:</span>
      <span class="token key atrule">maxSurge</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment">#依次滚动更新可以创建的Pod数</span>
      <span class="token key atrule">maxUnavaliable</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment">#(3+1)的25%</span></code></pre>

<p>版本回滚：</p>
<ul>
<li><p>回滚当然也会创建新的ReplicaSet，所以如果不希望有很多新的set出现，可以使用<code>kubectl rollout pause</code>来暂停动态更新，修改完之后再执行<code>kubectl rollout resume</code>来恢复，最终只会执行一次动态更新</p>
<blockquote>
<p>可以通过<code>spec.revisionHistoryLimit</code>来设置历史保留的ReplicaSet的数目</p>
</blockquote>
</li>
<li><p>使用<code>kubectl rollout history</code>查看历史出现过的版本</p>
<blockquote>
<p>创建Deployment时加上–reocrd参数会记录导致版本变化的kubectl命令</p>
</blockquote>
</li>
<li><p>使用<code>kubectl rollout history deployment/$&#123;name&#125; --to-version=$&#123;version&#125;</code>回滚到某一版本</p>
</li>
</ul>
<h4 id="深入理解StatefulSet：拓扑状态"><a href="#深入理解StatefulSet：拓扑状态" class="headerlink" title="深入理解StatefulSet：拓扑状态"></a>深入理解StatefulSet：拓扑状态</h4><p>实例之间有<strong>不对等关系</strong>，实例对外部数据有<strong>依赖关系</strong>的应用称为<strong>有状态应用</strong></p>
<p>Service是k8s将一组Pod暴露给外界的一种方式，主要有这样几种</p>
<ul>
<li>VIP(virtual IP)的方式，访问ip后请求被转发到service的Pod</li>
<li>DNS方式<ul>
<li>解析为VIP</li>
<li>解析为Pod的IP</li>
</ul>
</li>
</ul>
<p>Headless Service：没有VIP头的Service</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> web
  <span class="token key atrule">clusterIP</span><span class="token punctuation">:</span> None <span class="token comment">#没有定义VIP</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx <span class="token comment">#Service为有这个label的Pod做代理</span></code></pre>

<p>然后所有被代理的Pod将会被绑定到DNS记录<code>$&#123;pod-name&#125;.$&#123;service-name&#125;.$&#123;namespace&#125;.svc.cluster.local</code>上【有时后面的cluster.local等等会被省略】</p>
<p>一个StatefulSet使用Service的例子，可以看到与deployment非常相似</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> StatefulSet
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> web
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> <span class="token string">"nginx"</span>
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx
  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token punctuation">...</span></code></pre>

<p>StatefulSet会为这些Pod分配编号，并且Pod的网络身份(hostname等)也与编号严格对应</p>
<blockquote>
<p>所以Pod有更新后，IP可能会变，但是DNS记录不会变。有状态应用都应该使用DNS记录或者hostname</p>
</blockquote>
<h4 id="深入理解StatefulSet：存储状态"><a href="#深入理解StatefulSet：存储状态" class="headerlink" title="深入理解StatefulSet：存储状态"></a>深入理解StatefulSet：存储状态</h4><p>将存储系统解耦合，分为接口和实现，一方面便于在不了解存储系统的情况下快速搭建集群应用，另一方面减少存储系统关键信息的暴露。</p>
<p>接口部分，使用PVC(Persistent Volume Claim)，描述需要的Volume的特征</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVokumeClaim
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv<span class="token punctuation">-</span>pod
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">accessMode</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> ReadWriteOnce <span class="token comment">#可读写权限，只能被挂载在一个节点上</span>
  <span class="token key atrule">resources</span><span class="token punctuation">:</span>
    <span class="token key atrule">requests</span><span class="token punctuation">:</span>
      <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi <span class="token comment">#Volume大小至少为1GiB</span></code></pre>

<p>实现部分，使用PV(Persistent Volume)</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv<span class="token punctuation">-</span>volume
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">type</span><span class="token punctuation">:</span> local
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">capacity</span><span class="token punctuation">:</span> 10Gi
  <span class="token punctuation">...</span> <span class="token comment">#具体的存储系统的信息，例如服务器地址，授权文件等等</span></code></pre>

<p>使用样例：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">volumes</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span> <span class="token comment">#自己起的，与上面volumeMount对应</span>
  <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span>
    <span class="token key atrule">claimName</span><span class="token punctuation">:</span> pv<span class="token punctuation">-</span>claim</code></pre>

<p>k8s为根据声明自动查找满足条件的PV进行挂载。</p>
<p>StatefulSet也可以定义PVC的template，从而为每个Pod配一个PVC【使用时也是Pod使用对应PVC】</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token key atrule">containers</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> www
        <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
  <span class="token key atrule">volumeClaimTemplates</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">name</span><span class="token punctuation">:</span> www
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token punctuation">...</span></code></pre>

<p>此时如果Pod异常挂了，新起起来的Pod依然会继承之前Pod的PVC，而那个PVC对应的PV也是之前的，所以存储内容会原原本本地继承下来</p>
<h4 id="容器化守护进程：DaemonSet"><a href="#容器化守护进程：DaemonSet" class="headerlink" title="容器化守护进程：DaemonSet"></a>容器化守护进程：DaemonSet</h4><p>每个节点上运行且只运行一个DeamonPod，Pod的生命周期与节点保持同步</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> app/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> DaemonSet
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
      <span class="token key atrule">name</span><span class="token punctuation">:</span> aaa
  <span class="token key atrule">template</span><span class="token punctuation">:</span> <span class="token comment">#定义Pod的内容</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>
        <span class="token key atrule">name</span><span class="token punctuation">:</span> aaa
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">tolerations</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span>role.kubernetes.io/master
        <span class="token key atrule">effect</span><span class="token punctuation">:</span> NoSchedule
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>
      <span class="token punctuation">...</span></code></pre>

<p>DaemonSet的API和Deployment很像，但是没有<strong>replicas</strong>字段，使用<code>selector</code>来管理携带指定label的Pod。</p>
<p>为了在<strong>指定节点</strong>上创建Pod(在其上删除很好做)，DaemonSet会自动在<strong>创建Pod时</strong>根据节点名字加上<code>nodeAffinity</code>属性(nodeSelector的进阶)，下面是一个单独使用nodeAffinity的样例</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kine</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>
    <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span>
      <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span> <span class="token comment">#在每次调度时考虑该affinity</span>
        <span class="token key atrule">nodeSelectorTerms</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> metadata.name
            <span class="token key atrule">operator</span><span class="token punctuation">:</span> in <span class="token comment">#操作符为部分匹配</span>
            <span class="token key atrule">values</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> bbb <span class="token comment">#用key来匹配这个value</span></code></pre>

<p>另外，DaemonSet也会为Pod加上指定的tolerations关键字来<strong>容忍</strong>带有<code>network-unavaliable</code>污点的节点，例如</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">tolerations</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> node.kubernetes.io/unschedulable <span class="token comment">#有unschedulable污点</span>
    <span class="token key atrule">operator</span><span class="token punctuation">:</span> Exists
    <span class="token key atrule">effect</span><span class="token punctuation">:</span> NoSchedule <span class="token comment">#调度规则，还有NoExecute等</span></code></pre>

<p>例如对于网络插件来说，在节点还没有被纳入网络时，仍然需要在该节点上建立用于控制的Pod，此时就需要容忍network-unavaliable的污点。</p>
<p>对于Deployment来说，其通过ReplicaSet来进行版本控制，而只有一个Pod的DaemonSet则通过<code>ControllerRevision</code>对象来进行版本控制。可以通过<code>kubectl get controllerVision</code>来看。实际上ContorllerRevision就是在其Data段记录了该版本的template。可以通过<code>kubectl rollout undo daemonset $&#123;name&#125; --to--revision=$&#123;version&#125; rolled back</code>。</p>
<p>回滚实际上做的是patch更新，一个新的ControllerRevision会被创建出来(版本号+1)。</p>
<h4 id="撬动离线业务：Job与CronJob"><a href="#撬动离线业务：Job与CronJob" class="headerlink" title="撬动离线业务：Job与CronJob"></a>撬动离线业务：Job与CronJob</h4><p>离线业务：也称为<strong>Batch</strong> Job(计算任务)，需要在计算结束以后自然退出。</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Job
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
        <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
        <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"..."</span><span class="token punctuation">]</span>
      <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never
  <span class="token key atrule">backOffLimit</span><span class="token punctuation">:</span> <span class="token number">4</span> <span class="token comment">#失败重启的最大次数</span>
  <span class="token key atrule">activeDeadlineSeconds</span><span class="token punctuation">:</span> <span class="token number">110</span> <span class="token comment">#运行时间不超过110秒</span></code></pre>

<p>通过describe可以看到Job对象的Pod模板被加上了一个controller-uid&#x3D;${随机字符串}的Label，而Job本身则有了一个该label的selector</p>
<p>Completed不会重启，Failed会重启。</p>
<p>也可以定义并行任务</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">parallelism</span><span class="token punctuation">:</span> <span class="token number">2</span> <span class="token comment">#最大并行数(同一时间有多少Pod可以同时运行，默认为1)</span>
      <span class="token key atrule">completions</span><span class="token punctuation">:</span> <span class="token number">4</span> <span class="token comment">#最小完成度(至少要完成的Pod数目)</span></code></pre>

<p>常用的使用方法：</p>
<ul>
<li><p>制定Job模板(在name部分使用变量)，然后使用外部管理器来指定变量从而创建Job</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># job-template.yaml</span>
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>$VAR
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token punctuation">...</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span></code></pre>

<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> a b c
<span class="token keyword">do</span>
  <span class="token function">cat</span> job-tempate.yaml <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">"s/\<span class="token variable">$VAR</span>/<span class="token variable">$i</span>"</span> <span class="token operator">></span> ./jobs/job-<span class="token variable">$i</span>.yaml <span class="token comment">#用sed命令将$var替换为这里的i</span>
<span class="token keyword">done</span>
kubectl create <span class="token parameter variable">-f</span> ./jobs <span class="token comment">#将文件夹内的yaml全部创建出来</span></code></pre>
</li>
<li><p>使用工作队列(例如使用外部程序作为生产者)进行任务分发，Job在指定并发度下进行消费，这种一般在completions固定的情况下使用</p>
</li>
<li><p>有并行度，但没有completions。这种需要为每个Pod制定退出的条件</p>
</li>
</ul>
<p><strong>CronJob</strong>：Job的控制器，定时任务</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v1beta1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> CronJob
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">schedule</span><span class="token punctuation">:</span> <span class="token string">"*/1 * * * *"</span> <span class="token comment">#空格分隔的五个部分分别代表分钟 小时 日 月 星期，/表示每，*表示0，1表示1个单位。意思是每一分钟执行一次</span>
  <span class="token key atrule">jobTemplate</span><span class="token punctuation">:</span>
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">template</span><span class="token punctuation">:</span>
        <span class="token key atrule">spec</span><span class="token punctuation">:</span>
          <span class="token punctuation">...</span>
  <span class="token key atrule">concurrencyPolicy</span><span class="token punctuation">:</span> Allow <span class="token comment">#Forbid跳过/Replace替换，表示上一次Job没结束，此次任务启动的策略</span>
  <span class="token key atrule">startingDeadlineSeconds</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>interval<span class="token punctuation">&#125;</span> <span class="token comment">#interval秒内Job创建失败了100次，那么Job将不会再被创建</span></code></pre>

<h4 id="声明式API与Kubernetes编程范式"><a href="#声明式API与Kubernetes编程范式" class="headerlink" title="声明式API与Kubernetes编程范式"></a>声明式API与Kubernetes编程范式</h4><p>想要通过修改本地配置文件来修改一个对象，有两种方式，先编辑配置文件，然后</p>
<ul>
<li><p><code>kubectl replace -f $&#123;filename&#125;</code>：使用新的对象覆盖旧对象(命令式配置文件操作)</p>
<blockquote>
<p>对象之前是通过<code>kubectl create</code>创建出来的</p>
</blockquote>
</li>
<li><p><code>kubectl apply -f $&#123;filename&#125;</code>：对原对象执行了一次patch操作</p>
<blockquote>
<p>对象之前是通过<code>kubectl apply</code>创建出来的</p>
</blockquote>
</li>
</ul>
<p>patch操作(可以理解为merge地写)可以让对象有多个<strong>写</strong>端，从而能够并发地(k8s，插件，用户都有可能)进行修改。</p>
<p>以<code>Dynamic Admission Control</code>(<code>Initializer</code>)为例，它可以动态地做到对象在被k8s处理之前进行一些初始化工作：</p>
<ul>
<li><p>用configMap存储操作要用到的数据</p>
</li>
<li><p>先将一个编写好的initializer作为Pod</p>
</li>
<li><p>执行如下伪代码</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
    pod <span class="token operator">:=</span> <span class="token function">getLatestPod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">initialized</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        cm <span class="token operator">=</span> <span class="token function">getConfigMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        newPod <span class="token operator">=</span> <span class="token function">Pod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token function">change</span><span class="token punctuation">(</span>newPod<span class="token punctuation">,</span> cm<span class="token punctuation">)</span>
        
        patchBytes <span class="token operator">=</span> <span class="token function">CreateTwoWayMergePatch</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> newPod<span class="token punctuation">)</span>
        client<span class="token punctuation">.</span><span class="token function">Patch</span><span class="token punctuation">(</span>patchBytes<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p>也可以自己配置操作对象的范围</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> admissionregisteration.k8s.io/v1alpha1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> InitializerConfiguration
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
<span class="token key atrule">initializer</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span> <span class="token comment">#名字至少需要包含两个.</span>
    <span class="token key atrule">rules</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> <span class="token string">""</span> <span class="token comment">#意思是Core API Group</span>
        <span class="token key atrule">apiVersions</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> v1
        <span class="token key atrule">resources</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> pods</code></pre>

<p>之后新的Pod会附带上metadata.initializers.pending，内容包含initializer的名字</p>
<blockquote>
<p>所以initializer根绝pending判断Pod有没有被初始化，以及初始化完之后要清除这个标志</p>
</blockquote>
<blockquote>
<p>当然也可以在Pod的metadata.annotations里著名initializer，例如</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>
   <span class="token key atrule">"initializer.kubernetes.io/envoy"</span><span class="token punctuation">:</span> <span class="token string">"true"</span>
   <span class="token punctuation">...</span></code></pre></blockquote>
</li>
</ul>
<h4 id="声明式API的工作原理"><a href="#声明式API的工作原理" class="headerlink" title="声明式API的工作原理"></a>声明式API的工作原理</h4><p>API对象在etcd中的完整路径由Group、Version和Resouce(API<strong>资源类型</strong>)三个部分组成，以树形结构组织，例如</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> batch/v2alpha
<span class="token key atrule">kind</span><span class="token punctuation">:</span> CronJob</code></pre>

<p>中，<code>batch</code>是Group，<code>v2alpha</code>是version，<code>CronJob</code>是Resource。对于Pod等核心api，直接按照version写的那样从&#x2F;api下面匹配即可(<code>/api/v1/pods</code>)，而对于其他非核心api，需要在&#x2F;apis下面匹配(<code>/apis/batch/v2alpha/cronjobs</code>)</p>
<p>POST请求创建API对象流程：</p>
<style>.pvdqcwryvoxu{zoom: 50%;}</style><img src="/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/86e52f8f403c4661a3dcdb1482b9ce1d.jpg" class="pvdqcwryvoxu">

<ol>
<li>经过过滤器过滤POST请求，完成授权等前置工作</li>
<li>经过MUX等，完成URL与Handler的绑定</li>
<li>处理该Post请求Handler的查找API对象的类型定义</li>
<li>将yaml文件<strong>转换</strong>为<code>Super Version</code>的对象(该API对象的所有版本的字段全集)，用来统一处理不同版本的yaml文件</li>
<li>Admission &amp; Validation(合法api对象被存入registry)</li>
<li>转换回原版本，序列化后存入etcd</li>
</ol>
<p>CRD的创建这部分书上代码不全且版本落后，具体例子可参考<a target="_blank" rel="noopener" href="https://github.com/kubernetes/sample-controller">sample-controller</a></p>
<blockquote>
<p>apiextensions.k8s.io&#x2F;v1beata1 is deprecated in k8s v1.22.0 version.</p>
</blockquote>
<h4 id="API编程范式的具体原理"><a href="#API编程范式的具体原理" class="headerlink" title="API编程范式的具体原理"></a>API编程范式的具体原理</h4><img src="/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/8ea3266543164081af35dc4061d65cca.jpg" class="">

<p>控制器通过<code>Informer</code>获取它关心的对象。<code>Informer</code>通过<code>Reflector</code>包与APIServer建立链接，获取并监听对象的(增量)变化【例如增减对象就是通过Indexer控制的】，将其放入队列中。同时也不断从队列中读取对象【通过go routine建立若干个无限循环的协程】，根据增量类型<strong>修改informer的缓存</strong>，调用对应handler【使用neutron去修改真正的集群内容】。</p>
<blockquote>
<p>Informer往往响应迅速，而控制循环则可能会比较慢，因此用工作队列可以解耦二者</p>
</blockquote>
<h4 id="基于角色的权限控制：RBAC"><a href="#基于角色的权限控制：RBAC" class="headerlink" title="基于角色的权限控制：RBAC"></a>基于角色的权限控制：RBAC</h4><p>Role-based access control</p>
<ul>
<li>Role：角色，定义一组对API对象的操作权限</li>
<li>Subject：被作用者</li>
<li>RoleBinding：二者的绑定关系</li>
</ul>
<p>举例：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Role
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> mynamespace <span class="token comment">#通过namespace(逻辑上的管理单位，API对象默认为default)来指定产生作用的范围</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> example<span class="token punctuation">-</span>role
<span class="token key atrule">rules</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>
  <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"pods"</span><span class="token punctuation">]</span>
  <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">]</span> <span class="token comment">#还有create，update等等</span>
  <span class="token comment"># 需要指定某几个对象的话，可以用resourceNames: ["...", "..."]</span></code></pre>

<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> RoleBinding
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> mynamespace
  <span class="token key atrule">name</span><span class="token punctuation">:</span> example<span class="token punctuation">-</span>rolebinding
<span class="token key atrule">subjects</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> User <span class="token comment">#作用对象为User类型，即k8s的用户</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> exampe<span class="token punctuation">-</span>user
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io
<span class="token key atrule">roleRef</span><span class="token punctuation">:</span> <span class="token comment">#要绑定的Role</span>
  <span class="token key atrule">kind</span><span class="token punctuation">:</span> Role
  <span class="token key atrule">name</span><span class="token punctuation">:</span> example<span class="token punctuation">-</span>role <span class="token comment">#绑定之前定义的example-role</span>
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io</code></pre>

<p>对于非Namespaced的对象，比如Node等等，可以使用ClusterRole和ClusterRoleBinding，在metadata中不需要有namespace项</p>
<p>k8s的内置用户对象为<code>ServiceAccount</code>，更多时候我们直接使用它就可以了，而不需要使用<code>User</code></p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiversion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> mynamespace
  <span class="token key atrule">name</span><span class="token punctuation">:</span> example<span class="token punctuation">-</span>sa
<span class="token comment">#----------------------------</span>
<span class="token key atrule">kind</span><span class="token punctuation">:</span> RoleBinding
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> mynamespace
  <span class="token key atrule">name</span><span class="token punctuation">:</span> example<span class="token punctuation">-</span>rolebinding
<span class="token key atrule">subjects</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount
  <span class="token key atrule">name</span><span class="token punctuation">:</span> exampe<span class="token punctuation">-</span>sa
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> mynamespace
<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>
  <span class="token key atrule">kind</span><span class="token punctuation">:</span> Role
  <span class="token key atrule">name</span><span class="token punctuation">:</span> example<span class="token punctuation">-</span>role
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io</code></pre>

<p>创建完SA之后，k8s会自动生成一个secret对象。之后可以在Pod的<code>spec</code>中指定<code>serviceAccountName</code>，k8s会将证书文件挂载到容器内（namespace下没有声明SA的，会创建一个拥有大部分权限的default SA，因此生产环境中可以为default SA规定<strong>只读</strong>权限）。</p>
<p>同样，SA也有用户组的概念。SA在k8s中对应用户的名字为<code>system:serviceaccount:$&#123;name&#125;</code>，对应的用户组名字为<code>system:serviceaccounts:$&#123;namespace&#125;</code>。因此可以</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">subjects</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> Group
  <span class="token key atrule">name</span><span class="token punctuation">:</span> system<span class="token punctuation">:</span>serviceaccounts<span class="token punctuation">:</span>mynamespace <span class="token comment">#如果仅有system:serviceaccounts就是针对所有namespace</span>
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io</code></pre>

<p>四个内置ClusterRole：<code>cluster-admin</code>，<code>admin</code>，<code>edit</code>，<code>view</code></p>
<h4 id="聪明的微创新：Operator工作原理解读"><a href="#聪明的微创新：Operator工作原理解读" class="headerlink" title="聪明的微创新：Operator工作原理解读"></a>聪明的微创新：Operator工作原理解读</h4><p>Operator可以利用k8s的<strong>CRD</strong>来描述想要部署的<strong>有状态应用</strong>，然后在自定义控制器中定义具体的部署和运维工作。</p>
<h3 id="Kubernetes存储原理"><a href="#Kubernetes存储原理" class="headerlink" title="Kubernetes存储原理"></a>Kubernetes存储原理</h3><h4 id="持久化存储：PV和PVC的设计与实现原理"><a href="#持久化存储：PV和PVC的设计与实现原理" class="headerlink" title="持久化存储：PV和PVC的设计与实现原理"></a>持久化存储：PV和PVC的设计与实现原理</h4><p>PV和PVC和“面向对象”的思想非常类似，PVC就是<strong>接口</strong>，而具体的PV则是<strong>实现</strong></p>
<p>k8s内部的PersistentVolumeController会不断查看每个PVC是否处于Bound状态，并为未绑定的PVC遍历所有PV尝试绑定。</p>
<p>持久化Volume的目录<strong>不会因为容器的删除而被清理</strong>，也<strong>不会跟宿主机绑定</strong>，因此其实现往往依赖一个远程存储服务，例如NFS等等</p>
<blockquote>
<p>hostpath和emptyDir不具有这个特征，既可能被清理，也不能迁移到其他节点上</p>
</blockquote>
<p>一般来说，k8s准备持久化目录PV的过程分为两个阶段</p>
<table>
<thead>
<tr>
<th></th>
<th>远程块存储</th>
<th>远程文件存储</th>
</tr>
</thead>
<tbody><tr>
<td>阶段一(<strong>Attach</strong>)</td>
<td>在宿主机上挂载磁盘</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>阶段二(<strong>Mount</strong>)</td>
<td>将磁盘格式化后挂载到宿主机volume目录</td>
<td>将远程目录挂载到宿主机volume目录</td>
</tr>
</tbody></table>
<blockquote>
<p>PV的路径为<code>/var/lib/kubelet/pods/$&#123;pod id&#125;/volumes/kubernetes.io-$&#123;volume type&#125;/$&#123;name&#125;</code></p>
</blockquote>
<p>k8s也提供了可以自动创建PV的机制：<code>Dynamic Provisioning</code>(之前是<code>Static Provisioning</code>)，通过<code>StorageClass</code>来自动创建PV模板。</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> storage.k8s.io/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> StorageClass
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> block<span class="token punctuation">-</span>service
<span class="token key atrule">provisioner</span><span class="token punctuation">:</span> kubernetes.io/gce<span class="token punctuation">-</span>pd <span class="token comment">#要使用的存储插件，实际上PV是由存储插件生成的</span>
<span class="token key atrule">parameters</span><span class="token punctuation">:</span> <span class="token comment">#PV的相关属性</span>
  <span class="token key atrule">type</span><span class="token punctuation">:</span> pd<span class="token punctuation">-</span>ssd
<span class="token comment">#-----------------------------------------------</span>
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> claim1
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> ReadWriteOnce
  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> block<span class="token punctuation">-</span>service <span class="token comment">#由于StorageClass生成的PV也带有SC的name，所以让PVC和PV匹配是个容易的事情</span>
  <span class="token key atrule">resources</span><span class="token punctuation">:</span>
    <span class="token key atrule">requests</span><span class="token punctuation">:</span>
      <span class="token key atrule">storage</span><span class="token punctuation">:</span> 30Gi</code></pre>

<p>StorageClass并不仅仅用于Dynamic Provisioning，因为直接声明PV时给其StorageName属性赋一个不存在的Class也是可以的，这样是Static Provisioning，只要后面PVC也带有相同的属性，那还是可以匹配的。</p>
<h4 id="深入理解本地持久化数据"><a href="#深入理解本地持久化数据" class="headerlink" title="深入理解本地持久化数据"></a>深入理解本地持久化数据</h4><p>LocalPV(本地的持久化存储)的难点</p>
<ul>
<li><p>如何把本地磁盘抽象为PV？</p>
<p>宿主机目录不应该作为PV，因为无法保证磁盘空间不被其他应用争用导致空间不足。PV需要的一定是一块<strong>额外挂载</strong>在宿主机上的磁盘或者块设备</p>
<blockquote>
<p>Linux上可以使用<code>mount -t tmpfs $&#123;device name&#125; $&#123;dir like /mnt/...&#125;</code>来使用tmpfs临时挂载出一个磁盘设备</p>
</blockquote>
</li>
<li><p>如何保证Pod被调度到正确的node上去？</p>
<p>LocalPV强调local，那就一定和具体的node关联。因此调度Pod时需要知道这些信息</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume
<span class="token punctuation">...</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span>
  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> local<span class="token punctuation">-</span>storage
  <span class="token key atrule">local</span><span class="token punctuation">:</span>
    <span class="token key atrule">path</span><span class="token punctuation">:</span> /mnt/disks/vol1 <span class="token comment">#PV的路径</span>
  <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span>
    <span class="token key atrule">required</span><span class="token punctuation">:</span>
      <span class="token key atrule">nodeSelectorTerms</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> kubernetes.io/hostname
          <span class="token key atrule">operator</span><span class="token punctuation">:</span> In
          <span class="token key atrule">values</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> node<span class="token punctuation">-</span><span class="token number">1</span> <span class="token comment">#规定Pod一定要在node-1上</span></code></pre>

<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> storageClass
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> storage.k8s.io/v1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> local<span class="token punctuation">-</span>storage
<span class="token key atrule">provisioner</span><span class="token punctuation">:</span> kubernetes.io/no<span class="token punctuation">-</span>provisioner <span class="token comment">#没有插件来生产PV</span>
<span class="token key atrule">volumeBindingMode</span><span class="token punctuation">:</span> WaitForFirstConsumer <span class="token comment">#延迟绑定特性，等到某个使用该PVC的Pod出现在调度器以后再尝试与PV绑定，这样可以让调度器综合考虑所有调度要求</span></code></pre></li>
</ul>
<p>删除local PV的过程</p>
<ol>
<li>删除Pod</li>
<li>宿主机移除该硬盘(例如<code>umount</code>)</li>
<li>删除PVC</li>
<li>删除PV</li>
</ol>
<p>另外k8s也提供了<strong>Static Provisioner</strong>插件来帮助将<code>/mnt/disks/</code>下每一个挂载都创建一个PV对象</p>
<h4 id="开发自己的存储插件：FlexVolume与CSI"><a href="#开发自己的存储插件：FlexVolume与CSI" class="headerlink" title="开发自己的存储插件：FlexVolume与CSI"></a>开发自己的存储插件：FlexVolume与CSI</h4><p>CSI的原理：</p>
<style>.spwbqxjyafzm{zoom: 75%;}</style><img src="/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/image-20230209140836991.jpg" class="spwbqxjyafzm" alt="image-20230209140836991">

<ul>
<li><code>Driver Registar</code>将插件注册到kubelet中，它需要请求<code>CSI Identity</code>的信息</li>
<li><code>External Provisioner</code>负责provision，它监听PVC对象的创建，并调用<code>CSI Controller</code>的CreateVolume方法创建PV</li>
<li><code>External Attacher</code>负责attach，它监听VolumeAttachment(确认volume可以进入attach阶段的标志)的变化</li>
<li>Mount时直接调用<code>CSI Node</code>完成，不需要外部组件</li>
</ul>
<blockquote>
<p>实际使用时将三个外部组件和CSI放在同一个Pod中</p>
</blockquote>
<h3 id="Kubernetes网络原理"><a href="#Kubernetes网络原理" class="headerlink" title="Kubernetes网络原理"></a>Kubernetes网络原理</h3><h4 id="单机容器网络的实现原理"><a href="#单机容器网络的实现原理" class="headerlink" title="单机容器网络的实现原理"></a>单机容器网络的实现原理</h4><p>容器看见的网络栈(包括网卡，回环设备，路由表和iptables规则)隔离在它自己的Network Namespace中。容器的默认网关是docker0，所以外部的网络请求会经过docker0送往宿主机，对于处于同一网段的IP，容器的网关是0.0.0.0(即直连)，此时通过MAC寻址来通信。</p>
<p>有关docker0网桥的更多内容见本站另一篇博客：Docker网络虚拟化</p>
<h4 id="深入解析容器跨主机网络"><a href="#深入解析容器跨主机网络" class="headerlink" title="深入解析容器跨主机网络"></a>深入解析容器跨主机网络</h4><p>Flannel的三种后端实现</p>
<ul>
<li><p>UDP，性能最差，已被弃用</p>
<p>每个宿主机和其容器构成一个<strong>子网</strong>，每个节点有一个fannel0的TUN(tunnel)设备，它可以在内核和用户应用程序fanneld之间传递IP包。因此数据流为容器-&gt;docker0-&gt;flanneld-&gt;eth0-&gt;…(对称)。从flanneld到宿主机的过程中使用UDP封装，并且flannel通过检测目标容器的IP得到目标宿主机的IP，从而达到网络连接的目的。</p>
<style>.hilbzeswfydq{zoom:50%;}</style><img src="/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/image-20230211101318181.jpg" class="hilbzeswfydq" alt="image-20230211101442521">

<blockquote>
<p>用户态容器-&gt;内核态docker0-&gt;用户态flanneld-&gt;内核态eth0，一次发包经历三次不同态之间的复制，消耗很大</p>
</blockquote>
</li>
<li><p>VXLAN(virtual extensible LAN)，Linux内核支持的网络虚拟化技术</p>
<p>在传统三层网络之上覆盖二层网络，以VTEP设备作为隧道的两端，VTEP具有独立的IP和MAC</p>
<style>.ptvyrikqppwc{zoom:50%;}</style><img src="/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/image-20230211101442521.jpg" class="ptvyrikqppwc" alt="image-20230211101442521">

<p>当一个新的node加入集群后，flannel会为其他node加上发往该网段的包必须经由flannel.1设备发送的路由规则。VTEP收到原始IP报后，会用目的VTEP的MAC封装一个二层数据报，然后为了让Linux识别再加上一个VLAN Header，最后交给宿主机以UDP的形式发出去。由于宿主机的FDB转发数据库也是由flannel.1维护的，所以它也可以知道目的宿主机的IP。</p>
<table>
<thead>
<tr>
<th>外部以太网头</th>
<th>外部IP头</th>
<th>外部UDP头</th>
<th>VXLAN Header</th>
<th>内部以太网头</th>
<th>目的容器地址</th>
<th>$\cdots$</th>
</tr>
</thead>
<tbody><tr>
<td>目的主机的MAC</td>
<td>目的主机的IP</td>
<td>$\cdots$</td>
<td>一些标志位</td>
<td><strong>目的VTEP</strong>的MAC</td>
<td>目的容器的IP</td>
<td>$\cdots$</td>
</tr>
</tbody></table>
</li>
<li><p>host-gw</p>
</li>
</ul>
<h4 id="Kubernetes网络模型与CNI网络插件"><a href="#Kubernetes网络模型与CNI网络插件" class="headerlink" title="Kubernetes网络模型与CNI网络插件"></a>Kubernetes网络模型与CNI网络插件</h4><p>kubernetes用<code>CNI</code>接口维护了一个单独的cni网桥来替代docker0，名字叫cni0，node1路由表的规则</p>
<ul>
<li>发往本网段内的包由cni0处理</li>
<li>发往集群外部某node网段的包由flannel.1设备处理</li>
<li>发往docker网段的包由docker0处理</li>
</ul>
<p>CNI的设计思想就是Kubernetes在启动Infra容器之后能够直接调用CNI网络插件来配置网络栈</p>
<p>CNI插件分为如下几类(<code>kubeasz</code>安装的话都在<code>/opt/kube/bin/</code>中)：</p>
<ul>
<li>Main插件，用于创建具体网络设备，例如bridge、ipvlan等</li>
<li>IPAM插件，ip address management，例如dhcp、host-local</li>
<li>内置插件，例如flannel</li>
</ul>
<p>Pod网络构建流程：</p>
<ol>
<li>flanneld在每台宿主机上生成CNI配置文件</li>
<li>kubelet主干代码不负责容器网络，而是交由CRI(Container Runtime Interface)进行，docker的CRI是dockershim，它来加载上述配置文件</li>
<li>dockershim调用Docker API创建Infra容器，然后调用CNI插件配置网络。参数第一部分来自dockershim主动设置的环境变量，包括容器里网卡的名字(rth0)，Pod Namespace文件的路径，以及<code>CNI_ARGS</code>这一自定义参数等；第二部分来自CNI配置。</li>
<li>flannel的CNI配置中<code>delegate</code>字段表明这个插件实际工作的交付者。因此Flannel CNI插件的作用就是简单地在delegate中补充一些配置信息，同时保存在<code>/var/lib/cni/flannel</code>下</li>
<li>创建cni0网桥(如果没有的话)，进入network namespace创建veth pair设备，将这端的名字设为参数中容器网卡的名字，将另一端归属于cni0网桥(可能要设置Hairpin Mode来允许同一个包从这个端口进来又出去，因此如果设置了容器的端口转发，容器内部访问宿主机哪个端口时实际上会回到容器里)</li>
</ol>
<blockquote>
<p>因此在k8s中，所有的容器之间都是可以“通”的，容器看到的ip与真实ip是一致的</p>
</blockquote>
<h4 id="解读Kubernetes三层网络方案"><a href="#解读Kubernetes三层网络方案" class="headerlink" title="解读Kubernetes三层网络方案"></a>解读Kubernetes三层网络方案</h4><p>即只使用原来的三层网络</p>
<ul>
<li><p>host-gw(host-gateway)</p>
<p>给node1的路由表设置node2网段IP对应的<strong>下一跳IP</strong>为node2的IP并且通过eth0设备发送，由于设置了下一跳IP，此时数据链路层就会用下一跳IP查出的MAC地址封装数据包。到达node2后，发现目的IP为子网中容器的IP，此时交由cni0处理</p>
<table>
<thead>
<tr>
<th>目的MAC</th>
<th>目的IP</th>
</tr>
</thead>
<tbody><tr>
<td>node2的MAC</td>
<td>node2中容器的IP</td>
</tr>
</tbody></table>
<blockquote>
<p>由于需要node1知道node2的MAC，因此host-gw要求集群之间是<strong>二层可达的</strong></p>
<p>但也由此相比VXLAN<strong>减少了性能损耗</strong></p>
</blockquote>
</li>
<li><p>Calico</p>
<p>原理大致与host-gw相同，但是使用了<code>BGP</code>协议来在集群中分发路由信息。Calico项目由以下三个部分组成</p>
<ul>
<li><p>CNI插件</p>
</li>
<li><p>Felix，负责在宿主机上插入路由规则的DaemonSet</p>
</li>
<li><p>BIRD，BGP客户端，负责在集群中分发路由信息</p>
</li>
</ul>
<p>另外Calico<strong>不会在集群中创建任何的网桥设备</strong>，而是直接为每个容器创建连到宿主机上的veth pair(由于没有网桥，因此宿主机路由规则里也要写明去本网段xx容器IP得经由xxveth设备)</p>
<p>默认情况下Calico维护的网络遵循Node-toNode Mesh模式，$N^2$量级，因此推荐100以下用。大规模集群推荐使用Route Reflector模式，即指定若干节点来学习全局路由信息，其余节点仅跟这几个节点交换信息。</p>
<p>开启<code>IPIP</code>模式以后，Calico可以突破二层网络的限制。具体做法是将node1上到node2子网下一跳的eth0设备替换为tunl0设备(IP隧道设备)，然后在外面封装一层IP报头，伪装成node1到node2的IP包</p>
<table>
<thead>
<tr>
<th>目的MAC</th>
<th>目的IP</th>
<th>payload</th>
</tr>
</thead>
<tbody><tr>
<td>下一跳路由器的MAC</td>
<td>node2的IP</td>
<td>原IP数据报</td>
</tr>
</tbody></table>
<p>不扩展host-gw给中间路由器也指定网段下一跳mac的原因是公有云环境下用户肯定不能随意更改服务器配置</p>
</li>
</ul>
<h4 id="Kubernetes中的网络隔离：NetworkPolicy"><a href="#Kubernetes中的网络隔离：NetworkPolicy" class="headerlink" title="Kubernetes中的网络隔离：NetworkPolicy"></a>Kubernetes中的网络隔离：NetworkPolicy</h4><p>Calico、Weave均实现了NetworkPolicy，Flannel需要额外安装前述二者中一个</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/vl
<span class="token key atrule">kind</span><span class="token punctuation">:</span> NetworkPolicy
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>network<span class="token punctuation">-</span>policy
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">podselector</span><span class="token punctuation">:</span> <span class="token comment">#如果设为&#123;&#125;，那就是对Namespace下所有Pod起作用</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
      <span class="token key atrule">role</span><span class="token punctuation">:</span> db <span class="token comment">#所有携带了role=db的Pod</span>
  <span class="token key atrule">policyTypes</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> Ingress
  <span class="token punctuation">-</span> Egress
  <span class="token key atrule">ingress</span><span class="token punctuation">:</span> <span class="token comment">#流入白名单</span>
  <span class="token punctuation">-</span> <span class="token key atrule">from</span><span class="token punctuation">:</span> <span class="token comment">#下方列表项间是“或”关系，列表项内才是与关系，因此可以在列表项内定义并列的(同一缩进层级)ipBlock和namespaceSelector规则</span>
    <span class="token punctuation">-</span> <span class="token key atrule">ipBlock</span><span class="token punctuation">:</span> <span class="token comment">#源地址属于172.17.0.0/16且不属于172.17.1.0/24</span>
        <span class="token key atrule">cidr</span><span class="token punctuation">:</span> 172.17.0.0/16
        <span class="token key atrule">except</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> 172.17.1.0/24
    <span class="token punctuation">-</span> <span class="token key atrule">namespaceSelector</span><span class="token punctuation">:</span>
        <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
          <span class="token key atrule">project</span><span class="token punctuation">:</span> myproject
    <span class="token punctuation">-</span> <span class="token key atrule">podSelector</span><span class="token punctuation">:</span>
        <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
          <span class="token key atrule">role</span><span class="token punctuation">:</span> frontend
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP
      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>
  <span class="token key atrule">egress</span><span class="token punctuation">:</span> <span class="token comment">#流出白名单</span>
  <span class="token punctuation">-</span> <span class="token key atrule">to</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">ipBlock</span><span class="token punctuation">:</span>
        <span class="token key atrule">cidr</span><span class="token punctuation">:</span> 10.0.0.0/24
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">protocal</span><span class="token punctuation">:</span> TCP
      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5978</span></code></pre>

<p>NetworkPolicy通过iptables规则来实现隔离，而iptables实际上操作的是Linux的Netfilter</p>
<img src="/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/netfilter.jpg" class="" title="img">

<h4 id="找到容器不容易：Service、DNS与服务发现"><a href="#找到容器不容易：Service、DNS与服务发现" class="headerlink" title="找到容器不容易：Service、DNS与服务发现"></a>找到容器不容易：Service、DNS与服务发现</h4><p>Service也通过iptables设置转发规则，通过对转发目的的概率设置，从而实现deployment下Pod的负载均衡</p>
<p>但是这样也造成大量Pod存在时，iptables不断更新带来性能的损耗，因此推荐开启kube-proxy的IPVS模式，大致就是搞一个虚拟网卡，把VIP分配给他以后设置多台虚拟主机，每台直接代理一个Pod，然后它们以轮询规则作为负载均衡策略。因为IPVS在内核态，所以无需频繁切换到内核态维护iptables。</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>DNS记录</th>
</tr>
</thead>
<tbody><tr>
<td>ClusterIP模式的Service</td>
<td><code>$&#123;service-name&#125;.$&#123;namespace&#125;.svc.cluster.local</code></td>
</tr>
<tr>
<td>ClusterIP&#x3D;None模式的Headless Service</td>
<td>同上，但返回的是所有被代理的Pod的IP地址的集合</td>
</tr>
<tr>
<td>ClusterIP模式Service代理的Pod</td>
<td><code>$&#123;pod-name&#125;.$&#123;service-name&#125;.$&#123;namespace&#125;.svc.cluster.local</code></td>
</tr>
<tr>
<td>Headless Service代理的声明了hostname和subdomain的Pod</td>
<td><code>$&#123;hostname&#125;.$&#123;subdomain&#125;.$&#123;namespace&#125;.svc.cluster.local</code></td>
</tr>
</tbody></table>
<h4 id="从外界连通Service与Service调试“三板斧”"><a href="#从外界连通Service与Service调试“三板斧”" class="headerlink" title="从外界连通Service与Service调试“三板斧”"></a>从外界连通Service与Service调试“三板斧”</h4><p>由于Service依赖宿主机上kube-proxy生成的iptables规则和DNS记录，因此离开集群后这些信息是无用的。</p>
<p>从外部访问Service主要有如下方式：</p>
<ul>
<li><p>使用NodePort</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">nodePort</span><span class="token punctuation">:</span> <span class="token number">8080</span> <span class="token comment">#暴露给外部的端口</span>
    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">30080</span> <span class="token comment">#暴露在Cluster IP的端口，集群内部访问Service</span>
    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span> <span class="token comment">#代理的Pod的端口，实际访问Pod:这个端口</span>
    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP
    <span class="token key atrule">name</span><span class="token punctuation">:</span> http</code></pre>

<p>Kuberetes会对离开宿主机的IP包(仅限于因为Service而被转发的，可以通过DNAT过程加上去的0x4000标志检测)做SNAT，将源IP换成自己的IP或者自己网桥的IP。这也很容易理解，例如client-&gt;node2，但是node2因为负载均衡把包转给了node1，此时如果node1收到的包src是client的话，那回复给client会造成client的收发不一致。因此需要node2给node1转发时把src IP换成自己的，组hi后再从自己这回client。</p>
<p>如果需要明确知道具体是哪个Pod在负责处理请求，那这样是不行的，可以开启spec.externalTrafficPolicy&#x3D;local，让请求只会被转发到自己node上的Pod。</p>
</li>
<li><p>使用LoadBalancer，适用于公有云服务</p>
</li>
<li><p>使用ExternalName，相当于在kube-dns添加了一条CNAME别名记录，访问xxx.cluster.local和访问externalName效果相同</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">type</span><span class="token punctuation">:</span> ExternalName
  <span class="token key atrule">externalName</span><span class="token punctuation">:</span> my.database.example.com</code></pre>
</li>
<li><p>使用externalIP来代理Pod，这个IP得是你能够路由到的在集群中的一个节点</p>
</li>
</ul>
<h4 id="Kubernetes中的Ingress对象"><a href="#Kubernetes中的Ingress对象" class="headerlink" title="Kubernetes中的Ingress对象"></a>Kubernetes中的Ingress对象</h4><p>Ingress相当于Service的”Service”</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">tls</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> cafe.example.com
    <span class="token key atrule">secretName</span><span class="token punctuation">:</span> cafe<span class="token punctuation">-</span>secret
  <span class="token key atrule">rules</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> cafe.example.com <span class="token comment">#必须是标准的域名格式字符串，不能是IP地址</span>
    <span class="token key atrule">http</span><span class="token punctuation">:</span>
      <span class="token key atrule">paths</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /tea <span class="token comment">#域名下不同的路径交给不同的service</span>
        <span class="token key atrule">backend</span><span class="token punctuation">:</span>
          <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> tea<span class="token punctuation">-</span>svc
          <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">80</span>
      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /coffee
        <span class="token key atrule">backend</span><span class="token punctuation">:</span>
          <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> coffee<span class="token punctuation">-</span>svc
          <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre>

<p>可以使用Nginx Ingress Controller等等Ingress Controller来检测Ingress对象的创建，自动创建相关负载均衡服务，之后这可以用一个Service对外暴露这个服务即可。</p>
<blockquote>
<p>使用到的yaml文件需要查阅相关controller提供的资料</p>
</blockquote>
<h3 id="Kubernetes的资源模型与资源管理"><a href="#Kubernetes的资源模型与资源管理" class="headerlink" title="Kubernetes的资源模型与资源管理"></a>Kubernetes的资源模型与资源管理</h3><h4 id="Kubernetes的资源模型与资源管理-1"><a href="#Kubernetes的资源模型与资源管理-1" class="headerlink" title="Kubernetes的资源模型与资源管理"></a>Kubernetes的资源模型与资源管理</h4><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> db
    <span class="token punctuation">...</span>
    <span class="token key atrule">resources</span><span class="token punctuation">:</span>
      <span class="token key atrule">requests</span><span class="token punctuation">:</span>
        <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"64Mi"</span> <span class="token comment">#64MB内存，单位可以是Mi，M，Ki，K……</span>
        <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"250m"</span> <span class="token comment">#250millicpu，即0.25个CPU的计算能力，这里写0.25也可以</span>
      <span class="token key atrule">limits</span><span class="token punctuation">:</span>
        <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"128Mi"</span>
        <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"500m"</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
  <span class="token comment">#最终Pod占用的资源是容器占用资源的总和，其中内存资源不可压缩，缺失会造成Out-Of-Memory从而被内核终止，CPU资源可压缩，缺失仅会造成一定程度的饥饿</span></code></pre>

<p><code>requests</code>是调度时使用的资源量，即Pod<strong>一开始</strong>会申请这么多资源以供调度，limits则是Cgroups中设立的最大资源量。当node不满足Pod的requests时，Pod会被调度到其他节点(失败重启)</p>
<p>若requests和limits中cpu的值为<strong>相等的整数n</strong>，那么会使其<strong>绑定到n个cpu</strong>上</p>
<blockquote>
<p>类似于cpuset功能，减少cpu之间的上下文切换</p>
</blockquote>
<p>Pod的三种QoS(Quality-Of-Service)级别：</p>
<ul>
<li>Guaranteed：每个容器都同时设置了requests和limits(只有limits时requests与其一致，因此也是该情况)</li>
<li>Burstable：至少有一个容器设置了requests</li>
<li>BestEffort：啥也没有</li>
</ul>
<p>当整个kubernetes宿主机的资源发生不足，例如内存、文件系统可用空间低于阈值，会触发Eviction即资源回收，回收优先级依次为：</p>
<ol>
<li>BestEffort</li>
<li>Burstable且对象处于饥饿且资源使用量超过requests</li>
<li>Guaranteed且资源使用量超过limits或宿主机memory pressure</li>
</ol>
<blockquote>
<p>因此建议将DaemonSet的Pod都设为Guaranteed类型，否则其被回收之后会立刻创建，从而造成回收的失效</p>
</blockquote>
<h4 id="Kubernetes的默认调度器"><a href="#Kubernetes的默认调度器" class="headerlink" title="Kubernetes的默认调度器"></a>Kubernetes的默认调度器</h4><style>.jtyncdzwejng{zoom:40%;}</style><img src="/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/image-20230214135305115.jpg" class="jtyncdzwejng" alt="image-20230214135305115">

<p>两个控制循环：</p>
<ul>
<li><p>Informer负责监听Pod的变化，更新调度器缓存以及维护优先队列</p>
</li>
<li><p>主循环</p>
<ul>
<li><p>从队列中Pop出Pod</p>
</li>
<li><p>进行Predicate操作，选出潜在的node</p>
</li>
<li><p>进行Priorities操作，对潜在node进行打分</p>
</li>
<li><p>Bind操作只更新缓存，称为Assume，乐观</p>
<blockquote>
<p>失败不要紧，同步操作最终会让现实与调度器缓存一致</p>
</blockquote>
</li>
<li><p>发起Goroutine联系API server发起异步请求</p>
<blockquote>
<p>实际Pod开始执行时，也会再跑一次Predicates进行二次确认</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="Kubernetes默认调度器调度策略解析"><a href="#Kubernetes默认调度器调度策略解析" class="headerlink" title="Kubernetes默认调度器调度策略解析"></a>Kubernetes默认调度器调度策略解析</h4><p>Predicates预选主要有四种</p>
<ol>
<li><p>GeneralPredicates，简单地考察node的资源是否够Pod的requests</p>
</li>
<li><p>Volume相关</p>
<ul>
<li>NoDiskConflict：多个Pod声明挂载的PV是否有冲突(不允许被共享之类)</li>
<li>MaxPDVolumeCountPredicate：检查一个节点上某个类型的PV是否超过了一定数目</li>
<li>VolumeZonePredicate：检查Zone标签(高可用域)是否匹配</li>
<li>VolumeBindingPredicate：nodeAffinity字段是否匹配</li>
</ul>
</li>
<li><p>宿主机相关，比如PodToleratesNodeTaints，只有污点被允许时才能调度，NodeMemoryPressurePredicate，内存是否足够</p>
</li>
<li><p>Pod相关，大多和general重合，另外有考察Pod和已有的Pod之间affinity(亲密度)和anti-affinity的关系</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>
    <span class="token key atrule">podAntiAffinity</span><span class="token punctuation">:</span> <span class="token comment">#反亲密度</span>
      <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span> <span class="token comment">#调度时必须考虑</span>
      <span class="token punctuation">-</span> <span class="token key atrule">weight</span><span class="token punctuation">:</span> <span class="token number">100</span>
        <span class="token key atrule">podAffinityTerm</span><span class="token punctuation">:</span>
          <span class="token key atrule">labelSelector</span><span class="token punctuation">:</span>
            <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span> <span class="token comment">#不与携带有security=S2的Pod在一个节点上</span>
            <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> security
              <span class="token key atrule">operator</span><span class="token punctuation">:</span> in
              <span class="token key atrule">values</span><span class="token punctuation">:</span>
              <span class="token punctuation">-</span> S2
          <span class="token key atrule">topologyKey</span><span class="token punctuation">:</span> kubernetes.io/hostname <span class="token comment">#作用域为那些携带了kubernetes.io/hostname标签的节点</span></code></pre></li>
</ol>
<p>实际会并发16个Goroutine，为所有node计算shi否合适</p>
<p>Priorities优选策略</p>
<p>最常用的是LeastRequestedPriority(空闲资源最多)和BanlancedResourceAllocation(分配最平均)等</p>
<h4 id="Kubernetes默认调度器的优先级和抢占机制"><a href="#Kubernetes默认调度器的优先级和抢占机制" class="headerlink" title="Kubernetes默认调度器的优先级和抢占机制"></a>Kubernetes默认调度器的优先级和抢占机制</h4><p><code>PriorityClass</code>示例：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> scheduling.k8s.io/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> PriorityClass
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> high<span class="token punctuation">-</span>priority
<span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token number">1000000</span> <span class="token comment">#不大于1e9的整数</span>
<span class="token key atrule">globalDefault</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment">#为true则成为系统默认值，false则只作用于这个PriorityClass</span>
<span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"..."</span></code></pre>

<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span>
  <span class="token key atrule">priorityClassName</span><span class="token punctuation">:</span> high<span class="token punctuation">-</span>priority</code></pre>

<p>这个value就体现在默认调度器的优先队列中</p>
<p>当高优先级Pod调度失败时，发生抢占事件。此时并不会立刻抢占，而是将抢占者的<code>spec.nominatedNodeName</code>设为将被抢占的节点名字，等到被抢占者_优雅退出_以后才被调度。在此期间给更高优先级抢占者的到来留下了充足的时间。</p>
<p>抢占算法使用了两个队列</p>
<ul>
<li><p>activeQ：下一个调度周期需要调度的对象</p>
<blockquote>
<p>Pop出队发生在这个队列中</p>
</blockquote>
</li>
<li><p>unschedulableQ：调度失败的对象</p>
<blockquote>
<p>unschedulableQ中Pod更新以后，会被挪到activeQ中重新<strong>给予机会</strong></p>
</blockquote>
</li>
</ul>
<p>抢占流程：</p>
<ol>
<li><p>检查调度失败原因，<strong>确认抢占可以找到新节点</strong></p>
</li>
<li><p>复制一份缓存中的节点信息，用副本来模拟找出最佳结果，得出牺牲者列表</p>
<ol>
<li><p>清理牺牲者列表中的<code>nominatedNodeName</code></p>
</li>
<li><p>设置抢占者的<code>nominatedNodeName</code> &gt; 进入activeQ</p>
<blockquote>
<p>如果其优先级很低，那可能还不如普通高优先级Pod</p>
</blockquote>
</li>
<li><p>向API server逐一删除牺牲者</p>
</li>
</ol>
</li>
</ol>
<p>由于有抢占者的存在，因此一对Pod和节点之间进行预选时其实要运行两次预选算法，第一次是假设潜在抢占者在节点上运行(防止有InterPodAntiAffinity)，第二次假设不在，只有<strong>两次都通过了</strong>才会将Pod和节点视为可绑定</p>
<h4 id="Kubernetes-GPU管理与Device-Plugin机制"><a href="#Kubernetes-GPU管理与Device-Plugin机制" class="headerlink" title="Kubernetes GPU管理与Device Plugin机制"></a>Kubernetes GPU管理与Device Plugin机制</h4><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
    <span class="token key atrule">resources</span><span class="token punctuation">:</span>
      <span class="token key atrule">limits</span><span class="token punctuation">:</span>
        <span class="token key atrule">nvida.com/gpu</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment">#k8s并不在乎这个key的含义是什么，它只管计算value是否超出了容量</span></code></pre>

<p>在kubernetes中，资源可用量来自于Node对象的<code>Status</code></p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Node
<span class="token punctuation">...</span>
<span class="token key atrule">Status</span><span class="token punctuation">:</span>
  <span class="token key atrule">Capacity</span><span class="token punctuation">:</span>
    <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token number">2</span>
    <span class="token key atrule">memory</span><span class="token punctuation">:</span> 2049008Ki</code></pre>

<p>因此可以用PATCH操作来增加自定义资源量的记录</p>
<p>实际上这样的工作可以交给Device Plugin来管理。</p>
<style>.xpiglvnewnvn{zoom: 50%;}</style><img src="/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/image-20230214161132561.jpg" class="xpiglvnewnvn" alt="image-20230214161132561">

<p>Device Plugin通过gRPC的方式与kubelet通信，ListAndWatch接口负责定时汇报GPU列表，Allocate接口负责分配一个可用GPU，返回设备路径和驱动路径。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/Blog/tags/Container/" rel="tag"># Container</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/Blog/2022/10/15/2022-10-15%E7%BB%84%E4%BC%9A/" rel="prev" title="2022-10-15组会">
                  <i class="fa fa-chevron-left"></i> 2022-10-15组会
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/Blog/2022/10/23/cpp-easygraph%E6%96%87%E6%A1%A3/" rel="next" title="cpp_easygraph文档">
                  cpp_easygraph文档 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Cui</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/Blog/js/comments.js"></script><script src="/Blog/js/utils.js"></script><script src="/Blog/js/motion.js"></script><script src="/Blog/js/next-boot.js"></script>

  


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.7/mermaid.min.js","integrity":"sha256-G58AID1YoX5YaEtWfXSI0VLrZ6N4kvNvwg0BI8zUFxE="}}</script>
  <script src="/Blog/js/third-party/tags/mermaid.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/Blog/js/third-party/math/mathjax.js"></script>



</body>
</html>
