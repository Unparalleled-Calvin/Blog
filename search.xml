<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022-10-15组会</title>
    <url>/Blog/2022/10/15/2022-10-15%E7%BB%84%E4%BC%9A/</url>
    <content><![CDATA[<h3 id="CLARE-A-Semi-supervised-Community-Detection-Algorithm"><a href="#CLARE-A-Semi-supervised-Community-Detection-Algorithm" class="headerlink" title="CLARE: A Semi-supervised Community Detection Algorithm"></a>CLARE: A Semi-supervised Community Detection Algorithm</h3><p>KDD2022 <a href="https://www.microsoft.com/en-us/research/uploads/prod/2022/08/KDD_CLARE-1.pdf">PDF</a></p>
<p>社群检测算法无法检测出某种特定的社群</p>
<p>现有的方法可以归纳为seed based methods，在选定的seed旁边发展community</p>
<p>SEAL通过序列化决策，效率较低</p>
<p>核心思想</p>
<ul>
<li>精确定位器Locator</li>
<li>子图生成器Rewritor</li>
<li>进一步优化Optimization</li>
</ul>
<p>locator从潜在社群找出最好的匹配，找出的社群也带有周边结点的信息以帮助进一步操作【借鉴subgraph】</p>
<p>将社群embedding，然后用nearest neighbor</p>
<p>然后是rewrite阶段，从选出的候选中，drop掉无关的点以及boundary中的东西，Exclude Net&#x2F;Expand Net，增减图信息</p>
<p>Task</p>
<ul>
<li>Action：从exclude集以及expand集中选择动作</li>
<li>Reward：以分类的F1 score的形式体现</li>
</ul>
<p>Optimization：Policy Gradient</p>
<p>How does the rewriting implemented in the neural network? </p>
<p>rewriter是预训练的，训练完之后把东西喂进去</p>
<h3 id="Multiscale-mixing-patterns-in-networks"><a href="#Multiscale-mixing-patterns-in-networks" class="headerlink" title="Multiscale mixing patterns in networks"></a>Multiscale mixing patterns in networks</h3><p>PNAS2018 <a href="https://arxiv.org/pdf/1708.01236">pdf</a></p>
<p>异构图上的link</p>
<p>可以用assortativity coefficient来计算</p>
<p>感觉这篇文章就是提出了local assortivity的计算，还有用assortivity来做了一些network上的分析</p>
]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>KDD</tag>
        <tag>Community</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-10-19讨论班</title>
    <url>/Blog/2023/10/19/2023-10-19%E8%AE%A8%E8%AE%BA%E7%8F%AD/</url>
    <content><![CDATA[<p>Fuzzing Deep Learning Compilers with HirGen (ISSTA’23)</p>
<p>Deep Learning Compiler：</p>
<p>source -&gt; high level IR -&gt; low level IR -&gt; CPU和GPU之指令</p>
<p>先fuzz出一个计算图(coverage guidence)，如果HIR没问题，跑着看看oracle</p>
<ul>
<li>计算图构建：<ul>
<li>考虑类型和大小的约束</li>
<li>故意生成错误的图(边与节点的类型等等)测试编译器能不能正常处理</li>
</ul>
</li>
<li>三种Coverage<ul>
<li>op与dtype的组合</li>
<li>op与shape的组合</li>
<li>op与op的组合</li>
</ul>
</li>
<li>Oracles<ul>
<li>Crash</li>
<li>IR被优化前后执行结果不一致</li>
<li>不同设备(CPU-GPU)的计算结果不一致</li>
</ul>
</li>
</ul>
<p>Evaluation：</p>
<ul>
<li>看效率</li>
<li>看自己的guidence有没有用：Mann-Whitney U Test统计方法</li>
</ul>
<p>Stylette: Styling the Web with Natural Language (CHI’2022)</p>
<p>CHI：人机交互顶会</p>
<p>改变网页样式以契合用户的需求，手动改CSS对终端用户不友好</p>
<p>speakout loud 有啥痛点直接说</p>
<p>Goals</p>
<ul>
<li>模糊的自然语言-&gt;具体的更改</li>
<li>……</li>
</ul>
<p>工作流：自然语言-&gt;可能的css更改-&gt;用户选择</p>
<p>发这篇paper的时候还没有chatgpt</p>
<p>现在chatgpt理解抽象的能力不错</p>
]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>Fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-10-26讨论班</title>
    <url>/Blog/2023/10/26/2023-10-26%E8%AE%A8%E8%AE%BA%E7%8F%AD/</url>
    <content><![CDATA[<p>当代CPU微架构简介</p>
<p>指令级是微架构无关的，微架构在CPU内部</p>
<p>流水线有性能瓶颈</p>
<ul>
<li>拆得太细利用率低【bubble】</li>
</ul>
<p>微架构前端</p>
<ul>
<li>将指令转为和当前CPU相关的微指令</li>
<li>一个串行的length decoder之后是多个并行的decoder<ul>
<li>Complex decoder和多个Simple decoder，前者负责解码重要的、改变CPU状态的指令(从ROM中读解码规则【CPU中的软件】，因此可以升级CPU)</li>
</ul>
</li>
<li>decode部分占的晶体管不多，主要是branch predication</li>
</ul>
<p>微架构中端</p>
<ul>
<li>目标：乱序&#x2F;并行地执行uop</li>
<li>难点<ul>
<li>数据依赖<ul>
<li>def &amp; use：每个计算赋值操作都可以换名，cpu内部的寄存器要多于ISP规定的寄存器。如此可以减少依赖长度，支持并行</li>
<li>为什么对eax赋值要set rax高32位？将eax的使用看作rax的def，从而将减少依赖长度【eax与ax没这个关系，那个时候架构还不像现在这样】</li>
</ul>
</li>
<li>分支不确定<ul>
<li>guess：分支历史表、跳转目标表</li>
<li>顺序Commit+回滚：所以用到的寄存器只有在commit之后才被释放</li>
</ul>
</li>
<li>串行指令：例如换页表、控制寄存器等，会对后面的指令产生剧烈影响</li>
<li>分支指令：猜错相当于串行指令</li>
<li>长周期指令：例如cache miss，tlb miss等，阻塞commit队列</li>
</ul>
</li>
</ul>
<p>多核架构</p>
<p>多数民用cpu都保证cache一致性</p>
<ul>
<li>同一个cacheline可以被共享读，但独占写<ul>
<li>和锁变量在同一个cacheline中的变量都躺枪了</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>System</tag>
        <tag>CPU， 微架构</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-11-16讨论班</title>
    <url>/Blog/2023/11/16/2023-11-16%E8%AE%A8%E8%AE%BA%E7%8F%AD/</url>
    <content><![CDATA[<p><strong>An Introduction to LLM-based Multi-Agent System.</strong></p>
<p>Agent：一个综合性系统，能够适应定义好的环境，完成相关的任务</p>
<ul>
<li>组件：profile，memory(长期，短期)，planning，action</li>
</ul>
<p>Multi-Agent：分割功能，更高内聚&#x3D;&gt;更高的token效率</p>
<p>两个思路：</p>
<ul>
<li>每个Agent拥有自己的四个组件，独立完成小任务</li>
<li>每个Agent只负责一个组件的整个或部分功能</li>
</ul>
<p>实现方式</p>
<ul>
<li>群聊式：有个群主，协调各个Agent的工作</li>
</ul>
<p>还挺有趣的，感觉可以一定程度上缓解多轮对话带来的token混淆，区分Agent的角色有助于子任务获得更好的效果。例如Programmer&#x2F;Executor&#x2F;Reviewer</p>
<p><strong>Scaling Up Memory Disaggregated Applications with Smart.</strong> <strong>(ASPLOS 2024)</strong></p>
<p>现有的DM架构在io bound的任务下有一定的问题</p>
<p>Doorbell 寄存器的竞争，任务描述数据放在queue pair中，通过门铃寄存器提醒网卡。由于门铃有限，需要用自旋锁来等待。</p>
<p>如果qp中任务量太大，可能会造成cache thrashing——任务被发送出去后，远端的pair做完了会回一个消息，此时需要根据meta data找这个任务，如果cache miss会有缓慢的PCIe DMA read，所以抖动会造成相当的问题</p>
<p>CAS(compare and switch)太多重试会占满带宽</p>
<p>Design</p>
<ul>
<li>使用QP池【没太听懂】</li>
<li>动态限制并发数——消耗credit才能send</li>
<li>冲突避免——wait一会再retry</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>2023-11-30讨论班</title>
    <url>/Blog/2023/11/30/2023-11-30%E8%AE%A8%E8%AE%BA%E7%8F%AD/</url>
    <content><![CDATA[<h4 id="Large-Language-Model-amp-High-Perforam-Calculation"><a href="#Large-Language-Model-amp-High-Perforam-Calculation" class="headerlink" title="Large Language Model &amp; High Perforam Calculation"></a>Large Language Model &amp; High Perforam Calculation</h4><p>大模型的训练离不开高性能计算</p>
<p>训练过程：先<strong>pre-train</strong>一个base model，再<strong>fine tune</strong>一个aligned model，用于<strong>inference</strong></p>
<p>训练优化：</p>
<ul>
<li><p>三维并行化 粒度从粗到细，可以一起做</p>
<ul>
<li><p>DP 数据并行</p>
<ul>
<li><p>简单的数据分发训练，但是需要做同步。</p>
<p>每个mini batch并行计算完之后需要同步各个optimizer的状态，这就导致每个<strong>节点需要存储所有的参数</strong></p>
</li>
<li><p>现在用ZeRO-DP，将优化器的<strong>状态</strong>进行分割，通过即时通讯索取数据，让自己只需要存储自己这一块的内容</p>
</li>
</ul>
</li>
<li><p>PP 流水线并行</p>
<ul>
<li>把线性的计算任务拆分到不同的device&#x3D;&gt;也可以省内存</li>
<li>把流水线拆得更细</li>
</ul>
</li>
<li><p>TP Tensor并行</p>
<ul>
<li>数学上等价的矩阵拆分计算&#x3D;&gt;也可以省内存</li>
</ul>
</li>
</ul>
</li>
<li><p>Kernel(算子)优化</p>
</li>
</ul>
<p>NCCL提供了一个通信框架库，有描述这些通信的通信原语</p>
<p>NVLink Bridge &amp; NVSwitch：主机内的多GPU高速通信网络</p>
<p>然后NV也提了一个多主机互联的硬件组织架构，用200GPS光纤链接</p>
<p>目前实践上支持主机内高速互联，然后每个GPU配一个网卡，通过PCIE传输数据</p>
<ul>
<li><p>每个网卡接到不同的交换机(网络平面)——资源均摊</p>
</li>
<li><p>网络平面：</p>
<ul>
<li><p>例子：两层胖树，每个树干交换机可以连64个leaf，每个leaf可以连32个树干，32个网卡端口</p>
<p>-&gt; 最多只能连2048(64*32)个GPU【？】，如果要扩展，可能就要多层。因此用多个网络平面来节省资源，同时由于一个GPU连了8个平面，因此平面和平面之间的数据对GPU来说都是可达的</p>
</li>
</ul>
</li>
</ul>
<p>LLM 33B 64G 256GPUS token1k&#x2F;s</p>
<p>关于可靠性</p>
<ul>
<li>时间扰动的影响，当机子数目增加，被扰动的概率是很高的，例如GC,timer等，这会导致并行时间的下降</li>
<li>硬件故障……</li>
<li>快速恢复：checkpoint的<strong>异步</strong>保存、checkpoint的载入、高速存储</li>
</ul>
<p>推理优化：最新工作VLLM，数学等价拆分</p>
<img src="/Blog/2023/11/30/2023-11-30%E8%AE%A8%E8%AE%BA%E7%8F%AD/LLM.jpg" class="" title="LLM相关学习资料">

]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-11-9讨论班</title>
    <url>/Blog/2023/11/09/2023-11-9%E8%AE%A8%E8%AE%BA%E7%8F%AD/</url>
    <content><![CDATA[<p>fitness function: 评估测试用例的函数，要不要留下这个种子？</p>
<p>白盒，黑盒，灰盒(观察测试用例的执行，指导下一个，例如通过coverage作为fitness function指导下一次测试用例)</p>
<p>污点流分析 </p>
<p>对于黑盒测试来说，可以自定义Coverage空间，用来补充说明自己的实验</p>
<ul>
<li>但是由于缺少语义，黑盒比较难测出bug</li>
</ul>
<blockquote>
<p>白盒+guidance</p>
</blockquote>
<p>输入：基于生成&#x2F;基于突变</p>
<p>符号执行</p>
<p>预处理：对种子的 优化&#x2F;选择&#x2F;修剪&#x2F;重组</p>
<p>基于模型的生成：根据一些预定义的模型来生成输入</p>
<p>基于推断的生成：根据学习已有的测试数据，生成新的测试数据（可能有依赖问题，需要结合静态&#x2F;动态的方法）</p>
<p>生成器生成：要测decoder程序(例如pdf解析器)，可以取对应的encoder程序(例如pdf生成器)，通过轻微改动生成器来获得能触发decoder bug的case【很奇怪……】</p>
<p>内存快照，提高fuzz效率，AFL也有持久模式的</p>
<p>要根据程序性质来指导fuzz，可以结合静态&#x2F;动态……方法</p>
<p>IR根据抽象程度的不同分为HIR, MIR, LIR</p>
<p>MIR不依赖源语言和具体的CPU架构，通常和优化和变换有关</p>
]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>Fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-12-14讨论班</title>
    <url>/Blog/2023/12/14/2023-12-14%E8%AE%A8%E8%AE%BA%E7%8F%AD/</url>
    <content><![CDATA[<h4 id="从基础架构角度看大模型推理优化"><a href="#从基础架构角度看大模型推理优化" class="headerlink" title="从基础架构角度看大模型推理优化"></a>从基础架构角度看大模型推理优化</h4><p>模型侧</p>
<ul>
<li>量化——将以前高bit数存储的数据转为低bit数存储的数据，例如用16bit short代替32bit float<ul>
<li>能放下的参数更多</li>
<li>数据传输速度更快</li>
</ul>
</li>
<li>稀疏化<ul>
<li>在参数矩阵中一些位置挖空置0，从而以稀疏矩阵的形式传输，Nvidia支持满足一定约束的稀疏矩阵计算</li>
</ul>
</li>
<li>蒸馏<ul>
<li>得到的小模型能够表现出与大模型类似的能力</li>
</ul>
</li>
<li>KV cache</li>
</ul>
<p>系统侧</p>
<ul>
<li>并行化【iterative infer带来的革新】<ul>
<li>大模型时代，经验上来看计算量越大，最匹配的语料+参数得到的Loss越好，但是内存&#x2F;通信开销成为了瓶颈</li>
<li>数据并行&#x2F;张量并行&#x2F;流水线并行 见<a href="/Blog/2023/11/30/2023-11-30%E8%AE%A8%E8%AE%BA%E7%8F%AD/" title="2023-11-30讨论班">2023-11-30讨论班</a></li>
<li>传统的CV模型可能只做第一个并行，后两者由于CV网络连接方式多元、模块之间计算量不平衡等问题难以做到，但是大模型由于都是Transformer，做起来就很容易</li>
</ul>
</li>
</ul>
<p>自回归推理引擎</p>
<p>推理的第一步是把不完整的句子经过prefill转为向量</p>
<p>在batch的过程中仍然有early stop和late arrive等问题，因为是一个词一次迭代，batch中的多个句子最终形态可能词数不一致</p>
<ul>
<li>iteration-level schedule</li>
<li>prefill以及generate的过程中有一些是request无关的计算，把在这些步骤batch里的数据拼到一起【如果模型对向量中的数据不敏感的话】，在attention这种request有关的东西执行时再拆开</li>
</ul>
<p>KV cache</p>
<ul>
<li>传统的bert每次都需要计算之前的信息</li>
<li>存储之前所有词对应的value，从而在迭代推理过程中不用重复计算</li>
</ul>
<p>Memory Management</p>
<p>GPU借鉴Linux的COW思想</p>
]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-12-28讨论班</title>
    <url>/Blog/2023/12/28/2023-12-28%E8%AE%A8%E8%AE%BA%E7%8F%AD/</url>
    <content><![CDATA[<h4 id="Do-Users-Write-More-Insecure-Code-with-AI-Assistants-CCS23"><a href="#Do-Users-Write-More-Insecure-Code-with-AI-Assistants-CCS23" class="headerlink" title="Do Users Write More Insecure Code with AI Assistants? CCS23"></a><strong>Do Users Write More Insecure Code with AI Assistants?</strong> CCS23</h4><p>Empirical Study，心理学</p>
<ul>
<li>AI assistant是否会写更多unsafe code——会，因为AI模型训练数据很多就unsafe</li>
<li>用户是否信任？——用户会信任这些代码</li>
<li>如何构造prompt和迭代prompt</li>
</ul>
<p>做对照实验，5道算法题找人做，有&#x2F;无AI</p>
<p>统计上显著性检验要求的solid的被试数：问题数*10</p>
<p>分层：相同性质的一层，逐层采</p>
<p>雪球：先找到一个，然后从这个为抓手顺着这个找其他相同性质的</p>
<p>组内设计：同一个组的人在不同的条件下做同一套测试(但是可以加入随机)</p>
<img src="/Blog/2023/12/28/2023-12-28%E8%AE%A8%E8%AE%BA%E7%8F%AD/%E8%B0%83%E6%9F%A5%E6%96%B9%E6%B3%95.jpg" class="" title="调查方法">

<h4 id="AppAgent-Multimodal-Agents-as-Smartphone-Users-arXiv-2023"><a href="#AppAgent-Multimodal-Agents-as-Smartphone-Users-arXiv-2023" class="headerlink" title="AppAgent: Multimodal Agents as Smartphone Users. arXiv 2023"></a>AppAgent: Multimodal Agents as Smartphone Users. arXiv 2023</h4><p>大模型的Agent能做的事有限，理解能力不够</p>
<p>基于DOM tree标注页面可以点击的元素，一一标号</p>
<p>用户操作&#x2F;解释给Agent，然后它存储下来</p>
]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>CCS</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-12-21讨论班</title>
    <url>/Blog/2023/12/21/2023-12-21%E8%AE%A8%E8%AE%BA%E7%8F%AD/</url>
    <content><![CDATA[<h3 id="Hostping：Diagnosing-Intra-host-Network-Bottlenecks-in-RDMA-Servers"><a href="#Hostping：Diagnosing-Intra-host-Network-Bottlenecks-in-RDMA-Servers" class="headerlink" title="Hostping：Diagnosing Intra-host Network Bottlenecks in RDMA Servers"></a>Hostping：Diagnosing Intra-host Network Bottlenecks in RDMA Servers</h3><p>NSDI23 <a href="https://www.usenix.org/system/files/nsdi23-liu-kefei.pdf">论文原文</a> <a href="https://www.usenix.org/system/files/nsdi23_slides_liu-kefei.pdf">slides</a></p>
<p>CPU和CPU之间通过特定协议(Intel-UPI&#x2F;AMD)在通道间通信</p>
<p>memory channel: 指CPU暴露给内存的接口的通道数(非内存内通道数)</p>
<p>网卡和CPU通信通过PCIe链路进行，由于CPU的PCIe接口数有限，因此通过PCIe Switch之类的设备帮助多个外设复用同一个PCIe接口(可能还会再连一个PCIe Hub更低一级)</p>
<p>主机内部网络的瓶颈：无损模式下由于线路老化可能突然RNIC的线路degrade了，此时由于buffer被快速挤满，因此RNIC网卡会回返Tx PFC告诉下面上面已经满了。——可能带来PFC storm或者PFC deadlock</p>
<p>如果不是无损模式则可能有包的drop</p>
<img src="/Blog/2023/12/21/2023-12-21%E8%AE%A8%E8%AE%BA%E7%8F%AD/%E6%9C%89%E6%8D%9F%E6%A8%A1%E5%BC%8F.jpg" class="">



<p>GDR：GPU Direct RDMA，GPU直接访问其他机器上GPU的显存</p>
<p>本文讨论的机器内部结构，这里Socket可以理解为CPU</p>
<img src="/Blog/2023/12/21/2023-12-21%E8%AE%A8%E8%AE%BA%E7%8F%AD/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.jpg" class="" title="拓扑结构">

<p>硬件设备和设备不能直接通过Switch互联，还是得先去CPU走Access Control Service</p>
<p>本篇motivation：RNIC的带宽增长太快，PCIe4.0带宽速率支持不上了，同时PICe拓展的各个独特设备的复杂拓扑也导致可能的故障问题</p>
<p>因此设计这个Hostping用来帮助辨认这些问题，比如不知道是主机的问题还是网络的问题等等</p>
<ul>
<li>主机空闲(负载&lt;5%)，测试硬件的延迟和带宽</li>
<li>主机繁忙时，如果RNIC寄存器有异常，那么测量网络</li>
</ul>
<p>测出每个RNIC到硬件的metrics(带宽)后，得出一个metrics矩阵，然后本文中的问题都可以从这个矩阵中看出pattern</p>
<p>对比baseline标记出正常链路，从而推断拓扑下的异常链路【正常的链路中每段都是正常的，剩余的难以分辨的可以标记为异常】</p>
<p>但是有时异常是由于链路问题，有时可能是因为错误配置【Root Complex控制器】导致，这里通过时延来区分二者</p>
<p>如果很多RNIC到memory有问题，那么可能是memory channel有问题</p>
<p>Disscussion: 可能还是idea比较好，说服力、开销、metric的选取等还有待商榷</p>
]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>NSDI</tag>
        <tag>RDMA</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-9-14讨论班</title>
    <url>/Blog/2023/09/14/2023-9-14%E8%AE%A8%E8%AE%BA%E7%8F%AD/</url>
    <content><![CDATA[<h3 id="API-Fuzz-Driver-Generation"><a href="#API-Fuzz-Driver-Generation" class="headerlink" title="API Fuzz Driver Generation"></a>API Fuzz Driver Generation</h3><p>Fuzz是个框架，Fuzz Driver是要测的序列，所以这里说的是对于API的Fuzz如何生成序列</p>
<p>Fuzzing的关键是构造Fuzz Dirver以及Input Generator</p>
<p>既然Fuzz需要接受输入执行代码，那如何应用到lib等API上？</p>
<ul>
<li>API有依赖关系，Data、Control</li>
<li>构建符合API语义的代码</li>
</ul>
<p>相关工作</p>
<ul>
<li><p>收集<strong>用户代码</strong>片段，通过call graph构建API依赖关系</p>
<blockquote>
<p>语义更好，收集高质量较难</p>
</blockquote>
<ul>
<li><p>工作1：首先由一批CFG的执行图，清除无关的api调用得到精简图，将这些图中的公共顶点合并，跑一遍DFS去除环，得到合并后的CFG图和拓扑序</p>
</li>
<li><p>工作2：将用户程序抽象为自动机(程序状态点，函数调用、控制判断为边)，然后简化自动机，合并啥的</p>
<blockquote>
<p>用自动机的原因是他能标识判断的多分支</p>
</blockquote>
</li>
</ul>
</li>
<li><p>从<strong>API文档</strong>等构建依赖图，根据图游走构建序列</p>
<blockquote>
<p>覆盖更全，序列较短，语义不足</p>
</blockquote>
<ul>
<li>工作1：期望覆盖更多API依赖图</li>
<li>工作2：初始是单独的API node，通过mutation组装这些node</li>
</ul>
</li>
</ul>
<p>对于有复杂签名的API暂时没有好的处理方法，例如泛型函数，rust有Trait Bound，Java有基于Interface的约束，C++20有Concept约束。程序可能会生成原来库里没有的函数签名。</p>
<p>Solution表示一种泛型参数的取值，Match是用具体的类型匹配泛型函数，而Mono则是函数的单态化</p>
<p>使用其他API涉及的类型逐步推导更多的Match，然后生成所有可能的单态化函数，删除行为相同的单态化函数（行为用函数调用的方法集表示）。针对优化过的这些单态化函数进行覆盖等操作。</p>
<h3 id="Generative-Type-Inference-for-Python（ASE’23）"><a href="#Generative-Type-Inference-for-Python（ASE’23）" class="headerlink" title="Generative Type Inference for Python（ASE’23）"></a>Generative Type Inference for Python（ASE’23）</h3><p>静态类型推断——coverage比较低</p>
<p>有监督的类型推断：用训练的方式推断——需要大量的优质数据</p>
<p>利用nlp的填空模型填入模型——可解释性欠缺</p>
<p>TypeGen：利用大语言模型对话式地推断——可解释性变好了</p>
<ul>
<li>对象的上下文就是knowledge<ul>
<li>代码裁剪：生成对象的类型依赖图-&gt;移除和当前要分析的变量无关的变量</li>
</ul>
</li>
<li>合法类型<ul>
<li>用户定义的类型+python类型+第三方包类型(他们对top10000的第三方库建了一个数据库可以直接拿出来)</li>
</ul>
</li>
<li>用这些信息拼起来作为prompt喂给大模型</li>
</ul>
<p>My Comment：工作量就一两周，还是故事讲得好，有一定的参考意义</p>
]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>Fuzz</tag>
        <tag>ASE&#39;23</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-9-1讨论班</title>
    <url>/Blog/2023/09/02/2023-9-1%E8%AE%A8%E8%AE%BA%E7%8F%AD/</url>
    <content><![CDATA[<h2 id="FUSEE-A-Fully-Memory-Disaggregated-Key-Value-Store"><a href="#FUSEE-A-Fully-Memory-Disaggregated-Key-Value-Store" class="headerlink" title="FUSEE: A Fully Memory-Disaggregated Key-Value Store"></a>FUSEE: A Fully Memory-Disaggregated Key-Value Store</h2><p>当前在分布式内存上的KV存储主要通过单一服务器来管理元数据，本文主要是克服这一问题。</p>
<blockquote>
<p>原先如此设计的原因主要是内存大的节点可能并不具有强大的计算能力以处理</p>
</blockquote>
<p>所做的工作：</p>
<ul>
<li>在内存结点上建立元数据的拷贝并直接管理</li>
<li>提出一个以客户端为中心的协议允许客户端并发地访问和修改多拷贝的索引</li>
<li>使用两层内存管理框架来分割客户端和内存结点管理内存的责任</li>
</ul>
<p>一些需要解决的问题：</p>
<ul>
<li>以客户端为中心的索引拷贝：一致性问题不易使用传统方法解决，因为内存结点的计算能力不强且需要良好的可拓展性<ul>
<li>SNAPSHOT协议，合作式解决一致性问题</li>
</ul>
</li>
<li>远程内存分配：传统方法在完全分布式下无效；且客户端通信需要多个RTT<ul>
<li>将计算任务分成轻重两类，分别交给相应内存结点</li>
</ul>
</li>
<li>客户端失效带来的数据污染：（并没有完全理解实际场景）修改执行到一半客户端失效，被污染的数据却产生持久影响<ul>
<li>使用log</li>
</ul>
</li>
</ul>
<p>一般来说在远端处理request的机器需要有多个cpu提供算力处理并发请求</p>
<ul>
<li>云计算中心资源会有浪费，例如CPU资源已经用满，但是内存还有空余</li>
<li>容错不解耦</li>
</ul>
<p>内存分离架构DM</p>
<ul>
<li>计算资源和内存资源解耦——不同节点掌握的资源是不平衡的，可以使用RDMA(0 copy, kernel bypass)等高速网路连接</li>
</ul>
<h2 id="Is-unsafe-an-Achilles’-Heel-A-Comprehensive-Study-of-Safety-Requirements-in-Unsafe-Rust-Programming"><a href="#Is-unsafe-an-Achilles’-Heel-A-Comprehensive-Study-of-Safety-Requirements-in-Unsafe-Rust-Programming" class="headerlink" title="Is unsafe an Achilles’ Heel? A Comprehensive Study of Safety Requirements in Unsafe Rust Programming"></a>Is unsafe an Achilles’ Heel? A Comprehensive Study of Safety Requirements in Unsafe Rust Programming</h2><ul>
<li>定义了19个“安全”属性</li>
<li>rust中调用了unsafe API的代码块需要加上unsafe关键字以通过编译</li>
</ul>
<p>rust具有编译时的安全检查，作为面向系统级的编程语言，还是需要指针等数据结构与访问操作的。</p>
<p>unsafe是rust的关键字，CVE基本与unsafe有关</p>
]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>DM</tag>
        <tag>Storage</tag>
        <tag>Rust</tag>
        <tag>Safety</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-9-21讨论班</title>
    <url>/Blog/2023/09/21/2023-9-21%E8%AE%A8%E8%AE%BA%E7%8F%AD/</url>
    <content><![CDATA[<h3 id="Large-Language-Models-are-Edge-Case-Fuzzers-Testing-Deep-Learning-Libraries-via-FuzzGPT"><a href="#Large-Language-Models-are-Edge-Case-Fuzzers-Testing-Deep-Learning-Libraries-via-FuzzGPT" class="headerlink" title="Large Language Models are Edge-Case Fuzzers: Testing Deep Learning Libraries via FuzzGPT"></a>Large Language Models are Edge-Case Fuzzers: Testing Deep Learning Libraries via FuzzGPT</h3><p>Edge-Case&#x2F;Conner-Case 不常见的样例</p>
<p>用的是codex，chatgpt在代码上训练的模型；以及codegen</p>
<ul>
<li>zero-shot：啥也不给，只让它生成Edge Case</li>
<li>few-shot：开孔填空，在code上按照一定的pattern挖洞，然后让llm补充，循环进行</li>
<li>fine-tune：喂数据，从pr里拉之前容易引发bug的代码，人先标注有限的case，然后作为prompt提供给大模型</li>
</ul>
<h3 id="Marlin-A-Concurrent-and-Write-Optimized-B-tree-Index-on-Disaggregated-Memory-ICPP’23"><a href="#Marlin-A-Concurrent-and-Write-Optimized-B-tree-Index-on-Disaggregated-Memory-ICPP’23" class="headerlink" title="Marlin: A Concurrent and Write-Optimized B+-tree Index on Disaggregated Memory (ICPP’23)"></a>Marlin: A Concurrent and Write-Optimized B+-tree Index on Disaggregated Memory (ICPP’23)</h3><p>在DM上高性能B+树索引</p>
<ul>
<li>Insert&#x2F;Delete&#x2F;Update 并发控制开销大（锁的粒度不够小）<ul>
<li>这篇文章将叶子上的的kv改成key+pointer以避免在index上阻塞地写数据&#x3D;&gt;只要先准备好数据，快速地改pointer就行了。而这就牺牲了范围查询地效率，因为每次根据pointer查具体的内存位置都要走一次index</li>
</ul>
</li>
<li>Structural Modification Operation和IDU的同步导致效率低<ul>
<li>FAA三状态锁区分SMO和IDU–每个叶子上有一个SMO独占+IDU共享锁</li>
<li>FAA：Fetch and Add, return last value，CAS：Compare and Swap</li>
<li>锁值为0是S0，&gt;&#x3D;1是S1，&lt;-T是S2</li>
<li>SMO会将锁减去一个值X(X must &gt; T)，根据返回值确定目前是其他SMO（发现返回值为负的，rollback+X，不会改变S2状态）还是其他IDU（rollback+X，不会影响S1状态，重读直到返回值为0，即所有IDU在锁上加上的1都被还回去了）</li>
</ul>
</li>
<li>每次IDU都要多次RDMA<ul>
<li>压缩写操作的关键路径，读叶子的时候“投机地”用FAA上锁（猜对了少一个RTT，猜错了多一个RTT，由于概率原因还是有收益的）</li>
<li>由于投机了，所以可以batch发送</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>Fuzz</tag>
        <tag>LLM</tag>
        <tag>DM</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-9-28讨论班</title>
    <url>/Blog/2023/09/28/2023-9-28%E8%AE%A8%E8%AE%BA%E7%8F%AD/</url>
    <content><![CDATA[<h4 id="History-Driven-JVM-Fuzz-Driver"><a href="#History-Driven-JVM-Fuzz-Driver" class="headerlink" title="History-Driven JVM Fuzz Driver"></a>History-Driven JVM Fuzz Driver</h4><p>我们要测的是JVM，因此需要改变java byte code文件内容</p>
<p>已有的工作</p>
<p>Classming：基于Byte Code的mutation，例如在活动的数据流&#x2F;控制流跳转之类，缺点：覆盖率低&#x2F;执行掉率</p>
<p>History Driven：保留可能触发bug的代码片段</p>
<p>从history-bug中提取代码片段，插入到一段程序中</p>
<p>challenge：</p>
<ul>
<li>bug代码段的粒度，更多语义(粗)&#x2F;更多交互(细)</li>
<li>如何定位bug代码段<ul>
<li>特定的类型片段，Sequential&#x2F;If..else&#x2F;switch&#x2F;try-catch等</li>
<li>插入后如何修复代码？用已有的同类型可复用变量&#x2F;递归地new对象(因为可能要递归new出类属性)</li>
<li>基于CFG，考察关联的代码段</li>
</ul>
</li>
</ul>
<p>最后在OpenJ9上找了10个bug(可能在挑软柿子捏)</p>
<h4 id="WADIFF-A-Differential-Testing-Framework-for-WebAssembly-Runtimes-ASE’23"><a href="#WADIFF-A-Differential-Testing-Framework-for-WebAssembly-Runtimes-ASE’23" class="headerlink" title="WADIFF: A Differential Testing Framework for WebAssembly Runtimes (ASE’23)"></a>WADIFF: A Differential Testing Framework for WebAssembly Runtimes (ASE’23)</h4><p>差分测试wasm的runtime</p>
<p>wasm：</p>
<ul>
<li>stack based指令集，无寄存器指令</li>
<li>设计初衷是为了摆脱缓慢的js</li>
<li>执行流：先用high level语言(例如C++等)编写代码，然后编译为wasm字节码，最后放到runtime中执行。在runtime中要先过validator验证合法性</li>
</ul>
<p>wasm runtime bug：behavior和wasm描述的不一样</p>
<p>由于不知道理想情况是什么，所以也是用的差分测试。</p>
<p>首先用正则规则把wasm的语言转为formal的语言(看起来类似AST)，然后把所有的路径case生成代码段。</p>
<p>mutate：插入&#x2F;删除等一个byte的修改</p>
]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>Fuzz</tag>
        <tag>JVM</tag>
        <tag>ICSE</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-9-7讨论班</title>
    <url>/Blog/2023/09/07/2023-9-7%E8%AE%A8%E8%AE%BA%E7%8F%AD/</url>
    <content><![CDATA[<h3 id="Type-Batched-Program-Reduction"><a href="#Type-Batched-Program-Reduction" class="headerlink" title="Type Batched Program Reduction"></a>Type Batched Program Reduction</h3><p>Reducer：将程序变得更简洁，但保留感兴趣的点（例如编译错误，运行错误，特定输出等），不需要程序语义和原来保持一样</p>
<ul>
<li>针对特定的语言</li>
</ul>
<p>Reduction算法：</p>
<ul>
<li>transformation：程序化简的方法</li>
<li>search strategy：指导程序如何化简【一般是贪心】</li>
<li>Oracle：如何判断程序仍然具备想要的性质【一般是用户给的】</li>
</ul>
<p>举例：C-Reduce</p>
<ul>
<li>将特定字符串替换为”0”&#x2F;“1”</li>
<li>局部修改：修改三目运算&#x3D;&gt;例如只保留一个分支，reduce只需要让程序变简单</li>
<li>删除指定行数的代码</li>
<li>进行类编译器的修改：例如使用clang的前端</li>
</ul>
<p>举例：Perses</p>
<ul>
<li>在程序的解析树上从根节点开始遍历尝试删除节点</li>
<li>并不能考虑某个特定语言的特征</li>
</ul>
<p>本文工作</p>
<ul>
<li><p>Type Batched</p>
<ul>
<li><p>根据解析树的结点类型删除一个节点</p>
<blockquote>
<p>为什么要这样？因为删除某种类型的节点可能会导致出错概率提升从而拖慢效率</p>
</blockquote>
</li>
<li><p>type顺序的选择：计算跑oracle的期望(如果删掉能省更多的检查次数，那就先删这个)，概率则是先验给出来的</p>
</li>
</ul>
</li>
<li><p>Joint Batched</p>
<ul>
<li>由于同一类型的点可能相互有关系，因此这种策略会把某种节点全删，如果删完后oracle失败，则会更新概率，重新计算期望以重做joint（这里我感觉是重做type？因为更新了这种type的期望）</li>
</ul>
</li>
</ul>
<h3 id="JVM-testing"><a href="#JVM-testing" class="headerlink" title="JVM testing"></a>JVM testing</h3><p>Java Runtime Machine，执行java字节码，由于JVM的复杂性，因此对其做测试和保证其正确性时重要的</p>
<p>用fuzz的方式对其做测试</p>
<ul>
<li>生成不同的输入</li>
<li>差分测试，看在不同的JVM实现上结果有什么不一样</li>
</ul>
<p>JavaTailor</p>
<ul>
<li>Synthesis-based generation，随机将<strong>JVM bug case</strong>(过去的bug，现在可能已经被修复了)的代码剪切然后拼接，修复可能的语法错误（Synthesis），执行代码<ul>
<li>但是随机选取可能效率比较低，因为代码段的特征可能会相似，diversity不够好</li>
</ul>
</li>
</ul>
<p>Vectorizing Program Ingredients for Better JVM Testing（ISSTA’23）</p>
<ul>
<li>代码段语义层次聚类（hierarchy clustering）</li>
</ul>
<p>JITfuzz: Coverage-guided Fuzzing for JVM Just-in-Time Compilers </p>
<p>针对JVM的设计理念来做fuzz</p>
<p>JIT可以做一些优化，例如函数的内联优化，小代码的优化(e.g. x&#x2F;2 &#x3D;&gt; x&lt;&lt;1)，聚合类型的标量优化(例如把struct用可以开在栈上的int啥的代替)</p>
<ul>
<li><p>目前没什么针对JIT的测试，大多都是针对JVM的</p>
</li>
<li><p>做的方法和测试C compiler的差不多，mutation based fuzzing</p>
<blockquote>
<p>不是 mutation testing，那个是将错误代码插入到被测代码中，以验证当前测试用例是否可以发现注入的错误。</p>
</blockquote>
</li>
<li><p>六个mutator</p>
<ul>
<li>function inlining：将x op y这样的代码替换为调用小函数以触发JIT的inline检查</li>
<li>simplification：将代码弄复杂</li>
<li>……</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Testing</tag>
        <tag>ISSTA</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-1-11讨论班</title>
    <url>/Blog/2024/01/11/2024-1-11%E8%AE%A8%E8%AE%BA%E7%8F%AD/</url>
    <content><![CDATA[<h4 id="Contextual-Dispatch-for-Function-Specialization"><a href="#Contextual-Dispatch-for-Function-Specialization" class="headerlink" title="Contextual Dispatch for Function Specialization"></a>Contextual Dispatch for Function Specialization</h4><p>OOPSLA’20</p>
<p>JIT对函数的优化策略是根据上下文来决定的，以R为例</p>
<ul>
<li>需要在函数调用之前编译器插入类型检查代码</li>
<li>运行时如果发现参数类型变了就trigger recompiling</li>
<li>根据最近的调用删除一些参数的类型检查(如果用不到)以加速</li>
</ul>
<p>缺点：</p>
<ul>
<li>综合多次调用可能不是最优的优化</li>
<li>deoptimize&#x2F;recompile的过程比较花时间</li>
</ul>
<p>方法：</p>
<ul>
<li>空间换时间，记录context-&gt;code version表，call函数需要查表</li>
<li>Context记录什么信息……</li>
<li>对Context的可能值建立偏序(因为同一个context可能有多个次优化版本)关系，每次从表里找到&gt;&#x3D;当前ctx的最小的ctx’。若ctx’大于ctx，取ctx’的子节点，取其优化规则的并集重新编译然后插进来，若满了就随机逐出一个</li>
</ul>
<p>Comment：</p>
<ul>
<li>没说内存占用</li>
<li>我感觉这个工作有点捞</li>
</ul>
<h4 id="WaVe-a-verifiably-secure-WebAssembly-sandboxing-runtime"><a href="#WaVe-a-verifiably-secure-WebAssembly-sandboxing-runtime" class="headerlink" title="WaVe: a verifiably secure WebAssembly sandboxing runtime"></a>WaVe: a verifiably secure WebAssembly sandboxing runtime</h4><p>S&amp;P’23</p>
<p>主要讨论wasm的安全性</p>
<p>内存隔离：每个程序都有一块独立的区域</p>
<ul>
<li>总内存12G，规范要求从4G地址开始，总可用空间不超过4G，前后至少8G是guard page(可能motivated by±int32)</li>
</ul>
<p>WebAssembly System Interface(WASI)的挑战：</p>
<ul>
<li>缺乏完备的WASI规范</li>
<li>需要保证资源隔离<ul>
<li>内存隔离</li>
<li>文件系统隔离</li>
<li>网络隔离(说constraint更适合一定)</li>
</ul>
</li>
</ul>
<p>例如对于一个删除文件夹的API</p>
<ul>
<li>需要验证path字符串的地址是否在合法内存内</li>
<li>需要验证路径是否在根目录内</li>
<li>调用POSIX中的对应函数</li>
</ul>
<p>WaVe：一个可验证WASI安全的Wasm Runtime</p>
<p>静态扫描WASI(实验用的是他们自己实现的)函数中的Effect，包括</p>
<ul>
<li>内存操作&#x2F;文件操作&#x2F;网络操作(共7种)</li>
<li>对每种Effect有检验规则，静态检查</li>
</ul>
<p>Evaluation：</p>
<ul>
<li>通过Fuzz验证正确性<ul>
<li>AFL</li>
<li>通过QuickCheck验证pre-post-condition</li>
<li>随机生成syscall差分测试</li>
</ul>
</li>
<li>和wasmtime比较运行时性能【非静态检查的性能，没啥意义的测试】</li>
</ul>
<p>Contribution主要在于给出了一个WASI实现的标准&#x2F;流程，可以仿照他们的工作做个验证器，然后给定验证条件来实现需要的API</p>
]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>OOPSLA</tag>
        <tag>S&amp;P</tag>
        <tag>Wasm</tag>
      </tags>
  </entry>
  <entry>
    <title>An Empirical Study of Rust-for-Linux</title>
    <url>/Blog/2024/07/23/An-Empirical-Study-of-Rust-for-Linux/</url>
    <content><![CDATA[<p>本文主要对<a href="https://github.com/Rust-for-Linux">Rust-For-Linux</a>下的代码进行了实证研究，总结了使用Rust开发Linux内核的成果和不足，相关数据集开源在<a href="https://github.com/Richardhongyu/rfl_empirical_tools">Richardhongyu&#x2F;rfl_empirical_tools</a>.</p>
<p>3个RQ：</p>
<ul>
<li>RFL的现状是什么<ul>
<li>代码审查流程限制了其进一步的发展(driver、file system)</li>
<li>在内存安全上Rust并不是万能的</li>
</ul>
</li>
<li>RFL是否名副其实<ul>
<li>RFL的目标是更安全、 开销更小、更容易开发</li>
<li>实际上由于 unsafe的使用，只能做到more securable；一些情况下性能更低(icache miss)；引入了更多的新人加入内核开发</li>
</ul>
</li>
<li>从RFL中能学到什么</li>
</ul>
<h4 id="Preliminary"><a href="#Preliminary" class="headerlink" title="Preliminary"></a>Preliminary</h4><ul>
<li>FFI：Foreign Function Interface，用一种编程语言写的程序能调用另一种编程语言写的函数。RFL主要是使用Rust提供API给C Linux kernel调用</li>
<li><a href="https://github.com/rust-lang/rust-bindgen">rust-lang&#x2F;rust-bindgen</a>：自动将C头文件定义中的struct、函数声明转为Rust版本</li>
</ul>
<h4 id="RFL现状"><a href="#RFL现状" class="headerlink" title="RFL现状"></a>RFL现状</h4><p>6个insights：</p>
<ul>
<li><strong>drivers, netdev, and file systems</strong> are the long tail of RFL code.<ul>
<li>大多数都是内存管理，设备中断请求等</li>
</ul>
</li>
<li>RFL <strong>infrastructure</strong> has <strong>matured</strong>, with safe abstraction and drivers being the next focus.<ul>
<li>Kbuild在patch中占的比重降低，而safe abstraction的比重升高</li>
</ul>
</li>
<li>RFL is bottlenecked by <strong>code review</strong> but not by code development.<ul>
<li>原因：缺少高质量reviewer；RFL和Linux社区的合作模式不同(回复时间，审核周期等)；死锁：linux的人不喜欢审核没有实际driver的safe abstraction，而没有safe abstraction，RFL的人无法开发driver</li>
</ul>
</li>
<li>Kernel’s initiative to control memory in fine granularity <strong>conflicts</strong> Rust <strong>philosophy</strong>, which incurs overhead for RFL.<ul>
<li>Rust不支持C中的bitfield和union等数据结构，只能用一些低效的实现方式</li>
<li>Rust也不支持C中一些变量的attributes关键字</li>
</ul>
</li>
<li>RFL uses helper types to delegate management of kernel data to Rust while leaving the operation to kernel itself.<ul>
<li>Type和Deref来规范化类型和指针，从而避免C中void *之类的模糊</li>
<li>使用一些类型来帮助管控内核中一些结构体的行为(退出作用域自动释放内存、自动引用计数等)</li>
</ul>
</li>
<li>The major difficulty of writing safe drivers in Rust is to reconcile the inflexibility of Rust versus kernel programming conventions, which is often an oversight by RFL and the Linux community from what we observe.<ul>
<li>Rust中用于device probing的类型可能会很复杂</li>
<li>Rust中想要做到变长array比较麻烦，而C只需要一个指针和一个长度就可以了</li>
</ul>
</li>
</ul>
<h3 id="RFL是否名副其实"><a href="#RFL是否名副其实" class="headerlink" title="RFL是否名副其实"></a>RFL是否名副其实</h3><style>.qhqqucqltkvx{zoom:50%;}</style>

<ul>
<li>with RFL, Linux becomes more “securable” but still cannot be fully secure.<ul>
<li>Rust基本的内存安全控制</li>
<li>unsafe是无法移除的</li>
<li>Bug依旧可能由并发或者上下文语意语义产生</li>
</ul>
</li>
<li>There is no free lunch for performance –it is the programmer that counts!<ul>
<li>binary普遍增大</li>
<li>一些情况下会效率更高，另一些情况下则不然</li>
</ul>
</li>
<li>Rust的引入为内核开发带来了很多便利<ul>
<li>代码质量、可读性(doc注释)</li>
<li>新人加入(但暂时还不能承担核心任务)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
  </entry>
  <entry>
    <title>BF1的墓碑</title>
    <url>/Blog/2023/01/25/BF1%E7%9A%84%E5%A2%93%E7%A2%91/</url>
    <content><![CDATA[<p>事发当晚EA出面修复了漏洞，亚服起死回生，只能说是虚惊一场，不过这块墓碑还是保留着吧……</p>
<hr>

<p>战地1寿终正寝了，就在这里为这个游戏立个墓碑吧。</p>
<p>大概事件顺序：</p>
<ul>
<li>BF1开发商EA疏于对游戏环境的整治，导致玩家间形成外挂在官服捞薯，绿色玩家在私服玩的微妙平衡</li>
<li>反外挂组织BFEAC中成员<code>22</code>发现了EA漏洞，能够获取官服管理员权限，于2023年1月16日将EAC工具(可联ban外挂黑名单)挂载到BF1官服上，打破了平衡</li>
<li>外挂组织在2023年除夕前后进行DDOS攻击，使得大量私服服务器无限重开，难以进行游戏</li>
<li>DDOS攻击开销大，难以为继，2023年1月22日后攻击频率降低</li>
<li>俄罗斯人<code>shinku5_1</code>同样发现了该漏洞(一说拿到了更高的EA官方管理权限)，于2023年1月25日对官服和私服同时进行攻击，永久封禁正常玩家账号等</li>
<li>在双方“核弹互射”之后，游戏正式进入“核冬天”，亚服在线人数不足200人</li>
<li>玩家中出现一部分投降主义行为，可以合理推测<code>22</code>遭受一定程度的网暴</li>
<li>贴吧等平台出现大量反对外挂声援<code>22</code>的帖子，steam出现针对EA的大量差评</li>
</ul>
<p>一些图片留存：</p>
<div style="float:left;">
<style>.jfyckjgrseux{width: 65%; display:block; float:left;}</style><img src="/Blog/2023/01/25/BF1%E7%9A%84%E5%A2%93%E7%A2%91/d071b84241d4bfef295deeb62610bcf9391053774.jpg" class="jfyckjgrseux" alt="img">
<style>.kfymfsfmtcto{width: 35%; display:block; }</style><img src="/Blog/2023/01/25/BF1%E7%9A%84%E5%A2%93%E7%A2%91/5bafa40f4bfbfbed1383f5ba3df0f736aec31f19.jpg" class="kfymfsfmtcto" alt="img">
</div>


<p><strong>墓碑</strong></p>
<blockquote>
<p><a href="https://tieba.baidu.com/p/8232793039">战争结束了！你们都可以回家了！</a></p>
<p>战争结束了，英勇的战士们。在这场持久战中，你们奋力抵抗，永不妥协，不惧牺牲，无愧于勇士之名，钢铁之誉。然而，人事已尽，天命难违。你们每个人都已经尽到了自己应尽的责任，而现在，我们已经付出了太多的牺牲，太多的疲劳，我们已经无法再继续坚持战斗下去了。这不怪你们。放下枪去吧，去拥抱自己的亲人吧，去与朋友们到饭店小酌一杯吧，去在温暖阳光下呼吸新鲜的，不带战争阴霾空气吧。因为这些宝贵的事物，不就是我们拼死奋战所想守护的吗？现在，听好了，各位士兵们，最终的命令是：你们都可以回家了！<br>这场能完结所有战争的战争，终将分出胜负，枪炮都会腐蚀，绿草会再次生长，届时所有战争的痕迹将不复存在，这块土地会自己慢慢痊愈，像其他的伤痛一样，到时我们肯定已经入土长眠。<br>但是！<br>从帕斯尚尔的泥泞，<br>到武普库夫的冰雪，<br>由凡尔登的烈焰，<br>到苏瓦松的平原，<br>从西奈的沙漠，<br>到亚眠的废墟，<br>由圣康坦的战壕，<br>到阿尔登的雨林，<br>从黑戈兰湾的巨浪，<br>到法乌克斯的廊道，<br>从流血宴厅的城堡，<br>到格拉巴山的蓝天！<br>见证着我们的战斗，我们的牺牲，我们的守望！<br>士兵们，向你们自己敬礼！<br>我们麻木不仁，我们天真无邪。我们是可敬的英雄，也是十恶不赦的罪犯。我们注定成为传奇，也注定在历史中消逝。我们是天空的骑士、沙漠中的鬼魂、泥土中打滚的鼠辈。这些就是我们的故事！</p>
</blockquote>
<div style="float:left;">
<style>.kuskcbzmbteo{width:100%;}</style><img src="/Blog/2023/01/25/BF1%E7%9A%84%E5%A2%93%E7%A2%91/image-20230125164529658.jpg" class="kuskcbzmbteo" alt="image-20230125164529658">
<div style="float:left;">
<style>.jmwbslipdrpf{width:59%; display:block; float:left;}</style><img src="/Blog/2023/01/25/BF1%E7%9A%84%E5%A2%93%E7%A2%91/image-20230125164155185.jpg" class="jmwbslipdrpf" alt="image-20230125164155185">
<style>.mpylqiidnfxi{width:41%; display:block; float:left;}</style><img src="/Blog/2023/01/25/BF1%E7%9A%84%E5%A2%93%E7%A2%91/image-20230125164213462.jpg" class="mpylqiidnfxi" alt="image-20230125164213462">
</div>
</div>

<p>R.I.P.</p>
]]></content>
      <categories>
        <category>杂谈点滴</category>
      </categories>
  </entry>
  <entry>
    <title>Docker网络虚拟化</title>
    <url>/Blog/2023/01/07/Docker%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96/</url>
    <content><![CDATA[<h3 id="Docker网络虚拟化"><a href="#Docker网络虚拟化" class="headerlink" title="Docker网络虚拟化"></a>Docker网络虚拟化</h3><p>参考资料：</p>
<ul>
<li><a href="https://www.dasblinkenlichten.com/an-introduction-to-network-namespaces/">An introduction to network namespaces</a></li>
<li><a href="https://blog.csdn.net/Kangyucheng/article/details/88051969">五分钟理解VRF</a></li>
<li>Cloud Native Data Center Networking, Chapter 7: Container Networking</li>
</ul>
<h4 id="VRF-Virtual-Route-Forwarding"><a href="#VRF-Virtual-Route-Forwarding" class="headerlink" title="VRF(Virtual Route Forwarding)"></a>VRF(Virtual Route Forwarding)</h4><p>在一个路由器中构建多份虚拟的路由表，从而实现路由&#x2F;转发虚拟化。</p>
<p>所谓的虚拟路由表，可以理解为将一组接口-&gt;接口的转发策略打包到一起，当请求到来时，自然可以通过映射找到要去的接口。</p>
<p>这样做可以实现目的地相同但下一条不同的两个转发策略同时存在于一个路由器中。</p>
<style>.qyeqfdeueixe{zoom: 67%;}</style><img src="/Blog/2023/01/07/Docker%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96/image_thumb3.png" class="qyeqfdeueixe" alt="image">

<p>例如该图中192.168.1.1和192.168.1.1同属于192.168.1.0&#x2F;24，此时路由器处理来自两个不同接口的请求时(分别路由到数据接口和管理接口)，如果没有VRF，回去的包必定走同一个接口，会造成<strong>不对称路由问题</strong>(来去的链路不一样)。使用VRF后，可以让来自下方云接口的请求去下方云，来自右边云接口的请求回右边云。</p>
<p>一个具体的路由表例子：</p>
<style>.ijaeqqthylmj{zoom: 67%;}</style><img src="/Blog/2023/01/07/Docker%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96/20190301111226761.gif" class="ijaeqqthylmj" alt="img">

<p>同时，为了一定程度上实现资源共享，VRF之间实现部分“互通”也是有必要的，即设立一个转发路径让数据包被转发至另一个VRF所辖的接口，这被称为<strong>route leaking</strong></p>
<h4 id="Linux-Network-Namespace"><a href="#Linux-Network-Namespace" class="headerlink" title="Linux Network Namespace"></a>Linux Network Namespace</h4><blockquote>
<p>Network namespace允许你在Linux中创建相互隔离的网络视图，每个网络名字空间都有自己独立的网络配置，包括：网络设备、路由表、IPTables规则，路由表、网络协议栈等。新建的网络名字空间与主机默认网络名字空间之间是隔离的。我们平时默认操作的是主机的默认网络名字空间。</p>
</blockquote>
<p>VRF常见的部署场景是为两个接口(<strong>数据接口</strong>和<strong>管理接口</strong>)分别配置一套路由表。因此对于一台服务器来说，也可以通过namespace来做到与VRF相同的事情：只需要将不同的接口【网卡】添加到不同的namespace下就可以了。由此，来自相同ip段的请求发送到不同的接口上就可以用不同的链路响应，而不是用非对称的方式(用唯一接口对应一个ip段)解决。</p>
<p>另外，对于VRF语境下”route leaking”的需要，Linux提供了<code>veth</code>这样一种虚拟设备来连通不同的namespace。<code>veth</code>在构建时可以理解为一个类似Linux管道的设备，在一个接口处写，另一个接口就能读出相应的数据，格式一般为<code>a@b</code>，因此可以从本namespace中把数据递到其他namespace中。</p>
<h4 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h4><p>veth可以解决让两个namespace通信的问题，而bridge则可以让多个namespace之间进行通信。例如构建n个veth，然后将n个出发接口加入对应namespace，将n个目的接口都加入bridge。那么就实现了多个namespace的互通。</p>
<h4 id="Single-host下Docker的Linux实践"><a href="#Single-host下Docker的Linux实践" class="headerlink" title="Single-host下Docker的Linux实践"></a>Single-host下Docker的Linux实践</h4><p>Docker容器使用了LinuxNetwork Namepsace，并在宿主机上创建了docker0的bridge。在未指定网络配置时，通过docker run启动的容器都会有一个veth连到docker0。因此默认情况下，各个容器是互通的。</p>
<blockquote>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-idt</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>busybox busybox <span class="token comment">#后台启动一个busybox的容器</span>
nsenter <span class="token parameter variable">-t</span> <span class="token variable"><span class="token variable">`</span><span class="token function">docker</span> inspect <span class="token parameter variable">--format</span> <span class="token string">'&#123;&#123;.State.Pid&#125;&#125;'</span> busybox<span class="token variable">`</span></span> <span class="token parameter variable">-n</span> <span class="token function">ip</span> <span class="token parameter variable">-d</span> <span class="token function">link</span> show <span class="token comment">#进入该容器namespace并查看链路层相关接口</span></code></pre>

<img src="/Blog/2023/01/07/Docker%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96/image-20230107171508344.jpg" class="" title="image-20230107171508344">

<p>可以看到此时容器中除了有loopback接口之外，还有一个ifindex(interface index)为13的<code>veth</code>设备接口，该设备从eth0指向if14。这里eth0是namespace中为了虚拟化而起的别名。</p>
<p>回到主namespace，执行<code>ip -d link show</code></p>
<img src="/Blog/2023/01/07/Docker%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96/image-20230107172025305.jpg" class="" title="image-20230107172025305">

<p>可以看到主namespace下if14正是一条前往if13的veth，并且该接口正属于docker0的bridge。</p>
</blockquote>
<p>Docker会将默认的子网172.17.0.0&#x2F;16应用于docker0，同时对于新产生的容器，在为容器分配该子网下的ip的同时，也为容器加上去docker0的路由。</p>
<blockquote>
<p>进入容器后查看ip和路由</p>
<style>.pnyxmrrummee{zoom:50%;}</style><img src="/Blog/2023/01/07/Docker%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96/image-20230107175917501.jpg" class="pnyxmrrummee" alt="image-20230107175917501">
</blockquote>
<p>docker0则使用NAT代理所有的内部请求至Docker拥有的与宿主机处于同一网段的single-host的ip，从而实现内外部的通信。</p>
<p>上述是在single-host上docker使用bridge的一种实现，multihost场景下，有更多的插件可以供选择。对于k8s来说，其网络配置力求做到没有NAT参与，即容器IP在内外看来都是一致的，这部分在本文中不再深入讨论。</p>
]]></content>
      <categories>
        <category>技术视野</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>Container</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo GitHub Action CI配置(解决文章修改时间问题)</title>
    <url>/Blog/2022/10/14/Hexo-GitHub-Action-CI%E9%85%8D%E7%BD%AE(%E8%A7%A3%E5%86%B3%E6%96%87%E7%AB%A0%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98)/</url>
    <content><![CDATA[<p>因为本人懒得每次push完代码再手敲一次部署命令，所以想利用Github Action来实现每次push后自动部署到网页。中文互联网上搜索到的解决方案较老，花了几天时间踩了很多坑之后我这里也是成功配置完毕，因此在这里写篇博客记录一下。</p>
<p>以下是相关版本号</p>
<ul>
<li>hexo：v6.3.0</li>
<li>next：v7.8.0</li>
<li>node：v16</li>
</ul>
<h3 id="手动部署"><a href="#手动部署" class="headerlink" title="手动部署"></a>手动部署</h3><ul>
<li><p>安装必要插件</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git</code></pre>
</li>
<li><p>hexo配置文件</p>
  <pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>
  <span class="token key atrule">type</span><span class="token punctuation">:</span> git
  <span class="token key atrule">repo</span><span class="token punctuation">:</span> <span class="token comment"># ssh地址</span>
  <span class="token key atrule">branch</span><span class="token punctuation">:</span> <span class="token comment"># 配置过Github Page的分支，配置过程请自行查阅</span></code></pre>
</li>
<li><p>命令行部署</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">hexo d</code></pre></li>
</ul>
<h3 id="CI自动部署"><a href="#CI自动部署" class="headerlink" title="CI自动部署"></a>CI自动部署</h3><ul>
<li><p>请参考<a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/">利用 Github Actions 自动部署 Hexo 博客</a>进行Github的配置以及workflow yaml文件的初步配置，我使用的Hexo+Next版本无需使用主题仓库，因此对应部分我删除了。</p>
</li>
<li><p>在yaml中添加&#x2F;修改两个step</p>
<ul>
<li><p>checkout是将文件放入当前工作区，默认情况下对git文件做<strong>浅拷贝</strong>(shadow copy)，这里为了保留git log中的时间信息，采用<strong>深拷贝</strong>(deep copy)</p>
<p><strong>目前网上资料很少有这一步，但是这一步很关键</strong></p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Checkout
  <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/checkout@v2
  <span class="token key atrule">with</span><span class="token punctuation">:</span>
    <span class="token key atrule">fetch-depth</span><span class="token punctuation">:</span> <span class="token string">'0'</span></code></pre>
</li>
<li><p>第一条指令是取消git对中文文件的转义，否则linux会将<code>\xxx</code>解读为<code>xxx</code>找不到对应中文文件</p>
<p>第二条指令从git log中读取文件修改记录，并将sources中文件的修改时间用<code>touch -d</code>进行修复</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Restore file modification time
  <span class="token key atrule">run</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">
    git config --global core.quotepath false
    git ls-files --directory source | while read path; do touch -d "$(git log -1 --format='@%ct' $path)" "$path"; done</span></code></pre></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>技术视野</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github Action</tag>
      </tags>
  </entry>
  <entry>
    <title>From Luna to Solar</title>
    <url>/Blog/2022/10/24/From-Luna-to-Solar/</url>
    <content><![CDATA[<h3 id="From-Luna-to-Solar-The-Evolutions-of-the-Compute-to-Storage-Networks-in-Alibaba-Cloud"><a href="#From-Luna-to-Solar-The-Evolutions-of-the-Compute-to-Storage-Networks-in-Alibaba-Cloud" class="headerlink" title="From Luna to Solar: The Evolutions of the Compute-to-Storage Networks in Alibaba Cloud"></a>From Luna to Solar: The Evolutions of the Compute-to-Storage Networks in Alibaba Cloud</h3><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>弹性存储系统(EBS, Elastic Block Storage)要求高可用高速度，并且不同的而硬件配置也使得传统网络协议无法很好地适配。</p>
<p>LUNA：取代内核TCP栈以协调HDD(硬盘)和SSD(固态硬盘)的速度。在计算和存储集群之间的网络使用<strong>用户空间的TCP</strong>而不是硬件来提高scalability和interoperability。最终发现在性能上有很好的提高。</p>
<p>SOLAR：在LUNA的经验上，使用<strong>UDP协议栈</strong>实现网络化存储，同时辅之以<strong>硬件加速</strong>和<strong>快速错误恢复</strong>。由于网络协议倾向于提供统一的处理方式，而存储硬件的分层结构又带来末端的复杂性，因此SOLAR的主要创新点就在于<strong>打破了网络和存储层的边界，将网络包和存储块糅合在一起</strong>。</p>
<ul>
<li>EBS的数据路径被完全转移到网络部分，独立硬件可以处理而无需牵扯CPU和内存</li>
<li>数据块并不需要网络数据报那样要求到达顺序，因此无需维护接受缓冲等</li>
<li>轻量级错误检测</li>
<li>多路错误恢复(并没有建立TCP那样的端到端连接，错误恢复不影响scalability)</li>
</ul>
<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><style>.buxmojulhhms{zoom:50%;}</style><img src="/Blog/2022/10/24/From-Luna-to-Solar/006g42Mjly1h7gai54rtwj30x10q2qgt.jpg" class="buxmojulhhms" alt="image.png">

<p>传统EBS网络构造如上图所示，存储服务器和计算服务器的区分使得总体性能高于全部使用通用服务器，另外存储服务器本身也能够被精细化设计从而保证数据安全和效率。本文主要关注Frontend Network(串联同一地区各个集群的前端网络)【Backend Network通常是PoD(point of deliverly)的结构】</p>
<p>Storage Agent(SA)主要维护两个表单：</p>
<ul>
<li>Segment Table：虚拟磁盘到物理磁盘数据段的映射</li>
<li>QoS(quality of service) Table：维护各个虚拟磁盘服务等级和当前使用情况(带宽，IOPS每秒读写次数等)</li>
</ul>
<style>.ocrxkdmxqhpv{zoom: 67%;}</style><img src="/Blog/2022/10/24/From-Luna-to-Solar/006g42Mjly1h7gbqldq72j30ym0l7ngu.jpg" class="ocrxkdmxqhpv" alt="image.png">

<blockquote>
<p>为什么中间要加一个Block&#x2F;Chunk Server而不是用一些协议进行RDMA(Remote Direct Memory Access)？</p>
<ul>
<li>直接操作磁盘带来的LSM-Tree上的合并等操作与计算专用服务器CPU性能不匹配</li>
<li>多个VM操作多个VD带来的一致性问题</li>
<li>灵活性、粒度……</li>
</ul>
</blockquote>
<style>.tdteefqsywcl{zoom:50%;}</style><img src="/Blog/2022/10/24/From-Luna-to-Solar/006g42Mjly1h7hec5ne76j30sc0j311t.jpg" class="tdteefqsywcl" alt="image.png">

<p>图中是I&#x2F;O延迟的对比图，可以看到，在使用SSD时，Kernel TCP造成的延迟逐渐成为性能瓶颈(原来用的HDD可能速度更慢)，FN&#x2F;BN&#x2F;SA都需要去匹配SSD的高速。</p>
<blockquote>
<p>这里写速度比读速度快很多的原因是SSD有write cache</p>
</blockquote>
<h3 id="LUNA"><a href="#LUNA" class="headerlink" title="LUNA"></a>LUNA</h3><p>FN往往连接成百上千的计算节点，同时各个节点的设计往往不太一样，因此对scalability和interoperability有较高的要求。而对BN来说，小集群内硬件的配置大多相同，同时为了控制宕机的影响范围，集群内连接数也不会太多。</p>
<p>2019年开始LUNA被部署到几乎所有阿里云平台</p>
<style>.hjxgynvstobl{zoom: 67%;}</style><img src="/Blog/2022/10/24/From-Luna-to-Solar/006g42Mjly1h7hk4ofb4qj30o90eoq8u.jpg" class="hjxgynvstobl" alt="image.png">

<p>LUNA的亮点：</p>
<blockquote>
<p><a href="https://www.usenix.org/system/files/conference/nsdi14/nsdi14-paper-jeong.pdf">NSDI’14 mTCP: a Highly Scalable User-level TCP Stack for Multicore Systems</a>，提供Run-to-Complete实现网络传输的零拷贝</p>
<style>.fofcvlheipor{zoom: 80%;}</style><img src="/Blog/2022/10/24/From-Luna-to-Solar/v2-1fd0111829fd904e04ddbf06b121d7b6_1440w.webp" class="fofcvlheipor">

<style>.hpjmlnsyrdnn{zoom:80%;}</style><img src="/Blog/2022/10/24/From-Luna-to-Solar/v2-2bc95f9f013e34e0c02c80832a006a72_1440w.webp" class="hpjmlnsyrdnn">

<ul>
<li>读取NIC(网络接口控制器)的数据包由事件驱动而不是轮询，批处理读取</li>
<li>TCP放到用户态，减少系统调用</li>
<li>应用线程和mTCP线程共享buffer【是否是RTC……】</li>
</ul>
</blockquote>
<p>架构类似mTCP，有如下两个拓展</p>
<ul>
<li>通过回收和缓存共享来实现SA到RPC的零拷贝</li>
<li>lock-free和sharing nothing的线程部署理念，CPU核之间不存在共享和锁，提高并行度</li>
</ul>
<p>使用LUNA以后：</p>
<ul>
<li>SA逐渐转变成性能瓶颈</li>
<li>随着网络带宽的进一步提高，将网络栈交由硬件处理变得更加必要</li>
<li>错误恢复的时间(通常几秒到几分钟)让人难以接受</li>
</ul>
<h3 id="SOLAR"><a href="#SOLAR" class="headerlink" title="SOLAR"></a>SOLAR</h3><p>bare-metal：将整机提供给客户(可以自行建立多个虚拟机)，而非将虚拟机提供给客户</p>
<p>bare-metal cloud：将云基础设施移交到硬件</p>
<style>.pqrgjlttqxfk{zoom:67%;}</style><img src="/Blog/2022/10/24/From-Luna-to-Solar/006g42Mjgy1h7k3cdgmowj30yq0ed7cf.jpg" class="pqrgjlttqxfk" alt="image.png">

<p>可以看到，DPU(Data Processing Unit)提供CPU(6核以限制能耗)、内存、虚拟化、可编程部件(FPGA&#x2F;ASIC)以及通过PCIe(外围组件互连快件)进行直接内存访问</p>
<img src="/Blog/2022/10/24/From-Luna-to-Solar/006g42Mjgy1h7k3mzdf9ij310p08qgsj.jpg" class="" title="image.png">

<p>LUNA的网络栈和SA都在CPU里，CPU的开销很大。即便使用RDMA将数据访问offload到硬件，SA依然占用了CPU。另外，LUNA还需要经过两次PCIe接口，因此也会被PCIe拖慢一部分性能</p>
<p>SOLAR的设计理念</p>
<ul>
<li>通过将网络栈和SAoffload到硬件上，减少CPU开销，避免PCIe</li>
<li>能够检测和通过动态更换路径避免网络不可用</li>
</ul>
<p>one-block-one-packet</p>
<ul>
<li>更小的buffer【不用考虑失序到达了】</li>
<li>CPU和内存使用大大降低</li>
<li>更少的状态</li>
<li>很容易实现</li>
</ul>
<style>.bzpkjfyshwpg{zoom:67%;}</style><img src="/Blog/2022/10/24/From-Luna-to-Solar/006g42Mjgy1h7k60hjlgkj30qo0o6k4f.jpg" class="bzpkjfyshwpg" alt="image.png">

<ul>
<li>写操作过程：QoS获取服务信息，Block获取物理地址，CPU轮询以发起RPC请求，将UDP、RPC报文头生成好。同时与数据合并发出网络包。【CPU在生成RPC头的同时也准备好拥塞反馈的环境等】</li>
<li>读操作过程：与写操作不一样的地方在于，RPC读请求由cpu发出，同时维护一个接受表，等待FGPA处理之后的响应。<ul>
<li>CRC的聚合和检测由cpu完成，(FPGA的比特翻转问题难以保证正确性，因此只为每个小段进行CRC计算)。利用了CRC32的递归特性CRC(A^B)&#x3D;CRC(A)^CRC(B)。</li>
</ul>
</li>
</ul>
<p>SOLAR的经验</p>
<ul>
<li>从PCIe3.0到PCIE4.0花了十年，但是网络速度却从10Gbps涨到了100Gbps，因此在未来跳过PCIe仍将是重要的</li>
<li>将巨型帧的大小从8k降到4k以缓解拥塞，以及使用per-packet ACK来进行拥塞控制</li>
<li>将弹性存储系统整合进DPU对于边缘网络等有bare-metal cloud的情况依然能起到一定作用</li>
</ul>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>SIGCOMM</tag>
      </tags>
  </entry>
  <entry>
    <title>Haskell开发环境配置</title>
    <url>/Blog/2023/10/11/Haskell%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>操作系统：Win11</p>
<p>参考资料：</p>
<ul>
<li><a href="https://blog.csdn.net/SevenBerry/article/details/126467318">windows配置Haskell+VSCode开发环境（2022.8）_ghcup 镜像_SevenBerry的博客-CSDN博客</a></li>
<li><a href="https://mirrors.ustc.edu.cn/help/ghcup.html">GHCup 源使用帮助 — USTC Mirror Help 文档</a></li>
</ul>
<p>我们使用GHCup这样一个工具来帮助我们安装Haskell工具链，由于默认下载源在境外网站，因此国内用户需要使用镜像站来加快下载的速度。</p>
<p>首先在Windows powershell终端中执行</p>
<pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token variable">$env</span>:BOOTSTRAP_HASKELL_YAML = <span class="token string">'https://mirrors.ustc.edu.cn/ghcup/ghcup-metadata/ghcup-0.0.7.yaml'</span>
<span class="token function">Set-ExecutionPolicy</span> Bypass <span class="token operator">-</span>Scope <span class="token keyword">Process</span> <span class="token operator">-</span>Force<span class="token punctuation">;</span><span class="token namespace">[System.Net.ServicePointManager]</span>::SecurityProtocol = <span class="token namespace">[System.Net.ServicePointManager]</span>::SecurityProtocol <span class="token operator">-bor</span> 3072<span class="token punctuation">;</span><span class="token function">Invoke-Command</span> <span class="token operator">-</span>ScriptBlock <span class="token punctuation">(</span><span class="token namespace">[ScriptBlock]</span>::Create<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">Invoke-WebRequest</span> https:<span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>ustc<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>cn/ghcup/sh/bootstrap-haskell<span class="token punctuation">.</span>ps1 <span class="token operator">-</span>UseBasicParsing<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span>ArgumentList <span class="token boolean">$true</span></code></pre>

<p>输入希望安装的目录并回车，全部选择默认配置。</p>
<p>由于Windows缺少编译工具等，GHCup会先下载msys2这样一个工具包。该工具包同样默认从境外源下载，因此可以使用VPN等工具加速下载，例如<strong>在Clash中</strong>打开一个ps终端执行上述命令。</p>
<p>msys2下载完之后按Ctrl+C终止命令，此时关闭代理，重新打开ps窗口执行上述命令。GHCup会自动下载cabal等工具，当<strong>cabal安装完</strong>后，终端会卡在<code>Downloading the latest package list from hackage.haskell.org</code>这一行，再次终止命令。</p>
<p>在Haskell安装目录下的cabal文件夹内找到<code>config</code>文件，将其中</p>
<pre class="language-none"><code class="language-none">repository hackage.haskell.org
  url: http:&#x2F;&#x2F;hackage.haskell.org&#x2F;
  -- secure: True
  -- root-keys:
  -- keys-threshold: 3</code></pre>

<p>替换为科大源</p>
<pre class="language-none"><code class="language-none">repository mirrors.ustc.edu.cn
  url: https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;hackage&#x2F;
  secure: True</code></pre>

<p>然后执行</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">cabal update</code></pre>

<p>可以看到终端显示<code>Downloading the latest package list from mirrors.ustc.edu.cn</code>，等待其将package list下载完。</p>
<p>使用cabal安装<code>HLS</code>，构建出的可执行文件应该在<code>cabal/bin</code>下</p>
<pre class="language-none"><code class="language-none">cabal install haskell-language-server</code></pre>

<p>安装完成后，在VSCode中安装<code>Haskell</code>插件。为Haskell插件添加HLS的配置项即可。</p>
<style>.qidxwdngursg{}</style><img src="/Blog/2023/10/11/Haskell%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E9%85%8D%E7%BD%AE1.png" class="qidxwdngursg">

<style>.bywhusrqrfhg{}</style><img src="/Blog/2023/10/11/Haskell%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E9%85%8D%E7%BD%AE2.png" class="bywhusrqrfhg">



<p>另：此方法安装的cabal可能版本较老，install新版本依赖时可能在build环境出错，可以使用ghcup install cabal ${version}指定安装新版本cabal，并依旧使用上述方法替换cabal的config。</p>
]]></content>
      <categories>
        <category>技术视野</category>
      </categories>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux权限系统</title>
    <url>/Blog/2022/11/24/Linux%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="用户和组管理"><a href="#用户和组管理" class="headerlink" title="用户和组管理"></a>用户和组管理</h3><p>Linux用户分为以下三类</p>
<ul>
<li>超级用户【root】</li>
<li>系统用户【内建用户，不能用来登录，方便系统进程控制资源】</li>
<li>普通用户</li>
</ul>
<p>Linux用户组分为以下三类</p>
<ul>
<li>私有组【建立新帐户时与账户名同名的组】</li>
<li>标准组【组中可以容纳多个用户】</li>
<li>系统组【由Linux系统建立】</li>
</ul>
<pre class="mermaid">graph LR
用户和组管理 --> 用户配置文件
用户和组管理 --> 用户组配置文件
用户配置文件 --> 用户帐号文件 --> /etc/passwd
用户配置文件 --> 用户影子文件 --> /etc/shadow
用户组配置文件 --> 用户组帐号文件 --> /etc/group
用户组配置文件 --> 用户组影子文件 --> /etc/gshadow</pre>



<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># /etc/passwd</span>
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
<span class="token comment"># ...</span>
calvin:x:1000:1001::/home/calvin:/bin/sh</code></pre>

<p>用户名 : 密码(x表示存放在shadow) : <strong>uid</strong> : <strong>gid</strong> : 注释 : 主目录(有权限的目录) : 登陆后使用的默认shell</p>
<p>真正起到<strong>区分用户</strong>作用的是<strong>uid</strong>，0为root管理员，1~999为系统账号，1000~60000为一般账号</p>
<p><code>/etc/shadow</code>中则记录了加密过后的密码和一些诸如修改时间，有效期等配置信息</p>
<h3 id="文件权限控制"><a href="#文件权限控制" class="headerlink" title="文件权限控制"></a>文件权限控制</h3><p>使用<code>ls -h xxx</code>可以查看文件信息</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># ls -l db.json</span>
<span class="token parameter variable">-rwxrwxrwx</span> <span class="token number">1</span> root root <span class="token number">292602</span> Nov <span class="token number">24</span> <span class="token number">13</span>:39 db.json</code></pre>

<p>这里第一段是权限信息。</p>
<p>第一个字符代表文件类型</p>
<ul>
<li>- 代表普通文件</li>
<li>d 代表目录文件</li>
<li>s 代表套接字文件</li>
<li>p 代表管道文件</li>
<li>c 代表字符文件</li>
<li>b 代表块文件</li>
<li>l 代表链接文件</li>
</ul>
<p>后面每三个字符为一组，分别代表owner&#x2F;group&#x2F;others的权限</p>
<ul>
<li><p>r 读</p>
</li>
<li><p>w 写</p>
</li>
<li><p>x 对文件执行&#x2F;对目录搜索</p>
</li>
<li><p>s setuid或setguid【只在owner和group项可设置】</p>
<blockquote>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># ls -l /bin/passwd</span>
-rwsr-xr-x <span class="token number">1</span> root root <span class="token number">68208</span> Jul <span class="token number">15</span>  <span class="token number">2021</span> /bin/passwd</code></pre>
</blockquote>
</li>
<li><p>t 对目录文件设置后，只有目录内文件的所有者才能更改文件【只在others项可设置】</p>
</li>
</ul>
<p>可以使用<code>chmod</code>进行权限更改，例如777就对应rwxrwxrwx，而755则对应rwxr-xr-x。如果要设定owner的s位需要在前面加上4，group的s位加2，others的t位加1。例如1755对应rwxrwxrwt</p>
<h3 id="进程权限控制"><a href="#进程权限控制" class="headerlink" title="进程权限控制"></a>进程权限控制</h3><ul>
<li>euid：effective uid</li>
<li>ruid：real uid【真实的uid】</li>
<li>ssuid：saved set uid【拷贝自euid，便于控制子进程等uid】</li>
</ul>
<p>set uid实际设置的就是euid，类似的，也能设置gid。</p>
<p>我们可以看一下完整的执行passwd的过程</p>
<ul>
<li><code>fork</code>出一个子进程，此时uid和gid都是real的</li>
<li>passwd对于others允许执行，因此进程可以调用<code>exec</code>执行passwd文件</li>
<li>passwd有s权限位，此时进程euid被设为root的uid，即0</li>
<li>进程可以修改shadow文件</li>
</ul>
<h3 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h3><ul>
<li><a href="https://www.lxlinux.net/2315.html">Linux权限原理详解</a></li>
<li><a href="https://blog.csdn.net/hutongkoudemihu/article/details/125462312">Linux——&#x2F;etc&#x2F;passwd文件（管理用户和组）</a></li>
</ul>
]]></content>
      <categories>
        <category>技术视野</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/Blog/2022/10/10/hello-world/</url>
    <content><![CDATA[<p>花了一晚上的时间，终于搭建好hexo环境啦！以后应该会在这里分享一些技术相关的文字，或者个人生活的小感悟~</p>
<p>总之按照惯例道一声Hello World！</p>
]]></content>
      <categories>
        <category>杂谈点滴</category>
      </categories>
  </entry>
  <entry>
    <title>k8s集群部署</title>
    <url>/Blog/2022/12/08/k8s%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>使用工具：<a href="https://github.com/easzlab/kubeasz">kubeasz</a></p>
<h3 id="安装须知"><a href="#安装须知" class="headerlink" title="安装须知"></a>安装须知</h3><p>本文中所有命令<strong>均需在root账户下执行</strong>，使用root登录机器或使用<code>su</code>命令切换到root用户均可，但<strong>不可使用sudo代替</strong>。</p>
<h3 id="单节点集群部署"><a href="#单节点集群部署" class="headerlink" title="单节点集群部署"></a>单节点集群部署</h3><p>参考：<a href="https://github.com/easzlab/kubeasz/blob/master/docs/setup/quickStart.md">快速指南</a></p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">release</span><span class="token operator">=</span><span class="token number">3.3</span>.1
<span class="token function">wget</span> https://github.com/easzlab/kubeasz/releases/download/<span class="token variable">$&#123;release&#125;</span>/ezdown
<span class="token function">chmod</span> +x ./ezdown

./ezdown <span class="token parameter variable">-D</span> <span class="token comment">#下载镜像等文件</span>
./ezdown <span class="token parameter variable">-S</span> <span class="token comment">#容器化运行kubeasz</span>

<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> kubeasz ezctl start-aio <span class="token comment">#使用默认配置安装aio集群</span></code></pre>

<pre class="language-bash" data-language="bash"><code class="language-bash">kubectl get svc <span class="token parameter variable">-A</span> <span class="token comment">#查看所有服务，如果出现kubectl: command not found的报错可以重新登录或执行source ~/.bashrc使环境变量生效</span></code></pre>

<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#删除集群</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> kubeasz ezctl destroy default</code></pre>

<p>注意：</p>
<ul>
<li>单节点的集群在虚拟机挂起或关机重启时进程会挂掉，导致无法再控制kubectl等，可以重新安装aio集群，并按照报错提示删除原来的文件</li>
</ul>
<h3 id="多节点集群部署"><a href="#多节点集群部署" class="headerlink" title="多节点集群部署"></a>多节点集群部署</h3><p>参考：<a href="https://zhuanlan.zhihu.com/p/562533111">一键安装Kubernetes？使用kubeasz带你10分钟装好一个k8s集群，不受国内网络环境影响</a></p>
<p>在<strong>每台机器上</strong>进行如下操作配置ssh免密登录，安装kubeasz</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span>  ~/.ssh <span class="token comment">#如果没有该文件夹，可以ssh自己一下</span>
ssh-keygen <span class="token parameter variable">-t</span> rsa
ssh-copy-id <span class="token variable">$&#123;ip1&#125;</span> <span class="token comment">#这里的ip是你希望免密登录的机器ip，根据提示输入目标机器的密码</span>
ssh-copy-id <span class="token variable">$&#123;ip2&#125;</span>
<span class="token punctuation">..</span>. <span class="token comment">#请将包括自己在内的所有机器的ip都执行一遍</span>

<span class="token builtin class-name">export</span> <span class="token assign-left variable">release</span><span class="token operator">=</span><span class="token number">3.3</span>.1
<span class="token function">wget</span> https://github.com/easzlab/kubeasz/releases/download/<span class="token variable">$&#123;release&#125;</span>/ezdown
<span class="token function">chmod</span> +x ./ezdown

./ezdown <span class="token parameter variable">-D</span> <span class="token comment">#下载镜像等文件</span>
./ezdown <span class="token parameter variable">-S</span> <span class="token comment">#容器化运行kubeasz</span></code></pre>

<p>在某台机器上执行</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> kubeasz ezctl new k8s-01 <span class="token comment">#创建新集群k8s-01</span>
<span class="token function">vi</span> /etc/kubeasz/clusters/k8s-01/hosts <span class="token comment">#修改配置文件的如下几项：</span>
<span class="token comment">#[etcd]为数据库要放在哪些机器上</span>
<span class="token comment">#[kube_master]为master节点</span>
<span class="token comment">#[kube_node]为work节点</span>
<span class="token comment">#CLUSTER_NETWORK可以选用结构简单的flannel</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> kubeasz ezctl setup k8s-01 all <span class="token comment">#一键安装</span></code></pre>

<p>安装完成后，运行<code>source ~/.bashrc</code>或断开ssh重连使环境变量生效</p>
<p>同样使用<code>docker exec -it kubeasz ezctl destroy k8s-01</code><strong>删除集群</strong></p>
<h3 id="查看dashboard"><a href="#查看dashboard" class="headerlink" title="查看dashboard"></a>查看dashboard</h3><p>打印服务信息，根据port拿到端口：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">kubectl get svc <span class="token parameter variable">-A</span> <span class="token operator">|</span> <span class="token function">grep</span> kubernetes-dashboard
<span class="token comment"># port 443:30255/TCP</span></code></pre>

<p>打印token等信息：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">kubectl describe <span class="token parameter variable">-n</span> kube-system secrets admin-user</code></pre>

<p>访问https:&#x2F;&#x2F;${NodeIP}:${NodePort}【Chrome可能会禁止访问，可以使用其他浏览器】，输入对应token即可</p>
<img src="/Blog/2022/12/08/k8s%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/image-20221209132816190.png" class="" title="image-20221209132816190">

<img src="/Blog/2022/12/08/k8s%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/image-20221209132929364.png" class="" title="image-20221209132929364">



]]></content>
      <categories>
        <category>技术视野</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Kubeasz</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_easygraph文档</title>
    <url>/Blog/2022/10/23/cpp-easygraph%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>cpp_easygraph主要由C++编写，利用<a href="https://github.com/pybind/pybind11">pybind11</a>框架实现用C++代码到python的桥接。在cpp_easygraph提供的类和方法中，暴露出的接口与python库源码的接口相同(即函数名、参数、效果等)。EasyGraph通过引入cpp_easygraph中的类和方法，将C++实现的内容嵌入到原先的代码中，从而实现类和高性能计算方法的扩展。</p>
<h3 id="为何使用Pybind11？"><a href="#为何使用Pybind11？" class="headerlink" title="为何使用Pybind11？"></a>为何使用Pybind11？</h3><p>对于一个由C&#x2F;C++编写的python库来说，开发阶段的测试和最终代码的发布都需要开发者能够快捷且正确地编译代码生成目标文件。Pybind11是一个纯头文件的项目，一方面，它基于原生Python&#x2F;C API，兼容所有原生函数接口，另一方面，它仅仅保留了部分重要的函数和类，非常轻量，仅需在代码中包含头文件而不需要链接额外的静态库。因此，在不同的操作系统上，可以直接使用<code>python setup.py build_ext</code>进行编译和构建，这也极大地方便了开发运维一体化。</p>
<h3 id="如何使用Pybind11"><a href="#如何使用Pybind11" class="headerlink" title="如何使用Pybind11"></a>如何使用Pybind11</h3><h4 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h4><p>前文所述，pybind11是一个纯头文件的项目，我们可以通过<code>pip install pybind11</code>直接进行安装。进入<code>python根目录/Lib/site-packages/pybind11/include/pybind11</code>中可以看到其提供的所有头文件。</p>
<p>使用IDE(例如VS等)进行开发时，对于头文件目录相关的配置，可以将<code>python根目录/Lib/site-packages/pybind11/include</code>目录以及<code>Python.h</code>所在的<code>python根目录/include</code>目录加入配置项。对于库目录相关配置，只需将<code>python3x.lib</code>所在的<code>python根目录/libs</code>目录加入配置项即可。</p>
<p>以Visual Studio 2022举例，目录项配置如下</p>
<img src="http://tva1.sinaimg.cn/large/006g42Mjly1h7eaizu1dqj31n10so1iu.jpg" alt="image.png"  />

<p>另外将输出类型改为dll，文件后缀改为pyd即可生成对应库文件。</p>
<h4 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h4><p>假设要用C++实现如下python代码</p>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#文件名：foo.py，即我们要写一个名为foo的库</span>
<span class="token keyword">class</span> <span class="token class-name">Guest</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name

<span class="token keyword">class</span> <span class="token class-name">Vip</span><span class="token punctuation">(</span>Guest<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> no<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>no <span class="token operator">=</span> no
        
<span class="token keyword">class</span> <span class="token class-name">Greeter</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token operator">**</span>attr<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
        self<span class="token punctuation">.</span>cnt <span class="token operator">=</span> <span class="token number">0</span>
        self<span class="token punctuation">.</span>attr <span class="token operator">=</span> attr
    <span class="token keyword">def</span> <span class="token function">greet</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> guest<span class="token punctuation">,</span> count <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello "</span> <span class="token operator">+</span> guest<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> count<span class="token punctuation">:</span>
	        self<span class="token punctuation">.</span>cnt <span class="token operator">+=</span> <span class="token number">1</span>

<span class="token keyword">def</span> <span class="token function">get_localtime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">import</span> time
    localtime <span class="token operator">=</span> time<span class="token punctuation">.</span>asctime<span class="token punctuation">(</span>time<span class="token punctuation">.</span>localtime<span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> localtime</code></pre>

<p>首先我们先来看<code>Guest</code>和<code>Vip</code>。我们可以定义好前两个类的继承关系和构造函数。</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">struct Guest &#123;
    Guest(const std::string&amp; name) :name(name) &#123;&#125;
    std::string name;
&#125;;

struct Vip: public Guest &#123;
    Vip(const std::string&amp; name, int no) :Guest(name) &#123;
        this-&gt;no &#x3D; no;
    &#125;
    int no;
&#125;;</code></pre>

<p>然后我们声明一个模块<code>foo</code>，并将这两个类注册进来。</p>
<pre class="language-C++" data-language="C++"><code class="language-C++">PYBIND11_MODULE(foo, m) &#123; &#x2F;&#x2F; 宏PYBIND11_MODULE的第一个参数是导出后在python中的包名，第二个参数是下文module实例的符号
    py::class_&lt;Guest&gt;(m, &quot;Guest&quot;) &#x2F;&#x2F; class_模板中填写要导出的C++类，参数第二个是导出后在python中的类名
        .def(py::init&lt;const std::string&amp;&gt;()); &#x2F;&#x2F; init模板中填写构造函数的类型表
    py::class_&lt;Vip, Guest&gt;(m, &quot;Vip&quot;) &#x2F;&#x2F; class_模板中第二个参数开始填写要继承的C++类
        .def(py::init&lt;const std::string&amp;, int&gt;());
&#125;</code></pre>

<p>接下来我们来实现Greeter。Greeter的构造函数比较复杂，是可变参数，需要固定的格式(args, kwargs)。这里将其写在类的外面。类的方法可以写在类的里面，但需要加上<code>static</code>声明，不需要<code>self</code>参数，否则需要写在类外面，并且第一个参数为对象自身。</p>
<p>我们希望把Greeter的<code>cnt</code>属性也给暴露出来，因此需要写一个get方法，这个方法写在类里面就好。</p>
<pre class="language-C++" data-language="C++"><code class="language-C++">struct Greeter &#123;
    std::string name;
    int cnt;
    py::dict attr;
    
    py::object get_cnt() &#123;
        return py::cast(this-&gt;cnt); &#x2F;&#x2F; py::cast可以将参数转为py::object类型(如果能转换的话)
    &#125;
&#125;;

py::object Greeter__init__(py::args args, py::kwargs kwargs) &#123;
    py::object self &#x3D; args[0]; &#x2F;&#x2F; self一般是第0个positional parameter
    self.attr(&quot;__init__&quot;)(); &#x2F;&#x2F; .attr方法类似于python中取attribute，返回一个可能是属性也可能是方法的对象，这里用&quot;()&quot;执行__init__方法进行默认构造的初始化
    Greeter&amp; g &#x3D; self.cast&lt;Greeter&amp;&gt;(); &#x2F;&#x2F; cast方法可以将python类型转为C++类型(如果能转换的话)
    std::string name &#x3D; args[1].cast&lt;std::string&gt;(); &#x2F;&#x2F; 这里假定name是positional传参的，不在attr中，实际情况可能并非如此
    py::dict attr &#x3D; kwargs;
    g.name &#x3D; name;
    g.cnt &#x3D; 0;
    g.attr &#x3D; attr;
    return py::none();
&#125;

py::object Greeter_greet(py::object self, py::object guest, py::object count) &#123;
    Greeter&amp; g &#x3D; self.cast&lt;Greeter&amp;&gt;();
    Guest&amp; gu &#x3D; guest.cast&lt;Guest&amp;&gt;();
    py::print(py::str(&quot;Hello &quot;) + py::str(gu.name) + py::str(&quot;!&quot;)); &#x2F;&#x2F; 这里直接调用了python中print，并使用了py::str重载过的+
    if (count.cast&lt;bool&gt;()) &#123; &#x2F;&#x2F; 不能用if(py::object)，那样是判断指针是否为空 
        g.cnt +&#x3D; 1;
    &#125;
    return py::none(); &#x2F;&#x2F; 没有返回值，返回None
&#125;</code></pre>

<p>由于可变参数需要运行时动态绑定，因此不能上之前一样用静态的模板编译，因此参考Boost Python的<a href="https://wiki.python.org/moin/boost.python/HowTo#A.22Raw.22_constructor">Raw Constructor</a>加上个人实验，发现如下形式有效(与Boost Python相反)。</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 在PYBIND11_MODULE中加上
py::class_&lt;Greeter&gt;(m, &quot;Greeter&quot;)
    .def(py::init&lt;&gt;())
    .def(&quot;__init__&quot;, &amp;Greeter__init__) &#x2F;&#x2F; 可变参数的函数不需要写py::arg
    .def(&quot;greet&quot;, &amp;Greeter_greet, py::arg(&quot;guest&quot;), py::arg(&quot;count&quot;) &#x3D; false) &#x2F;&#x2F; py::arg中填写导出后在python中的方法名，可以对arg对象直接赋值来规定参数默认值
    .def_property(&quot;cnt&quot;, &amp;Greeter::get_cnt, nullptr); &#x2F;&#x2F; 第一个参数为导出后在python中的属性名，二三参数分别为get和set该属性的函数指针</code></pre>

<p>最后我们写一下<code>get_localtime</code>方法</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">py::object get_localtime() &#123; &#x2F;&#x2F; 不需要self参数
    py::object time &#x3D; py::module_::import(&quot;time&quot;); &#x2F;&#x2F; 运行时导入time模块
    py::object localtime &#x3D; time.attr(&quot;asctime&quot;)(time.attr(&quot;localtime&quot;)(time.attr(&quot;time&quot;)()));
    return localtime;
&#125;

&#x2F;&#x2F; 在PYBIND11_MODULE中加上
m.def(&quot;get_localtime&quot;, &amp;get_localtime); &#x2F;&#x2F; 写法与method相同</code></pre>

<p>生成foo库并实验一下，发现代码正确无误。</p>
<img src="http://tva1.sinaimg.cn/large/006g42Mjly1h7eejvwnc9j30rb0kwne3.jpg" alt="image.png" style="zoom:50%;" />

<p>上述代码涉及如下Pybind11使用知识点：</p>
<ul>
<li>C++变量与py::object对象的转换</li>
<li>声明一个module并注册类和方法<ul>
<li>类继承</li>
<li>类方法的注册<ul>
<li>init方法</li>
<li>可变参数(init或普通方法)</li>
<li>默认参数</li>
</ul>
</li>
<li>类属性的注册<ul>
<li>getter</li>
<li>setter</li>
</ul>
</li>
<li>模块方法的注册</li>
</ul>
</li>
<li>运行时导入其他python模块</li>
<li>正确使用if判断</li>
<li>none返回值</li>
</ul>
<p>其余一些tricky的使用大多与python有关，例如<code>set</code>等内置类型或方法可以通过<code>builtins</code>包拿到，以及可以通过<code>object.__class__()</code>新建一个对象等。关于API的使用使用可参考<a href="https://pybind11.readthedocs.io/en/stable/#">官方文档</a>，<a href="https://github.com/pybind/pybind11/discussions">官方仓库讨论</a>，<a href="https://github.com/pybind/pybind11/issues">官方仓库issue</a>，stackoverflow等平台</p>
<h3 id="cpp-easygraph项目架构"><a href="#cpp-easygraph项目架构" class="headerlink" title="cpp_easygraph项目架构"></a>cpp_easygraph项目架构</h3><h4 id="目录架构"><a href="#目录架构" class="headerlink" title="目录架构"></a>目录架构</h4><p>目录架构与easygraph基本保持一致。easygraph中有的文件夹和.py文件，cpp_easygraph目录下也有对应文件夹和cpp文件。</p>
<p>cpp_easygraph的<code>common</code>文件夹中存放共用的头文件以及一些工具函数，这部分在easygraph中没有对应。</p>
<p>python通过可以嵌套的<code>__init__.py</code>来指定import时导入的符号，以及在py文件中使用<code>__all__</code>来指定文件暴露出去的符号。cpp_easygraph使用<code>__init__.h</code>文件期望达到相同的抽象级别。注意，这里使用头文件仅仅为了达成一层include时的抽象，想要include某个文件夹下所有符号，包含该<code>__init__.h</code>即可。举例</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; cpp_easygraph&#x2F;functions&#x2F;path&#x2F;path.h
py::object _dijkstra_multisource(py::object G, py::object sources, py::object weight, py::object target);
&#x2F;&#x2F; other functions need to be exposed...

&#x2F;&#x2F; cpp_easygraph&#x2F;functions&#x2F;path&#x2F;__init__.h
#include &quot;path.h&quot;
&#x2F;&#x2F; other header files need to be included

&#x2F;&#x2F; cpp_easygraph&#x2F;function&#x2F;__init__.h
#include &quot;path&#x2F;__init__.h&quot;
&#x2F;&#x2F; other header files need to be included

&#x2F;&#x2F; cpp_easygraph&#x2F;cpp_easygraph.cpp
#include &quot;functions&#x2F;__init__.h&quot;</code></pre>

<h4 id="类架构"><a href="#类架构" class="headerlink" title="类架构"></a>类架构</h4><p>目前仅仅实现了Graph和DiGraph两个类，DiGraph继承于Graph，二者仅有python绑定的函数不同，成员变量是相同的。</p>
<p>实际函数中，要使用成员变量，直接cast到基类的引用Graph&amp;即可。要使用方法，通过传入的py::object对象使用attr进行对应python方法的执行。</p>
<h4 id="类设计"><a href="#类设计" class="headerlink" title="类设计"></a>类设计</h4><p>实现Graph类的思路大体沿用easygraph，node和adj均为与python代码一致的map结构。python中dict的键可以是任意可哈希对象，easygraph也支持任意这样的对象成为node.但是C++中的map暂时无法支持多样的类型，因此维护两个内部映射的<code>node_to_id</code>和<code>id_to_node</code>，在C++函数计算以及数据结构存储时使用node_t(目前typedef为int，可更换为unsigned等)，在函数解析参数和函数返回时使用进行对象的转换。</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; common.h
typedef int node_t;
typedef float weight_t;

&#x2F;&#x2F; Graph.h
struct Graph &#123;
    node_dict_factory node;
    adj_dict_factory adj;
    py::dict node_to_id, id_to_node, graph;
    node_t id;
    bool dirty_nodes, dirty_adj;
    py::object nodes_cache, adj_cache;
&#125;</code></pre>

<p>Graph需要暴露adj和node属性，每次都查找dict生成显然对速度不利。考虑到用户在进行数据增删和数据使用往往是两个不同的时间段，这里牺牲空间加入两个cache对象，当发生数据结构内容改变时置dirty标志为1，下次调用属性get方法时就会重新生成一次，并抹去dirty，以此减少时间消耗。</p>
<p>node和adj的attr部分默认为std::string到weight_t(目前typedef为float，可更换为double等)的映射。</p>
<h3 id="将cpp-easygraph嵌入到easygraph"><a href="#将cpp-easygraph嵌入到easygraph" class="headerlink" title="将cpp_easygraph嵌入到easygraph"></a>将cpp_easygraph嵌入到easygraph</h3><h4 id="类的嵌入"><a href="#类的嵌入" class="headerlink" title="类的嵌入"></a>类的嵌入</h4><p>尝试导入cpp_easygraph并定义GraphC和DiGraph类。两个类继承于cpp_easygraph中C++编写的类，并定义cflag以便在运行时与python类区分。</p>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># graph.py</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token keyword">import</span> cpp_easygraph
    <span class="token keyword">class</span> <span class="token class-name">GraphC</span><span class="token punctuation">(</span>cpp_easygraph<span class="token punctuation">.</span>Graph<span class="token punctuation">)</span><span class="token punctuation">:</span>
        cflag <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment"># </span>
<span class="token keyword">except</span> ImportError<span class="token punctuation">:</span>
    <span class="token keyword">class</span> <span class="token class-name">GraphC</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">**</span>graph_attr<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"..."</span><span class="token punctuation">)</span>
            <span class="token keyword">raise</span> RuntimeError</code></pre>

<h4 id="方法的嵌入"><a href="#方法的嵌入" class="headerlink" title="方法的嵌入"></a>方法的嵌入</h4><p>为了优雅地嵌入cpp_easygraph的方法，编写了一个装饰器以用于装饰对应的python函数，使得函数最终能根据传入类的类型调用对应语言编写的方法。</p>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># decorators.py</span>
<span class="token keyword">def</span> <span class="token function">hybrid</span><span class="token punctuation">(</span>cpp_method_name<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 函数闭包实现装饰器，参数为cpp_easygraph中导出的方法名</span>
    <span class="token keyword">def</span> <span class="token function">_hybrid</span><span class="token punctuation">(</span>py_method<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
            G <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
            <span class="token keyword">if</span> G<span class="token punctuation">.</span>cflag <span class="token keyword">and</span> cpp_method_name <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span> <span class="token comment"># 判断是否为C++编写的类</span>
                <span class="token keyword">import</span> cpp_easygraph
                <span class="token keyword">try</span><span class="token punctuation">:</span>
                    cpp_method <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>cpp_easygraph<span class="token punctuation">,</span> cpp_method_name<span class="token punctuation">)</span>
                    <span class="token keyword">return</span> cpp_method<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span> <span class="token comment"># 调用C++编写的方法</span>
                <span class="token keyword">except</span> AttributeError <span class="token keyword">as</span> e<span class="token punctuation">:</span>
                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Warning: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>e<span class="token punctuation">&#125;</span></span><span class="token string">. use python method instead."</span></span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> py_method<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span> <span class="token comment"># 否则依旧调用python编写的方法</span>
        <span class="token keyword">return</span> method
    <span class="token keyword">return</span> _hybrid</code></pre>

<p>使用装饰器举例：</p>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token decorator annotation punctuation">@hybrid</span><span class="token punctuation">(</span><span class="token string">"cpp_density"</span><span class="token punctuation">)</span> <span class="token comment"># 如果传入GraphC对象，则调用cpp_easygraph.cpp_density</span>
<span class="token keyword">def</span> <span class="token function">density</span><span class="token punctuation">(</span>G<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> G<span class="token punctuation">.</span>number_of_nodes<span class="token punctuation">(</span><span class="token punctuation">)</span>
    m <span class="token operator">=</span> G<span class="token punctuation">.</span>number_of_edges<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> m <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">0</span>
    d <span class="token operator">=</span> m <span class="token operator">/</span> <span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> G<span class="token punctuation">.</span>is_directed<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        d <span class="token operator">*=</span> <span class="token number">2</span>
    <span class="token keyword">return</span> d</code></pre>

<h4 id="实际调用"><a href="#实际调用" class="headerlink" title="实际调用"></a>实际调用</h4><p>装饰器使得函数会自动根据传入的类选择对应代码段执行。</p>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> easygraph <span class="token keyword">as</span> eg
G1 <span class="token operator">=</span> eg<span class="token punctuation">.</span>Graph<span class="token punctuation">(</span><span class="token punctuation">)</span>
G2 <span class="token operator">=</span> eg<span class="token punctuation">.</span>GraphC<span class="token punctuation">(</span><span class="token punctuation">)</span>
G1<span class="token punctuation">.</span>add_edges<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
G2<span class="token punctuation">.</span>add_edges<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
G3 <span class="token operator">=</span> G2<span class="token punctuation">.</span>py<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># G2转为Graph类型</span>
G4 <span class="token operator">=</span> G<span class="token punctuation">.</span>cpp<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># G1转为GraphC类型</span>
eg<span class="token punctuation">.</span>density<span class="token punctuation">(</span>G1<span class="token punctuation">)</span> <span class="token comment"># 调用python代码写的函数</span>
eg<span class="token punctuation">.</span>density<span class="token punctuation">(</span>G2<span class="token punctuation">)</span> <span class="token comment"># 调用C++代码写的函数</span>
eg<span class="token punctuation">.</span>density<span class="token punctuation">(</span>G3<span class="token punctuation">)</span> <span class="token comment"># 调用python代码写的函数</span>
eg<span class="token punctuation">.</span>density<span class="token punctuation">(</span>G4<span class="token punctuation">)</span> <span class="token comment"># 调用C++代码写的函数</span></code></pre>

<h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><ul>
<li><p>C++实现的Graph类中，python dict类型的nodes和adj以cache的形式存储，导致其并不能做到所见即所得。例如在python中，要对node属性做修改仅需<code>G.nodes[...][key]=value</code>即可，但在C++中，这无法改变以std::unordered_map形式存储的实际数据。另外cache无法做到精确更新，每次都是重新生成一遍dict，效率不高。</p>
<p>思考过的解决方式有：自定义一个继承于dict的类，用于精细化控制nodes和adj的cache，内部封装所属Graph的指针，但这带来两个问题：</p>
<ul>
<li>如果这个类由C++来写，此类就没有办法继承python dict，因为类的方法和成员等都是运行时确定的，无法静态编译。参见<a href="https://github.com/pybind/pybind11/issues/1193">#1193</a></li>
<li>如果这个类由Python来写，那么Graph下属c该类，该类又需要存储Graph的引用，会造成循环引用，无法判断gc能否正常回收内存。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>技术视野</category>
      </categories>
      <tags>
        <tag>Pybind11</tag>
      </tags>
  </entry>
  <entry>
    <title>shell和terminal</title>
    <url>/Blog/2023/02/09/shell%E5%92%8Cterminal/</url>
    <content><![CDATA[<h4 id="Terminal和TTY"><a href="#Terminal和TTY" class="headerlink" title="Terminal和TTY"></a>Terminal和TTY</h4><ul>
<li><p>古早年代通过电传打印机(<strong>t</strong>ele<strong>ty</strong>pewriter)让用户与计算机交互，打字机上输入的文本可以直接发送到计算机，计算机的输出也通过打字机打印出来。</p>
<style>.hafhahjjvmke{zoom:50%;}</style><img src="/Blog/2023/02/09/shell%E5%92%8Cterminal/image-20230209093403164.png" class="hafhahjjvmke" alt="image-20230209093403164">

<blockquote>
<p>UART：Universal Asynchronous Reciver&#x2F;Transmitter，通用异步收发传输器</p>
<p>line dicipine：行规范</p>
</blockquote>
</li>
<li><p>终端设备(例如VT100)出现并逐渐取代了电传打印机</p>
<blockquote>
<p>使用阴极射线管进行显示，供应商采用ascii字符集这一相同标准，同时显示器单行最大80字符的设定也能在现代编程规范中觅得踪影(Google C++ style, PEP8)</p>
</blockquote>
</li>
<li><p>PC时代，显示器和键盘取代了传统终端。考虑到兼容性，在内核中模拟了一个终端(terminal emulator)与tty驱动交互</p>
<style>.nrsgdqueelgr{zoom: 50%;}</style><img src="/Blog/2023/02/09/shell%E5%92%8Cterminal/image-20230209093744371.png" class="nrsgdqueelgr" alt="image-20230209093744371"></li>
</ul>
<h4 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h4><p>shell是<strong>操作系统和用户进行交互</strong>的<strong>程序</strong>，运行在terminal之中，常见实现有<code>sh</code>，<code>bash</code>，<code>csh</code>，<code>cmd</code>，<code>pwoershell</code>，<code>explore</code>(windows资源管理器)，<code>Ubuntu GNOME Terminal</code>……</p>
<h4 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h4><p>Console是早期计算机为了调控设备而设立的一些开关等</p>
<p>由内核直接提供的终端页面叫虚拟控制台(Virtual Console)，而上述拥有图形化界面的是终端窗口(伪终端)</p>
<h4 id="PTY"><a href="#PTY" class="headerlink" title="PTY"></a>PTY</h4><p>运行在用户态的终端是PTY伪终端(<strong>p</strong>seudo t<strong>ty</strong>)，更安全和灵活</p>
<blockquote>
<p>因此当桌面崩掉无法响应的时候，你仍然能通过内核里的TTY来做要做的事</p>
</blockquote>
<p>以GNOME terminal为例，流程为</p>
<ol>
<li>建立GNOME terminal终端</li>
<li>打开<code>/dev/ptmx</code>字符文件，获得文件描述符PTY master，在<code>/dev/pts/</code>创建PTY slave设备</li>
<li>terminal拥有了上述的设备文件，fork出一个bash</li>
<li>terminal监听键盘事件，然后将其发送到PTY master，后者将经由line discipline处理的输入回传给terminal以供显示</li>
<li>当按下回车后tty driver将缓冲的数据复制到pts中，此时bash读取并fork运行相关的命令</li>
<li>由于fork出的命令拥有与bash相同的资源，因此可以操作pts进而回显到terminal上</li>
<li>当按下ctrl C以后，line discipline产生一个SIGINT信号发给pts，进而交给bash来kill子进程</li>
</ol>
<style>.gxuaqoamqnxs{zoom: 50%;}</style><img src="/Blog/2023/02/09/shell%E5%92%8Cterminal/image-20230209102402053.png" class="gxuaqoamqnxs" alt="image-20230209102402053">

<h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><p>SSH的全称是Secure Shell Protocol，目标机器在22端口监听到连接请求做完验证工作后会申请创建一个tty，建立连接后的结构如图</p>
<style>.eiwspzudvhuo{zoom:50%;}</style><img src="/Blog/2023/02/09/shell%E5%92%8Cterminal/image-20230209103551239.png" class="eiwspzudvhuo" alt="image-20230209103551239">

<p>用户端部分禁用了line discipline，因此相关命令经过回车后才不会被执行。但服务端部分的line discipline没有被禁用，因此能够在服务端执行并正常回显</p>
<blockquote>
<p>所以才会出现ssh连接远程服务器的时候，终端中输入字符一卡一卡的，因为每一个字符的回显都要经过网络的一次来回传输</p>
</blockquote>
]]></content>
      <categories>
        <category>技术视野</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>《神拳考》读书笔记</title>
    <url>/Blog/2023/02/24/%E3%80%8A%E7%A5%9E%E6%8B%B3%E8%80%83%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>《神拳考》止庵 著 华东师范大学出版社</p>
<p>义和团运动的兴起与宗教由非常大的关系，可能直接原因来自于数月的旱灾，但根本原因在于洋人对清政府土地的占领、廉价工业品的倾销和天主教带来的<strong>宗教</strong>冲击引发民众<strong>愤懑不满</strong>。实际上这是一场神的战争。</p>
<p>简单的<strong>降神</strong>仪式降低了普通民众参与义和团的门槛，同时参与者中不具判断能力的孩童居多。</p>
<p>信奉诸神种类繁多，大体可以分为</p>
<ul>
<li>佛道教及民间教门崇信的佛祖神仙</li>
<li>小说戏曲中的英雄豪杰</li>
<li>历史上的圣贤名臣武将</li>
<li>自然神和自创神</li>
</ul>
<p>给身处底层的群众提供了一次使自己突然变得伟大的机会。</p>
<p>但这种诸神体系下，人与神一对一的关系也就决定了义和团的组织形式不可能多严密。但神整合了团民，也整合了团民攻击的对象，更重要的是赋予了团民<strong>必胜的信念</strong>。</p>
<p>义和团的口号“扶清灭洋”使得其内心始终没有把自身放在朝廷的对立面，从来没有针对清朝的革命意识。</p>
<p>随后清政府对义和团逐渐妥协化，因为镇压已无可能。彼时起，团民开始大规模屠杀教民（被杀者不一定真的是教民），但屠戮的行为很可能被团民理解为神对于对立面的消灭。</p>
<p>随着对立面的范围逐渐被扩大化，<strong>焚表</strong>这一行为也逐渐扩散，即烧纸看是否纸灰飞扬，如果三次不起，则被污为教民。同样<strong>头顶十字</strong>也成为判断是否是教民的标准，但同样解释权也在于人。集体往往可以承担个体所不能承担的责任，在集体中个体也往往无需做出属于自己的判断。</p>
<p>冲突随后再次被泛化，洋货与洋人一道，也成为必须要破坏的对象。此时，对立面成为“洋”文化这一整体。但与此同时，最终义和团所反对的，也仅仅局限于“洋”这一字眼的忌讳，丧失了具体内容，因此只能算是笼统的排外。洋货均以“土”字替代，团民本身也无法避免使用，就默许了这种解决冲突的方式。</p>
<p>忌讳这种语言系统的成功，最终可能就变成大家相信的事实上的成功了。</p>
<p>红灯照在义和团中一直比较神秘，义和团视女性为“不洁”，例如认为女性会使得法术失灵，但却又用“洁”来对抗“不洁”。红灯照中均为未嫁之女。</p>
<p>传闻坚定了民众的信念，从而造就了新的传闻，这也使得义和团的影响力变得更为广大。</p>
<p>人们参与仪式，充分显示着“国家兴亡，匹夫有责”这一传统姿态。仪式的魅力是在两个方面：它把个人引入集体，从而彼此互相成为依靠，互相给予力量；同时，它又使每一个人都感到自己是最重要的，因此而大为振奋。当大家都诚心诚意地参与义和团的各种仪式时，整个社会都变成了义和团。</p>
<p>载漪和慈禧，一个要攫取皇位，一个要保住权力，都不惜以天下孤注一掷，这若不是迷狂年代里最明白的两个人，就是最迷狂的两个人了。义和团这样真正的群众运动，即使为当局所鼓动号召，始终也是难以控制的，无论节奏、规模，还是后果，都是如此。只不过慈禧、载漪等对此的反应特别迟钝罢了。</p>
<p>然而这是一个普遍冲昏头脑的年代，重要的不在于现实如何，而在于对现实的解释如何。</p>
<p>义和团除了是一场农民运动，一次“神-鬼之战”和一桩并非独立存在的历史事件外，从根本上讲，也是一种思维方式。这种思维方式不仅为团民所有，也为当时大多数人所有，而无拘社会地位与文化层次。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>mit6.828实验报告</title>
    <url>/Blog/2023/05/03/mit6-828%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul>
<li>Virtual Box 6.1</li>
<li>Ubuntu 22.04</li>
<li>MIT6.828 2022</li>
</ul>
<h3 id="Lab1：Xv6-and-Unix-utilities"><a href="#Lab1：Xv6-and-Unix-utilities" class="headerlink" title="Lab1：Xv6 and Unix utilities"></a>Lab1：Xv6 and Unix utilities</h3><p>文档链接：<a href="https://pdos.csail.mit.edu/6.828/2022/labs/util.html">Lab: Xv6 and Unix utilities (mit.edu)</a></p>
<h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><p>本练习要求读完xv6第一章</p>
<blockquote>
<ul>
<li><p>为什么要用fork+exec而不是将二者合并？</p>
<p>这样做提供了一个重定向文件描述符而不扰乱原进程的机会。fork和exec都不会修改文件描述符表，如果做成原子化的，那么若要修改子进程的fd，势必需要在原进程做修改和还原。</p>
<p>例如在shell中执行cat &lt; in.txt时，先fork，然后解析cmd，然后输入重定向，然后exec</p>
</li>
<li><p>Pipe的好处？</p>
<ul>
<li>自清理</li>
</ul>
</li>
<li><p>任意长内容传输</p>
</li>
<li><p>两个进程并发执行</p>
</li>
</ul>
</blockquote>
<p>按照提示写就行，这里的sleep是系统调用，具体的调用原理我暂时还不清楚，应该是一个生成好的入口直接渠道kernel的sleep了</p>
<h4 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h4><p>参考xv6书中给出的pipe使用样例</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//fd[0]用于read，fd[1]用于write</span></code></pre>

<p>我在parent里写了一个wait(&amp;pid)，防止出现对管道的争用</p>
<p>然后按照描述parent先写然后等待子进程结束，子进程先读后写最后退出，然后parent读取后退出</p>
<h4 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h4><p>这道题难度稍微有点高，具体要做的在<a href="http://swtch.com/~rsc/thread/">this page</a>中已经给出。简单来说需要主进程往管道里塞2~…的数字，之后每个子进程读取并打印第一个数a，建立一个管道，然后派生出一个和自己操作相同的子进程。前一个子进程将能够整除a的数字筛掉，并将剩余数字写到管道中交由后一个子进程处理。</p>
<p>当管道的写端被关闭时，进程read的返回值是0，我在这里卡了一段时间。</p>
<p>这是出错的代码：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">prime</span><span class="token punctuation">(</span>fd_<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">else</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">%</span> num <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token function">write</span><span class="token punctuation">(</span>fd_<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd_<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd_<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>这里我错误地认为父进程单方面close父子进程就不会再有东西打开文件，但是实际上fork时子进程也会继承父进程的文件描述符表，所以要父子进程都关掉fd[1]，子进程read的返回值才会是0。</p>
<p>正确写法如下：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd_<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">prime</span><span class="token punctuation">(</span>fd_<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">else</span><span class="token punctuation">&#123;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd_<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">%</span> num <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token function">write</span><span class="token punctuation">(</span>fd_<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd_<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>另外本体递归和fork的概念也容易把人搞迷糊，用return还是exit，这都是需要考虑的问题。</p>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>本题可以参考ls的写法，了解怎么遍历文件夹以及判断文件类型，然后用递归写就可以了。</p>
<h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h4><p>实现方式不难，while循环里用gets读入一行，如果发现长度为0那么就break，否则手动从buf中找出arg们，然后调用fork以及exec。这里xargs的argv[1]是命令名，到新的argv中要挪到argv[0]去，后面的刚好依次前移。</p>
<style>.lovboojwcvrs{zoom: 50%;}</style>

<h3 id="Lab2：system-calls"><a href="#Lab2：system-calls" class="headerlink" title="Lab2：system calls"></a>Lab2：system calls</h3><p>文档链接：</p>
<p>本次lab要求读完xv6第二章</p>
<blockquote>
<ul>
<li>RISCV拥有三种模式：<code>machine mode</code>, <code>supervisor mode</code>和<code>user mode</code>，CPU从machine mode开始，执行一些命令后转到supervisor mode，在该mode下，我们称系统运行在内核态。RISCV提供<code>ecall</code>指令使代码进入supervisor mode，然后对syscall指令进行检查</li>
</ul>
</blockquote>
<h4 id="Using-gdb"><a href="#Using-gdb" class="headerlink" title="Using gdb"></a>Using gdb</h4><p>make qemu-gdb后会在项目根目录下生成<code>.gdbinit</code>文件，lab文档要求重新开一个窗口运行gdb。实测可用的命令为：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">gdb-multiarch <span class="token parameter variable">-iex</span> <span class="token string">"set auto-load safe-path /"</span></code></pre>

<p><code>gdb-multiarch</code>用于支持<code>.gdbinit</code>中的riscv架构，<code>auto-load</code>用于让gdb自动加载根目录下的<code>.gdbinit</code>文件</p>
<p>可以使用如下命令使以后只需要使用safegdb即可</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">>></span> ~/.bashrc
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">safegdb</span><span class="token operator">=</span><span class="token string">"gdb-multiarch -iex <span class="token entity" title="\&quot;">\"</span>set auto-load safe-path /<span class="token entity" title="\&quot;">\"</span>"</span></code></pre>

<blockquote>
<p> gdb的layout src指令会使终端会一分为二，可以使用Ctrl+X, A来关闭layout</p>
</blockquote>
<p>xv6执行流程：</p>
<ul>
<li>系统启动后以<code>machine mode</code>执行<code>kernel/entry.S</code>，它设定一些特权寄存器后调用<code>kernel/start.c</code>的<code>start</code>函数。</li>
<li><code>start</code>函数设定好<code>mstatus</code>以及<code>mepc</code>两个寄存器以后开启中断等，然后使用<code>mret</code>指令读取前述两个集群器的值，进入<code>supervisor mode</code>以及调用<code>kernel/main.c</code>的<code>main</code>函数。</li>
<li><code>main</code>函数初始化好一系列东西以后调用<code>kernel/proc.c</code>的<code>scheduler</code>函数，进行进程调度。第一个用户态进程是<code>user/initcode.S</code>，它由前述过程中调用的<code>kernel/proc.c</code>的<code>userinit</code>函数初始化进程相关信息。</li>
<li><code>initcode.S</code>通过系统调用执行<code>exec(&quot;/init&quot;)</code>，该程序来自于<code>user/init.c</code>，可以打开一个<code>console</code>文件，并fork出一个子进程执行<code>sh</code>命令</li>
</ul>
<blockquote>
<p>syscall的执行流程是用户进程设立好对应的寄存器的值后，使用硬件终端指令进行软中断，CPU发现中断后进行mode的切换以及切换程序栈等，实现从用户态到内核态的转变</p>
</blockquote>
<p>Q: Looking at the backtrace output, which function called syscall?<br>A: Function usertrap called function syscall.</p>
<p>Q: What is the value of p-&gt;trapframe-&gt;a7 and what does that value represent? (Hint: look user&#x2F;initcode.S, the first user program xv6 starts.)<br>A: The value of p-&gt;trapframe-&gt;a7 is 7. <code>li a7, SYS_exec</code> in user&#x2F;initcode.S moves SYS_exec whose value is 7 into register a7.</p>
<p>Q: What was the previous mode that the CPU was in?<br>A: User mode. <code>initcode.S</code> which executes in user mode uses syscall to execute <code>init</code>.</p>
<p>Q: Write down the assembly instruction the kernel is panicing at. Which register corresponds to the varialable num?<br>A: The instruction is “lw a3,0(zero)”. Varialable num is stored in a3.</p>
<p>Q: Why does the kernel crash? Hint: look at figure 3-3 in the text; is address 0 mapped in the kernel address space? Is that confirmed by the value in scause above?<br>A: The kernel crashes because it reads the value of an invalid address 0 which is not mapped in the kernel address space. The value scause is 0xd which means a load page fault occurred referring to chapter 4.1.10 of riscv-privileged-v1.10.</p>
<p>Q: What is the name of the binary that was running when the kernel paniced? What is its process id (pid)?<br>A: The name of the process is “initcode” and its pid is 1.</p>
<h4 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h4><p>本题要求实现一个新系统调用trace，它能够规定进程接下来执行哪些系统调用会打印提示信息。</p>
<p>首先按照文档要求修改相关头文件c文件，添加trace函数。文档在下一步提示将tracemask存储进proc结构体中，称为进程信息的一部分，这一做法实在很巧妙。我原先在想是否需要在内核中使用全局变量+映射表等方式来存储，这样看来完全是没有必要的。因此<code>sys_trace</code>函数做的就是将它的参数存进进程信息中，之后<code>syscall</code>函数就可以根据这个值来判断是否需要打印相关信息。由于结构体的这个值初始化的时候是0，所以不必担心鲁棒性。</p>
<p>之后在fork时将子进程的tracemask设为和父进程一样就可以通过测试啦，如果<code>trace children</code>那个样例报超时，可以进gradelib.py中把<code>run_qemu_kw</code>的timeout设高一点。</p>
<h4 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h4><p>本题要求实现一个新的系统调用sysinfo，该函数需要在参数中的sysinfo结构体中填入空闲的内存数以及系统总进程数。</p>
<p><code>sys_sysinfo</code>函数具体的准备工作与trace类似，主要的工作在于实现<code>freemem</code>，<code>nproc</code>以及使用<code>copyout</code>。<code>freemem</code>统计系统中所有可用内存，这里在<code>kernel/kalloc.c</code>中可以使用kmem.freelist拿到空闲页的链表，统计空闲页数再乘上每页的大小即可。<code>nproc</code>统计所有状态不为UNUSED的进程数目(UNUSED则是类似进程池的概念，一开始初始化了，但是没有使用)，再<code>kernel/proc.c</code>中遍历proc数组即可。</p>
<p><code>copyout</code>则用于将数据拷贝到用户态内存，利用<code>myproc</code>函数拿到进程的页表等信息后即可将参数填写完毕。</p>
<p>最后还要自己加个time.txt，否则差一份满分。</p>
<style>.hcfaxwisroqm{zoom:50%;}</style>

<p>下面总结一下增加syscall的流程，以<code>xxx</code>为例</p>
<ul>
<li><p><code>user/user.h</code>主要用于给用户态进程提供一个可以调用的函数声明<code>xxx()</code>，具体的函数定义在<code>user/usys.pl</code>生成汇编码中(实际上这些函数就是用ecall指令调用kernel中的系统调用函数桩，和系统调用的实现没有关系)</p>
</li>
<li><p><code>kernel/syscall.h</code>中定义了不同系统调用的号码<code>SYS_xxx</code>，<code>kernel/syscall.c</code>中则将<code>sys_xxx()</code>放入syscalls数组的对应位置，以及在syscall_names中写入名称xxx</p>
</li>
<li><p>然后在以sys开头的c文件中实现<code>sys_xxx()</code>，例如<code>kernel/sysproc.c</code>等</p>
<blockquote>
<p>如果想要在其他文件中写一些工具函数，例如<code>kernel/kalloc.c</code>等，可以在<code>kernel/defs.h</code>中写好定义，再到具体的文件中去实现</p>
</blockquote>
</li>
</ul>
<h3 id="Lab3：page-tables"><a href="#Lab3：page-tables" class="headerlink" title="Lab3：page tables"></a>Lab3：page tables</h3><p>文档链接：<a href="https://pdos.csail.mit.edu/6.828/2022/labs/pgtbl.html">Lab: page tables (mit.edu)</a></p>
<p>本次lab要求读完xv6第三章</p>
<blockquote>
<p>xv6运行的Sv39RISC-V机器中，有效地址为39位，其中页索引27位，页内偏移12位(每页4096字节)。翻译成物理地址时，只需要将页索引更换为44位的物理索引PPN即可。</p>
<p>如果不做额外处理，一个进程将拥有2^27^个PTE，实在是过于庞大。因此采用多级页表的方式，将27位每9位分成一段，将2^9^&#x3D;512个PTE，每个PTE占8B(64位)，刚好放进一页。因此，在多级页表中，第一级页表的PTE中PPN存放对应二级页表的页号，之后转到那个物理页查找即可。每个CPU的<code>satp</code>寄存器存放根页表的地址，因此可以同时执行不同程序。</p>
<table>
<thead>
<tr>
<th>Reserved</th>
<th>PPN</th>
<th>RSW</th>
<th>D</th>
<th>A</th>
<th>G</th>
<th>U</th>
<th>X</th>
<th>W</th>
<th>R</th>
<th>V</th>
</tr>
</thead>
<tbody><tr>
<td>11位</td>
<td>44位</td>
<td>Reserved</td>
<td>Dirty</td>
<td>Accessed</td>
<td>Global</td>
<td>User</td>
<td>Executable</td>
<td>Writable</td>
<td>Readable</td>
<td>Valid</td>
</tr>
</tbody></table>
<p>补充：OS负责维护页表，而查找页表获得真实物理地址的工作实际由MMU硬件完成，因此不用担心权限问题。</p>
<style>.hblnggubppes{zoom: 50%;}</style><img src="/Blog/2023/05/03/mit6-828%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/xv6%E5%86%85%E6%A0%B8%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" class="hblnggubppes" alt="image-20230720105441496">

<p>xv6内核虚拟地址空间与物理地址空间的关系：</p>
<ul>
<li>KERNBASE到PHYSTOP从物理空间直接映射，这部分由内核自身拥有。</li>
<li>实际上QEMU只提供这部分物理存储</li>
<li>fork时为子进程分配的空间地址一定在QEMU的物理空间中，也就是在内核视角下一定在这一段，因此内核可以直接使用这个物理地址作为虚拟地址进行内存拷贝等操作</li>
<li>PHYSTOP之上的虚拟空间存放内核栈等数据，这部分同样映射到实QEMU的物理空间中<ul>
<li>所以实际上这部分物理空间在内核的虚拟空间被映射了两次</li>
<li>每一个进程都有一个内核栈，即Kstack..，为了防止溢出产生问题，增加了一个Guard Page，对应PTE_V被设为0</li>
</ul>
</li>
<li>KERNBASE之下的部分虚拟空间也从物理空间直接映射，用于操作IO设备等</li>
</ul>
<p>xv6的main函数会初始化内核页表等，此时使用的地址都是物理地址。当这些都完成之后，才会把根页表的地址放到<code>satp</code>寄存器中，那之后才由CPU负责翻译地址。</p>
<style>.fkhlxtobphfd{zoom: 50%;}</style><img src="/Blog/2023/05/03/mit6-828%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/xv6%E7%94%A8%E6%88%B7%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" class="fkhlxtobphfd" alt="image-20230720180040653">

<p>对于用户虚拟空间来说，可以使用sbrk等系统调用来增加或减少进程实际分配的空间。</p>
<p>用户进程和内核按理需要两个不同的页表，trampoline正是起这样一个桥接的跳板作用。</p>
</blockquote>
<h4 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h4><p>本题要求在每个用户进程的虚拟空间中新开辟一个USYSCALL区域，该区域对用户来说只读，提供一些数据以在用户态完成系统调用。测试中使用的<code>ugetpid()</code>，即将进程的pid数据存储在该区域。</p>
<p>模仿trapframe，先在proc结构体中增加usyscall的指针定义，在<code>allocproc()</code>函数中分配实际的物理页，与此对应在freeproc中也需要释放该页。该页分配完毕后需要安装到页表中，因此在<code>proc_pagetable()</code>函数中模仿trapframe写好usyscall的安装代码。注意，这里PTE的应该为PTE_R和<strong>PTE_U</strong>两个选项设值，前者代表只读，后者代表用户态可访问。</p>
<h4 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h4><p>本题要求按照指定的格式打印进程的页表，实现起来非常简单，参照<code>freewalk()</code>函数就可以完成遍历多级页表的代码。</p>
<h4 id="Detect-which-pages-have-been-accessed"><a href="#Detect-which-pages-have-been-accessed" class="headerlink" title="Detect which pages have been accessed"></a>Detect which pages have been accessed</h4><p>本题要求为xv6的PTE增加PTE_A这一选项并实现pgaccess这一新系统调用。pgaccess主要用于从给定的虚拟地址开始查看len个页是否被访问过，并返回一个bitmap。参考xv6 book等得知Access这一位在右起第7个，即(1L &lt;&lt; 6)。然后在<code>kernerl/sysproc.c</code>的<code>sys_pgaccess()</code>不全相关的逻辑代码。由于<code>kernel/vm.c</code>已经提供了<code>walk()</code>函数用来从任意虚拟地址找到对应的PTE，因此该代码写起来非常简单。</p>
<p>该问题的难点可能在于bitmap的处理，涉及位运算以及大端小端等等比较麻烦，这里简化处理让len不超过32位，用int存储mask。若len不足32位则左移mask。</p>
<style>.gfgbbdgiwfon{zoom:50%;}</style>

<h3 id="Lab-4：Traps"><a href="#Lab-4：Traps" class="headerlink" title="Lab 4：Traps"></a>Lab 4：Traps</h3><p>文档链接：<a href="https://pdos.csail.mit.edu/6.828/2022/labs/traps.html">Lab: Traps (mit.edu)</a></p>
<p>本次lab要求读完xv6第四章</p>
<blockquote>
<p>RISCV中与陷入有关的寄存器：</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>stvec</code></td>
<td>trap vector，存放trap handler的地址</td>
</tr>
<tr>
<td><code>sepc</code></td>
<td>error pc，存放PC，之后sret会将值拷贝进PC寄存器</td>
</tr>
<tr>
<td><code>scause</code></td>
<td>cause，存放trap的原因(错误码)</td>
</tr>
<tr>
<td><code>sscratch</code></td>
<td>临时存放某寄存器的值，然后这个寄存器可以存放trapframe的基址(虽然在用户态是固定值，但是机器码中使用了这种寻址方式)以先存储其他31个寄存器</td>
</tr>
<tr>
<td><code>sstatus</code></td>
<td>机器状态，SIE位规定是否打开中断、SPP位表明trap来自于什么模式以及要回到什么模式</td>
</tr>
</tbody></table>
<p>操作系统要做的事情：</p>
<ul>
<li>如果是设备中断+关中断状态，直接忽略以下步骤</li>
<li>关闭中断</li>
<li>设置sepc为当前pc</li>
<li>将当前mode保存进SPP位</li>
<li>设置scause位trap的原因</li>
<li>设置mode为supervisor</li>
<li>将stvec拷贝到pc中</li>
</ul>
<p>用户在进行syscall、错误行为、设备中断等情况下会出现trap，完整路径是uservec-&gt;usertrap-&gt;usertrapret-&gt;userret</p>
<p>由于RISCV在trap时不提供页表切换，因此需要在用户态也提供handler程序地址的页表，这也是为什么上面地址空间图中用户进程都有trampoline页。trampoline页的PTE_U位是0，即只允许在内核态执行跳板代码，进行寄存器保存、页表更换等。uservec(<code>kernel/trampoline.S</code>)首先将a0保存到sscratch，然后就可以利用a0存放trapframe的值，用于机器指令将31个寄存器保存到进程的trapframe内存处(用户态下在trampoline下面一页)，内核态可以通过进程结构体查看具体trapframe地址。然后再随便用一个寄存器放基址，把sscratch中临时存放的值放到trapframe对应a0的地方去。</p>
<p>usertrap(<code>kernel/trap.c</code>)则对trap做一个初步的处理，首先将stvec的改为kerneltrap的地址，以处理在内核态产生的trap，然后根据scause执行不同的逻辑。</p>
<p>而usertrapret(<code>kernel/trap.c</code>)则是异常处理完毕后的收尾工作，例如将stvec仍改为usertrap等。</p>
<p>最后调用userret(<code>kernel/trampoline.S</code>)，同样可以从内核态刀用户态连贯执行，它更改了<code>satp</code>指向的页表，以及恢复32个寄存器的值，通过sret回到用户态。</p>
<p>内核在执行syscall的时候，读写原来的寄存器通过trapframe操作内存部分就好。</p>
<p>如果内核内存能够在每个进程页表内都有映射，那么也可以不拥有trampoline和trapframe这么复杂的机制，但是那样可能会带来bug和安全问题</p>
<p>kernelvec则将32个寄存器push到栈上，而kerneltrap只需要判断是硬件中断还是异常(不会再有syscall)</p>
<p>有些操作系统使用page fault来实现copy on write，即在fork时将父子的内存页表项都设为只读，子进程使用父进程的页表，当任意一个出现写请求时再进行完整的内存拷贝。再比如也可以用page fault实现lazy allocation，即发生缺页异常时再实际分配。</p>
</blockquote>
<h4 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h4><p>本题要求理解call.c编译出的汇编代码回答问题</p>
<p>Q: Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</p>
<p>A: a0, a1 and a2 contain arguments to functions. In main’s call to printf, a1 holds 13.</p>
<p>Q: Where is the call to function <code>f</code> in the assembly code for main? Where is the call to <code>g</code>? (Hint: the compiler may inline functions.)</p>
<p>A: The compiler computes the return value in advance and take the value as the argument to printf. So the call action is omitted.</p>
<p>Q: At what address is the function <code>printf</code> located?</p>
<p>A: 0x642 in the comment.</p>
<p>Q: What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?</p>
<p>A: 0x38. jalr will store the address of the consequent instruction in the target register ra.</p>
<p>Q: Run the following code. </p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0x00646c72</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"H%x Wo%s"</span><span class="token punctuation">,</span> <span class="token number">57616</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>What is the output? The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p>
<p>A: The output is “He110 world”. if RISC-V is big-endian, variable i would be 0x726c6400 but 57616 need not be changed.</p>
<p>Q: In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?</p>
<pre class="language-none"><code class="language-none">printf(&quot;x&#x3D;%d y&#x3D;%d&quot;, 3);</code></pre>

<p>A: I think it depends on the architecture and the compiler. y may be a random value from the register or from the stack.</p>
<h4 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h4><p>本题要求写一个函数打印调用栈中的所有返回地址。根据<a href="https://pdos.csail.mit.edu/6.1810/2022/lec/l-riscv.txt">lecture notes</a>给出的栈帧可以看出，栈自高地址向低地址增长，sp寄存器指向当前栈顶，fp寄存器指向当前栈底(上一个栈顶)，在fp-8处是返回地址，fp-16处是上一个fp。因此可以通过提供的内联汇编码获取fp，并以迭代的方式读取所有的返回地址。</p>
<p>文档提示内核栈只占一个page，可以通过PGROUNDDOWN查看当前地址在哪一页。所以循环的终止条件可以是<code>PGROUNNDDOWN(fp)==PGROUNDDOWN(pre_fp)</code>。我写的时候是用的<code>fp &lt; PGROUNDUP(fp)</code>，因为最后一个fp肯定等于更高地址页的起始地址。</p>
<h4 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h4><p>本题要求新增系统调用<code>sigalarm</code>和<code>sigreturn</code>。</p>
<p><code>sigalarm</code>要求进程每隔固定时间执行某函数，根据提示在proc结构体中加入interval、handler、tickcount三个成员，执行该系统调用时将interval和handler存入进程结构体中，并将count归零。然后每次硬件中断时监测是否为时钟中断，并在count上+1以及判断是否到达interval。由于handler是用户态的函数，因此需要返回用户态以后执行该函数。trap时返回用户态程序靠的是epc，所以只需要将trapframe中的epc改为handler即可返回到这个函数中(不带参数)。</p>
<p>但是这样会破坏原来的epc以及trapframe等，为了进一步完善alarm，人为规定在handler的最后必须调用sigreturn系统调用完成收尾工作以及恢复alarm前的样子。</p>
<style>.cyfkjgmiprie{zoom:33%;}</style><img src="/Blog/2023/05/03/mit6-828%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="cyfkjgmiprie" alt="示意图">

<p>通过在proc结构体中加入alarmtrapframe用于备份时钟中断时的trapframe，以及使用inalarm在表征此时正处于在handler中以关闭alarm。sigreturn时将alarmtrapframe的内容恢复到trapframe，并且由于syscall返回用户空间时返回值通过trapframe-&gt;a0传递，因此只能return trapframe-&gt;a0才不会破坏原值。</p>
<style>.dnoojvtoghiz{zoom:50%;}</style>

<h3 id="Lab-Copy-on-Write-Fork-for-xv6"><a href="#Lab-Copy-on-Write-Fork-for-xv6" class="headerlink" title="Lab: Copy-on-Write Fork for xv6"></a>Lab: Copy-on-Write Fork for xv6</h3><p>本次lab要求实现copy on write，实现的思路是将uvmcopy的简单拷贝过程给改成使用相同的PTE条目填充子进程的页表。将父子进程的PTE_W都设为0后，其中一方由于写内存而触发page fault后，交由kernel的trap handler处理，分配新的物理页并将原物理页的内容拷贝下来。</p>
<p>由于这种情况下同一时间可能有两个pte指向同一块物理内存，带来的难点就是引用计数的设计，即何时增加引用计数，何时减少引用计数。一开始我觉得应该在mappages中增加引用计数，但是实际上设计cow机制的map只有在uvmcopy中出现，加到mappages中可能会引发其他问题，因此只需要在uvmcopy中增加计数即可。调用kalloc分配的页的引用计数以1为初始值。何时减少引用计数呢？我本来认为应该在unmap处，或者在kfree之前减少引用计数，因为我觉得kernel代码中有其他一些kfree的调用会因为之前没有给他增加引用计数而出错。实际上这些不需要担心，因为initpage是最先进行的。另外copyout也需要增加代码用于对COW的页进行重分配，逻辑与trap大致相同。</p>
<p>在freerange中也需要额外增加一次引用计数，因为在init之前没有东西引用过它们。</p>
<p>关于PTE，新增了一位PTE_C位表明这页是COW的。实际上只需要为原来有PTE_W的页设立这一项，原来就是只能PTE_R的在重复映射下一样不会影响。</p>
<p>代码参考了<a href="https://zhuanlan.zhihu.com/p/594047776">MIT 6.S018 lab cow(Copy-on-write fork) 踩坑指南 - 知乎 (zhihu.com)</a>的部分内容，感谢。</p>
]]></content>
      <categories>
        <category>技术视野</category>
      </categories>
      <tags>
        <tag>Xv6</tag>
        <tag>OS</tag>
        <tag>Mit</tag>
      </tags>
  </entry>
  <entry>
    <title>《毛泽东传（六）》读书笔记</title>
    <url>/Blog/2023/12/10/%E3%80%8A%E6%AF%9B%E6%B3%BD%E4%B8%9C%E4%BC%A0%EF%BC%88%E5%85%AD%EF%BC%89%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>《毛泽东传》主编 逄先知 金冲及 中共中央文献研究室</p>
<h4 id="写在前面的话——兼读后感"><a href="#写在前面的话——兼读后感" class="headerlink" title="写在前面的话——兼读后感"></a>写在前面的话——兼读后感</h4><p>打小我对建国后相当一段历史范围的认知是十分有限且模糊的。中学的历史书上大多细致介绍社会主义建设时期三大改造的历程与成就，而对于60年代到70年代的内容则匆匆略过。当时的我并不知道有公开的文献著作可以查阅学习，于是只能以文学作品的只鳞半爪来管中窥豹，尤其是一些八九十年代的“伤痕文学”。</p>
<p>很小的时候看曹文轩写的《红瓦黑瓦》，写油麻地中学的孩子们参加大串联，在接待站的大锅菜里捞肉片，当时神而往之，觉得学生可以不用花钱到处玩实在是太幸福了……后来看王小波的小说，无论是《黄金时代》还是《革命年代的爱情》，觉得那个年代的青年又是不幸的，他们青春中无处发泄的骚动先是被狂热的社会氛围匆匆点燃，然后又在重复的劳作中慢慢熄灭。杨绛写《我们仨》、流沙河写《锯齿啮痕录》、季羡林写《牛棚杂忆》、巴金写《随想录》……</p>
<p>文学家们的刻画生动而具体，当我阅读这些文字的时候，我仿佛能穿越到那个时空，亲身经历那场席卷社会的政治风暴。暴力、冤屈、谎言……这些细节既让我感到哀恸与悲伤，却又难以让我理解种种行为背后的逻辑。生活在当今时代，我无法理解为什么在半个世纪前是非颠倒、污蔑迫害能成为一种“风尚”。关于毛泽东，他的功过到底该如何评价，是黑暗中带领底层人民获得民主主义革命胜利的领袖，还是支持文革对人民造成大量伤害的第一责任人……我希望能够有自己的认识，能够真正地了解那段历史。恰好我在学校图书馆中借到《毛泽东传》的最后一卷，主要写毛泽东晚年的经历，因此我便选定阅读这本书撰写读书报告。</p>
<p>这篇可以算是读后感，因此关于历史进程中的一些细节这里不再赘述，只谈谈我在阅读过程中的一些思考。</p>
<p>毛时代政治氛围的紧张与彼时的社会情况、国际形势有很大的关系。首先中国刚刚完成民主主义革命，无产阶级成为新中国的主人，通过社会主义三大改造，我国基本建立起社会主义制度和经济格局，但依然一穷二白，社会主义到底该如何发展，并没有一个成功的先例。其次中国面临着相当大的国际压力，世界上的两个超级大国苏联和美国都对中国怀有敌意。苏联领导人赫鲁晓夫全盘否定斯大林，在毛泽东看来走上了修正主义的道路，而美国更是放出“把和平演变的希望寄予第二代、第三代人”这样的阳谋。因此如何保护来之不易的革命成果“不变色”成为领导人要考虑的问题。在这样的历史条件之下，毛更加看重政治建设，尤其在一些贪污腐败以及欺压百姓的现象更加坚定了他要重整党和国家的决心。</p>
<p>政治形势的加重并不是一蹴而就的，而是经历了一个漫长的发展过程。从反右，到社会主义教育运动的两个阶段，再到文化大革命，“敌我矛盾”的打击面是逐步扩大的，同时毛泽东对于党内部分意见的不满也越来越大。在此基础上，以林彪和四人帮为首的投机分子和野心家集团借此机会大肆攻击领导干部，试图通过扰乱社会秩序来攫取不正常的权力，最终酿成了一段让人不愿回忆的惨痛历史。</p>
<p>毛泽东说党内存在“两条路线”，被他认为走“资本主义当权派”路线的刘少奇、邓小平主张用人民的内部矛盾视角来看待毛泽东所认为的敌我矛盾，并且对毛泽东的强硬做法总是采取缓和的措施，这在毛泽东看来是不可接受的。诚然，作为一个刚成立的社会主义国家，到底该如何发展是没有一个合适的先例的。原本作为我们学习对象的苏联已经变成了侵犯我国北方领土剑拔弩张的强敌，我们必须自己探索出一条发展之路。在如今看来，刘少奇和邓小平等人的主张似乎更加值得采取。要谋求民族的复兴和国家的富强，必须要采取高效的发展方式。而这样的发展模式，必然是需要贴合国情、符合社会实际条件的。社会的主要矛盾是什么，这是一个首先要弄清楚的问题，毛泽东认为仍然是阶级矛盾。而实际上，经过多年的革命战争历程，人民迫切需要的是休养生息、逐步改善生活。于是我们看到，以阶级斗争为纲并没有像毛泽东所设想的那样改善工厂、农民的生产力，不仅阻遏了五六十年代早期市场经济的萌芽，而且在社会的物质上和人民的精神上都造成了巨大的破坏。</p>
<p>马克思主义中国化是个很有趣的命题，马克思揭示了资本主导下世界运行的规律，但由于缺乏实践的参照以及历史条件的限制，在很多现实的复杂问题上，马克思主义的基本理论无法给予充分的方法论的指导。因此结合当下的国情理解并运用马克思主义是非常重要的。六七十年代，正是由于对国情认识不清，毛泽东才错误地发动了一系列政治运动。当今的世界局势瞬息万变，国际形势剑拔弩张，国内矛盾重重交织，习近平新时代中国特色社会主义理论体系作为马克思主义中国化的最新成果，在许多我们关心的问题上都做出了指引。作为生活在这个国家的一份子，适当的学习和思考这个总览全局的理论体系有助于我们重新审视我们所处的社会，跳脱出狭隘的视角，从更高的角度思考问题。</p>
<p>我在一些影视作品和许多展览馆中对毛泽东早年的经历略有了解，而这本书则为我补上了毛泽东的晚年这块缺失的拼图。即便现在让我对毛泽东的功过进行评定，我还是会感到为难。历史就是历史，只会存在于文字和文字带来的想象中，无论是功，还是过，毛泽东都已经确确实实地归入岁月的长河。忧乐胸怀心系社稷的是他，诗人本色挥斥方遒的是他，谋略巧思决胜千里的是他，固执我见的是他，昏聩不明的也是他……无论如何都不能否认，他是一个伟人，为中华民族做出了突出贡献的伟人。即便在他在晚年由于错误的认知人为导致了全社会范围内的灾难，我们也不能否认，如今一切的美好生活都源他和以他为代表的许许多多革命先辈们。没有毛泽东在革命早期的力挽狂澜救全党于危难，以及在抗日战争时期的正确理论指引和建国后打下的工业基础，都不可能发展为如今的中国。</p>
<p>自信人生二百年，会当水击三千里。希望未来的中国越来越好，也希望更多人能够全面的了解党的历史，了解毛泽东的一生，以史为鉴，共建今朝。</p>
<h4 id="社会主义教育运动（上）"><a href="#社会主义教育运动（上）" class="headerlink" title="社会主义教育运动（上）"></a>社会主义教育运动（上）</h4><p>毛泽东所关心的是农村的社会主义教育，他希望社会底层不要出现修正主义等现象，但他其实并没有形成一套具体的方案。毛泽东对于社会主义的理解，经济上在于按劳分配和价值法则，政治上则在于阶级斗争。</p>
<ul>
<li><p>四清：清账目、清仓库、清财物、清工分</p>
</li>
<li><p>五反：反贪污盗窃、反投机倒把、反铺张浪费、反分散主义、反官僚主义</p>
</li>
<li><p>二十条：关于目前农村工作中若干问题的决定（草案）、关于农村社会主义教育运动中一些具体政策的规定（草案）</p>
</li>
</ul>
<p>政治是一种艺术，说一点我自己不成熟的看法吧，我觉得作为一个人来说，在处理问题的时候难免会陷入某种路径依赖。中国共产党通过自下而上的革命，获得了政权，成立了新中国。革命是纯洁的、彻底的、暴力的。所以早期领导人面对国家发展期所遇到的种种“不社会主义”的问题，也总会想着要相对彻底地解决，而不惜用暴力、彻底的方法保持纯洁性呢？</p>
<p>毛认为政治斗争和生产可以一起搞，政治斗争的结果会使得生产效率更高。他把干部参加生产劳动看作是一件具有“伟大革命意义”的“极端重大的问题”。所谓“又红又专”就是如此，干部在懂政治的同时也要深入生产的一线，与人民群众打成一片，成为受群众拥护的好干部。他的理想是很好的，只是他对于阶级形势过分估计，过于强调阶级斗争了。毛自己也怕搞乱，强调不要性急。然而在“以阶级斗争为纲”的指导下，农村社教运动中仍然普遍发生了混淆两类矛盾、打击面过宽的问题。在社教运动的过程中，毛开始逐渐注意到文化领域，他认为文化领域目前仍然是“旧”的那一套，需要对上层建筑加以整改。同时由于石油部的成功经验，毛向全国推广了学解放军的做法，在机关、生产部门广泛设立政治部。</p>
<p>毛泽东说：“如果我们和我们的后代不能时刻提高警惕，不能逐步提高人民群众的觉悟，社会主义教育工作做得不深不透，各级领导权不是掌握在真正的马克思主义者手里，而被修正主义者所篡夺，则我国可能要走一段资本主义复辟的道路。”</p>
<p>毛对生产是很重视的，他希望在社教的过程中保持正常的生产活动，保持农业生产和农业政策的稳定。所以我们可以看到，毛的本意是既要发展意识，又要发展物质。物质和意识不可以只侧重于一个方面，只追求物质而忽视社会意识的建设会造成修正主义的出现以及对社会主义的破坏。而只追求在意识领域的工作则有可能扰乱正常的生产生活秩序，从而造成生产力的倒退。中央的出发点是好的，但是在实际执行的过程中受到了曲解和扩大化。</p>
<h4 id="社会主义教育运动（下）"><a href="#社会主义教育运动（下）" class="headerlink" title="社会主义教育运动（下）"></a>社会主义教育运动（下）</h4><p>毛泽东很重视修正主义的问题，他认识到修正主义的出现是不以人的意志为转移的，“不干净才合理嘛，不然就没有矛盾了嘛。对立统一，是两个侧面的统一。”新中国之后出现了一些贪污腐败等等修正主义现象，从当时的政治意义上来说，这些都是“敌人”掌握政权的例子。刘少奇说：“在很多地方，他们是利用我们的口号，利用我们的政策，利用共产党员的招牌，利用我们干部的面貌来篡夺领导权，或者把持领导权。……而上面的根子危害性更大。”</p>
<p>十九届六中全会通过的《决议》中写到：“勇于自我革命是中国共产党区别于其他政党的显著标志。自我革命精神是党永葆青春活力的强大支撑。”为什么要坚持自我革命？就像毛泽东说的，矛盾是对立统一的，作为一个成员众多党派，出现违背党的基本理念的现象客观上来说是一定会发生、不以人的意志为转移的。因此我们时时刻刻都要注意自我革命，努力从中央到地方都能够最大程度地贯彻党的宗旨和使命。</p>
<p>刘少奇对后十条做了修正，认为只依靠基层组织和基层群众难以彻底解决问题，应该从省委等部门下派工作队到地方上打“歼灭战”。此后农村社教运动出现了新的组织形式，即有省委、地方、县的数千干部组成强大的工作团，集中包揽县的领导权组织运动。</p>
<p>关于经济建设，毛泽东关注国家的工业发展，他设想用十五年建立一个独立的完整的工业体系，再用十五年建设使国家接近世界先进水平。我想那时的领导人深切认识到当时我国国力与西方国家的巨大差距，用居安思危的方式思考国家未来的建设和发展方向。事实也证明，我国现在所取得的生产力的巨大成就，与自身拥有一套完整的工业体系是密不可分的。</p>
<p>毛在关于“三五”计划的讲话中认为“欲速则不达”，不能把建设的目标搞得太大。“第一是老百姓，不能丧失民心；第二是打仗；第三是灾荒。”后来周恩来将其总结为“备战、备荒、为人民”，成为六七十年代国民经济计划的指导方针。</p>
<p>社教运动的第二阶段是四清的重新明确，即：清政治、清经济、清思想、清组织。原先的四清主要在经济方面，而新四清则将矛头对准政治和“当权派”。随着毛泽东的理念与刘少奇的理念发生越来越多的分歧，社教运动该如何开展也逐渐成为二人的矛盾点。</p>
<p>社教运动的主要矛盾是什么呢？刘认为是“四清”与“四不清”的矛盾，并且有敌我矛盾和内部矛盾的交叉，这是复杂的，而毛却认为这是“社会主义与资本主义的矛盾”。可以看出，刘并不希望社教运动搞得太过于激烈，但毛却认为必须要从根本上解决地方以及中央所出现的修正主义问题，保持社会主义的纯洁性。由此也可以想象，在七千人大会之后，直到社教运动的开展，毛与刘的矛盾是如何一步步加深的，以及向“当权派”攻击的观点是如何为后续文革做思想上的转变的。</p>
<h4 id="发动“文化大革命”"><a href="#发动“文化大革命”" class="headerlink" title="发动“文化大革命”"></a>发动“文化大革命”</h4><p>昨天看了社教运动的下半章节以后，实在是有些迷茫。</p>
<p>当今时代，先辈们用生命的代价所革除的腐朽事物仿佛悄无生息地又回来了，从公职人员的腐败到资本家的剥削，实在是令人生气和失望。自改革开放以来，我国在经济建设方面取得了举世瞩目的成就，多年保持中高速增长的同时，国民生产总值跃居世界第二。但同时我们也发现，“先富起来的人”逐渐成为社会主要经济活动的掌控者，总体贫富差距越来越大。加之早期监管体系尚未完善，底层工人组织力松散，难以形成合力，“阶级斗争”一词仿佛已从社会意识中消失。马克思说“到目前为止的一切社会的历史，都是阶级斗争的历史”，现今的我们，到底该怎么做呢？</p>
<p>我想，阶级斗争该提，无论如何都应该讲究“实事求是”，万不可以盲目扩大。我们应该意识到，我国的生产力还未到马克思所提到的发达阶段，并不具有实现共产主义的经济基础。同时外部错综复杂的国际形势也决定了当前我国不能“乱”，否则很容易被乘虚而入从内部瓦解。历史也表明，在此种发展不充分的情况下，不科学的平均主义会导致生产力的停滞甚至倒退。资本只有在资本家的手中才能够最快地增殖，也才能够更快地提高我国的总体发展水平。但发展讲究科学的发展，所以完善分配制度以及监管手段才显得尤为重要。社会范围内大规模的斗争显然是不可取的，但在小的领域，比如公司或者其他存在阶级矛盾的地方，毛泽东思想给我们该如何进行阶级斗争争取权益提供了很好的思路。要勇于与剥削阶级斗争，讲究斗争的方法与策略，尽可能地团结可以团结的人，抓住事物的主要矛盾，用最小的代价获得最大的成果。</p>
<p>社教的后期，毛泽东对于社教的具体措施提得越来越少，他开始更多考虑党、尤其是党中央的修正主义问题。“造反”一词出现的频率更高。随着事态的逐渐发展，对于毛泽东的个人崇拜也越发严重。</p>
<p>“大字报”在毛泽东看来是一种有效的“群众战斗形式”，可以打乱原有的秩序，使群众的手脚放开，形成一个有效的突破口。从北大的大字报开始，到席卷全国各级党委和机关的“造反”，毛在其中起到了相当的支持作用。他认为“天下大乱”是到达“天下大治”的必由之路，反对中国的修正主义、建立新的社会秩序是最亟需解决的问题，为此一段时间内社会的紊乱是可以接受的代价。原本为了控制混乱程度由刘少奇、邓小平派出的工作组也由于在毛泽东看来对斗争起“阻碍作用”，使北大、清华等高校的运动冷冷清清而被裁撤。</p>
<p>从1966年8月1日开始的中共八届十一中全会正式通过了关于无产阶级文化大革命的决定。《决定》中写道：“在当前，我们的目的是斗垮走资本主义道路的当权派，批判资产阶级的反动学术权威，批判资产阶级和一切剥削阶级的意识形态，改革教育，改革文艺，改革一切不适应社会主义经济基础的上层建筑，以利于巩固和发展社会主义制度。”8月7日，毛泽东写下《炮打司令部——我的第一张大字报》，字里行间直指原接班人刘少奇“实行资产阶级专政”，而后与毛泽东政治主张相近的林彪逐渐成为毛心中的接班人。八届十一中全会的决议意味着全国范围内的文化大革命已经是箭在弦上不得不发，十年浩劫就此拉开帷幕。</p>
<p>如今再看这段历史，我们应该反思，当时党内高层为什么没有能够阻止文化大革命的发生？</p>
<p>首先我觉得，文革的发动并不只是毛一人的过错，决议的通过需要大多数人的同意，明确反对决议的人一定不占多数。所谓“紧张的政治氛围”从来都不可能是少数人能够造就的，而是多数人对于政治斗争工作的重视。毛泽东作为党和国家的领导人对当时国内主要矛盾的错误判断，加之相当程度的个人崇拜，造成了党内的盲目左倾，这种左倾的势头经过社教、反右运动等等的发展，逐步发展和壮大，量变的积累最终导致了质变的发生。于是更加剧烈而全面的文化大革命发生了，这是党和国家历史进程中的悲剧。</p>
<p>其次，我们也不能忽视当时我国所处的外部国际环境，帝国主义长期敌视、封锁我国，使我国面临相当的外部压力。苏联的形象从社会主义老大哥转为“修正主义”，这是被毛泽东等人看在眼里的实实在在的资本主义复辟的信号。同时杜勒斯也针对社会主义国家的和平演变说“要把希望寄托在第三、第四代上”。毛泽东不希望中国的革命成果被窃取，社会主义政权被颠覆。“修正主义”成为一个有例在先、活生生的威胁，并且这个威胁在毛泽东看来通过程度轻微的的社教运动等，无法在全国范围内被根除，最终导致了误判和工作重心的转变。</p>
<p>写这部分内容的时候，经过思考和检索，我对过去一些观念里似是而非的名词有了重新的认识，修正主义、社会主义的本质、无产阶级专政、人民民主专政、中国特色社会主义等等。</p>
<h4 id="支持“红卫兵”运动"><a href="#支持“红卫兵”运动" class="headerlink" title="支持“红卫兵”运动"></a>支持“红卫兵”运动</h4><p>毛泽东把这项急迫政治运动的希望寄托在青年人身上，一方面青年人身上有打破旧势力的闯劲，另一方面他认为在青年人身上做好政治工作能够防止美国等资本主义国家的“和平演变”。</p>
<p>但是红卫兵中的大多数人都处于一种政治狂热之中，缺少法律观念。部分人在“革命造反”的旗号下做出了很多荒唐的举动，造成了严重的后果。由于“不许动用部队和警察镇压革命学生运动”被毛泽东批准，社会上已然没有一个机构能够遏制陷入狂热中的红卫兵们。毛认为“放任自流”的后果是可以接受的，但是他没有想到，社会上原有的错综复杂的矛盾在种种漂亮的口号下集中地爆发出来，大大小小的野心分子乘此活跃，为所欲为。而随之发展的“大串联”使得北京高校的文革运动辐射到了全国。串联的交通食宿都由政府开支，外地大小高校的师生来到北京受到毛泽东的接见。由此，全国上下对毛的个人崇拜达到一个顶峰，各地党政机关纷纷被围攻，陷入瘫痪和半瘫痪，社会秩序处于失控边缘。</p>
<p>“安亭事件”则使得文化大革命从学生过渡到工人阶级，王洪文在串联筹建的上海工人革命造反总司令部不被中共上海市委承认，被认为是“压制革命造反”，他组织两千多工人赴京请愿，在安亭被铁路局拦下，因此煽动工人卧轨拦车。张春桥被派往上海后，不顾中央确定的原则，擅自发表支持工总司的言论。这一做法得到了毛泽东的支持，他发觉学生运动已有走向低落的征兆，希望通过革命来促进工人的生产。实际上，毛泽东的主观想法并没有和客观的实际情况相统一，文革进入生产一线的结果只是更大规模的混乱，造成了严重的干扰和破坏。</p>
<h4 id="在“全面夺权”的日子里"><a href="#在“全面夺权”的日子里" class="headerlink" title="在“全面夺权”的日子里"></a>在“全面夺权”的日子里</h4><p>1967年1月，文革的进一步发展以产业工人为主体，在城市的大小生产部门席卷起更加剧烈的“夺权”风暴。宣传方面对于上海文革运动的公开支持进一步促使全国其他省市的效仿，山西山东黑龙江……诸多地区实现了造反派的“夺权”。虽然毛泽东意识到一部分造反派已经形成了“无政府主义”的思想，但是这对于文革的巨大浪潮来说无济于事。各地造反派早夺权中很快形成山头林立的局面，排斥其他组织，相互争权抢权，同时党政军各级部门的领导干部遭到任意批斗与迫害，社会局势几近失去控制。</p>
<p>为了保证军队以及银行等社会重要机关的稳定，对于处于混乱状态的地区，中央实行军事管制，由军队接管重要部门。毛泽东批示同意了不准把斗争锋芒指向军队的通知，他在矛盾的心情下，希望军队既能够保持稳定，又能够坚决地支持夺权的“左派”。然而在派系林立的地方上，各个派系都宣称自己是左派，军队难以确定该支持哪一派。同时，部分地区军队仍然受到相当的冲击，造反派组织抢武器库，造成了大规模的武斗和伤亡。</p>
<p>同时，中央文革小组以及四人帮对于各地文革组织的煽动也造成了相当恶劣的后果，例如林彪借军队内革命的由头铲除异己力量、王力等人支持造反派采取极端行动，江青提出的“文攻武卫”造成各地大规模的武斗等，虽然毛泽东通过了一些规定以阻止事态的恶化，然而起到的实际作用却不大。</p>
<p>在着手筹备九大和整党工作的时候，毛泽东认为需要对“文化大革命”从理论上加以总结，这个理论被称为“无产阶级专政下继续革命的理论”，其中的主要论点既不符合马克思列宁主义，也不符合中国的实际国情，而是建立在对国内阶级形势以及党和国家政治状况的错误估计基础上的。</p>
<p>从这段历史可以看出，人与人之间的关系是松散而脆弱的，要维护当下的社会秩序，就需要有一个强有力的机构。文革中军队、警察因为中央错误的指示，没有能正确履行职责，使得偏离正确方向的社会得不到适时的纠正。如果人人都能“夺权”，所有的评判完全出于主观而不依照客观的法律，那么社会将回到混乱无序的状态。在这种状态下，冲突与压迫将无法避免。我们要建设法治的国家而非人治的国家，只有依托法律才能够维护相对公正的社会秩序，才能一定程度上保护客观上弱势的群体。</p>
<h4 id="八届十二中全会到九大"><a href="#八届十二中全会到九大" class="headerlink" title="八届十二中全会到九大"></a>八届十二中全会到九大</h4><p>1967年后，局势稍稳，但是武斗仍在继续。毛泽东没有认识到这是文革在错误理论指导和错误部署下的必然结果，而是仍然从“以阶级斗争为纲”的思路中出发，认为这些不好的现象是由于背后有阶级敌人在操纵。在毛泽东新的认识中，他更加强调文化大革命是和国民党反动派、资产阶级长期斗争的继续，因此造成了斗争社会面的再次扩大——被怀疑有历史问题的人也要被清查，全国席卷起“清理阶级队伍”的运动。虽然毛泽东多次强调不要扩大打击面，严禁逼供，给人出路，但是社会上仍然出现了大量的违背政策、逼供信、造成冤假错案的现象。</p>
<p>八届十二中全会在中央层面把造成巨大灾难的文化大革命全面肯定，同时通过了关于刘少奇的审查报告，审查的材料中充斥着大量的伪证和不实信息，但对此一无所知的刘少奇根本没有申辩的权利。第二年十一月，刘少奇在河南开封囚禁处含冤而死。</p>
<p>全会结束后，毛泽东着手的第一件事就是整党，他提出党组织要“吐故纳新”，恢复组织生活，但总的指导思想依然是“以阶级斗争为纲”。同时，由于文革已经进行了两年有余，毛泽东提出要缩小打击面，同时对“二月逆流”中受批判的干部也释放了善意。但是由于当时的总体认识仍然处于“文化大革命是完全有必要、是非常及时的”，因此相当一部分受到错误审查和处理的干部和知识分子仍没有得到解放，问题并没有从根本上得到解决。</p>
<p>中共九大的召开加强了林彪、江青、康生等人在党中央的地位，同时林彪和江青两个集团的矛盾和争夺也逐步加剧。毛泽东所设想的团结和胜利并没有如期到来。</p>
<h4 id="林彪事件"><a href="#林彪事件" class="headerlink" title="林彪事件"></a>林彪事件</h4><p>九大后，国内局势一度趋于缓和，各地党组织陆续恢复，大规模武斗明显减少，工农业产量逐步回归。“中央文革小组”的取消则相对削弱了江青集团的权力，而林彪集团能够直接控制军权，在“三支两军”的实行下获得了更多的权势，在九大前后达到了顶峰。</p>
<p>面对苏联在边境的挑衅，毛泽东保持了不向任何外来压力低头的风范，他强调如果美帝国主义、社会帝国主义如果硬是要把侵略战争强加在我们头上，我们就坚决抵抗到底，直至最后胜利。</p>
<p>林彪的在一些事情上采取的做法越来越让毛泽东察觉到其攫取更大权力的野心。在庐山会议上，毛泽东对于“天才”的称呼以及设国家主席的想法均表达出强烈的不满，追究了相关人员的责任。这些方面对与林彪的设想出入很大，林彪对于毛泽东的不满越发加剧。由林立果等人策划的政变计划“五一七”工程在实际实施时由于毛泽东的察觉而没有能成功执行，为此林彪等人只能仓皇出逃。飞机在蒙古上方由于机组人员不齐整、油料不足等原因迫降坠毁。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>中国Rust开发者大会参会记录</title>
    <url>/Blog/2024/09/07/%E4%B8%AD%E5%9B%BDRust%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%E5%8F%82%E4%BC%9A%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>Amazon：Rust and 生成式AI应用</p>
<p>PyO3，Rust&#x2F;Py binding，还有其他一些开源工具例如diffuser-rs等</p>
<p>AWS为Rust开发者提供SDK服务，同时还有生成式AI产品Amazon Q</p>
<p>非凸科技：首席架构师乔丹，Rust程序的不同链接方式在交易系统中的典型应用</p>
<p>投研团队都写Rust，策略&#x2F;工程，但是strategy和facade(前端)依然要两个团队分别维护</p>
<ul>
<li>第一种方式：crate-type&#x3D;lib，用workspace捏在一个大项目里，dependency指定A依赖B<ul>
<li>代码有泄露风险</li>
</ul>
</li>
<li>第二种方式：crate-type&#x3D;cdylib，用extern C来指定需要分发出去的代码<ul>
<li>C风格函数无法接受Rust独有类型，FFI</li>
</ul>
</li>
<li>第三种方式：crate-type&#x3D;<strong>rlib</strong>，保留Rust语言特性，性能无损，无FFI<ul>
<li>不再开放代码权限，静态链接</li>
<li>但是<strong>ABI</strong>稳定性在长期开发中可能会成为问题，毕竟Rust的工具链一直在更新——不过可以约定公司使用的版本</li>
</ul>
</li>
</ul>
<p>字节跳动：吴迪，Rust服务端开发</p>
<p>Rust与降本增效——性能高的同时，Review代码的时候极大地减少心智负担，只需要关心业务逻辑</p>
<p>将GO迁移到Rust后，可用性增加，CPU使用率下降，性能提升约50%</p>
<p>要敢于造轮子，社区很多库有的时候没那么完善</p>
<p>Rust可能未来会作为计算基座</p>
<p>JetBrain：交互式debugRust代码</p>
<p>绝大多数人都哦再用println!或者dbg!调试</p>
<p>交互式debug：breakpoint， stepbystep</p>
<p>Sonala：华语区大使李学斌</p>
<p>Bitcoin: proof of work, Ethereum: smart contract (proof of stack), Solana: proof of history</p>
<p>EVM: 以太坊虚拟机，全局竞价，单线执行</p>
<p>SVM：Solana虚拟机，不同的竞价(NTF, DEX等类型)并行在对应队列中单线执行</p>
<p>Sonala的基础交易费非常低，导致会有为了争先交易而产生的泛洪请求。为了保证网络质量采用quic</p>
<p>Vara Network</p>
<p>采用WASM而不是EVM做智能合约，并行采用Actor消息模型</p>
<p>Async维测&amp;定位的探索和思考</p>
<p>Rust，无栈协程，Future用工作线程的栈，没有独立栈空间</p>
<p>协程状态机与函数体里的await位置有关，从而可以记录从pending转而重新执行函数时从哪里恢复</p>
<p>Rust HashMap 比看起来更复杂</p>
<p>场景：开发时序数据库HoraeDB，为了高效并发做了分段HashMap，Rwlock</p>
<ul>
<li>用Vec Buffer提高局部性，减少tlb&#x2F;cache miss<ul>
<li>demo: <a href="https://github.com/Rachelint/sharded-hashmap">Rachelint&#x2F;sharded-hashmap</a></li>
</ul>
</li>
<li>实际分配的内存比with_capacity指定的多<ul>
<li>先乘 8&#x2F;7，然后对齐到2^n，这么多个buckets对应的kv空间</li>
<li>同时hashmap对内存的随机访问可能会分散在不同的页上</li>
</ul>
</li>
<li>capacity需要微调合理，否则会内存爆炸</li>
<li>尽量不要放太大的东西</li>
</ul>
<p>Rust和C++互操作及交叉编译 朱树磊 浙江大华</p>
<p>动机</p>
<ul>
<li><p>公司legacy code比较多</p>
</li>
<li><p>使用大型C&#x2F;C++库和中间件</p>
</li>
<li><p>希望使用C++的特性</p>
</li>
<li><p>HPC的CUDA等类C++语言Rust也无法直接调用</p>
</li>
</ul>
<p>跨语言互操作工具包括FFI，bindgen，cbindgen，cpp!</p>
<p>cxx：安全的C++和Rust互操作工具</p>
]]></content>
      <categories>
        <category>技术视野</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>冬天的故事</title>
    <url>/Blog/2024/12/22/%E5%86%AC%E5%A4%A9%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<p>好像真的坠入爱河了。</p>
<p>再次想起这个表情包：</p>
<img src="/Blog/2024/12/22/%E5%86%AC%E5%A4%A9%E7%9A%84%E6%95%85%E4%BA%8B/%E5%9D%A0%E5%85%A5%E7%88%B1%E6%B2%B3.png" class="">

<p>情难自已，丧失理性。</p>
<p>不过我很开心。</p>
<p>附上前两天随便写的东西</p>
<blockquote>
<p>又开始胡思乱想了。</p>
<p>今天csl在群里说：“老崔追人，给人一种很矛盾的感觉，一方面又想从朋友发展不想直接集中炮火追人，一方面又没朋友相处那么自然带点拘束”。我一想好像还真是这样。但是难道把自己的内心交给另一个人不是一件重要并且严肃的事情吗？当自己没有足够的情感的时候，又怎么可以违背本心做出言过于实这样的事情呢。感情在细微处生长，在宏大处汇合。可能我觉得从一个个细碎的交流与琐事所培养的情感更加真切吧。</p>
<p>看到这句话的时候就想起在网上还算有名的一句话“爱是想触碰却又缩回手”。原文是“Love is a touch yet not a touch”. 前半句很好理解，我们的爱欲总是驱使我们去靠近，去碰撞，尝试擦出火花，但后半句理解各不相同。可以理解为约束，可以理解为尊重，可以理解为自卑……</p>
<p>有胡思乱想总是好的，心里会被思绪还有挂念填满。所以我感激并且珍惜。</p>
<p>风将思念吹散，埋进心的角落，故事悄悄发芽，是个关于爱的梦。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂谈点滴</category>
      </categories>
  </entry>
  <entry>
    <title>加息、降息与硅谷银行破产</title>
    <url>/Blog/2023/03/13/%E5%8A%A0%E6%81%AF%E3%80%81%E9%99%8D%E6%81%AF%E4%B8%8E%E7%A1%85%E8%B0%B7%E9%93%B6%E8%A1%8C%E7%A0%B4%E4%BA%A7/</url>
    <content><![CDATA[<p>我们经常会听到这样的说词：美国在世界范围内拥有货币霸权，通过美联储周期性的加息和降息来收割全世界。但是相信很多人对其中的含义和实现细节依然不是很清楚，这篇博客就几个概念和问题做一个解释。</p>
<h4 id="加息、降息，调整的是什么？"><a href="#加息、降息，调整的是什么？" class="headerlink" title="加息、降息，调整的是什么？"></a>加息、降息，调整的是什么？</h4><p>加息和降息的“息”指的是其<strong>会员银行间拆借的利率</strong>，即<strong>联邦基金利率</strong>。这个利率是受市场调控的，因此会上下波动，但美联储可以通过一定的手段来调控联邦基金利率。</p>
<p>当联邦基金利率升高时，商业银行间拆借的利率会升高，银行资金成本变高，从而导致存款利率的升高等一系列后续影响。</p>
<h4 id="怎么实现加息、降息？"><a href="#怎么实现加息、降息？" class="headerlink" title="怎么实现加息、降息？"></a>怎么实现加息、降息？</h4><p>我们一般称<strong>中央银行</strong>为银行的银行，这是因为中央银行具有发行货币、调整商业银行的存款准备金率等等职能。依靠这些职能，中央银行能够调控宏观上的货币量，并以此调控经济。美国联邦储备系统，简称为<strong>美联储</strong>，负责履行美国的中央银行的职责。</p>
<ul>
<li>存款准本金率：<strong>商业银行</strong>为了保证能够让客户提取存款和结清账目存放在<strong>中央银行</strong>的钱占商业银行存款的<strong>最低</strong>比重。当存款准备金率比较低的时候，商业银行可以有更多的钱用于放贷等投资，使得流通的货币更多。</li>
</ul>
<h5 id="稀缺准备金体系：公开市场业务"><a href="#稀缺准备金体系：公开市场业务" class="headerlink" title="稀缺准备金体系：公开市场业务"></a>稀缺准备金体系：公开市场业务</h5><p>过去美联储放水不多的情况下，各商业银行的准备金较少。美联储大多采用公开市场的方式，通过买入或卖出有价证券来实现调控市场中的流动性。这里的有价证券一般就是<strong>美国国债</strong>，美联储在公开市场发行更多的美国国债，流通的货币量减少，利率就会上升。反之美联储回购更多的国债，流动的货币量增多，利率就会下降。</p>
<h5 id="金融危机后的利率走廊：-准备金余额利率-贴现率"><a href="#金融危机后的利率走廊：-准备金余额利率-贴现率" class="headerlink" title="金融危机后的利率走廊：[准备金余额利率, 贴现率]"></a>金融危机后的利率走廊：[准备金余额利率, 贴现率]</h5><p>由于2008年金融危机后美联储大量进行量化宽松，各银行拥有充分的准备金，面对公开市场导致的货币量减少依然游刃有余。因此公开市场方法很难实现美联储的目标利率。</p>
<p>联邦基金利率走廊的上下限是<strong>贴现率</strong>和<strong>准备金余额利率</strong>，这两个受美联储控制。</p>
<ul>
<li>贴现率：商业银行向美联储借钱的利率。</li>
<li>准备金余额利率：商业银行在美联储存放准备金部分的利率。</li>
</ul>
<p>这里的逻辑很容易厘清：只有向同行借钱的利率<strong>低于</strong>向美联储借钱的利率，商业银行才会乐意向同行借钱（上界）；只有利率<strong>高于</strong>把钱存在美联储那里，商业银行才会乐意把钱借给同行（下界）。</p>
<h5 id="多轮量化宽松后的利率走廊：-隔夜逆回购利率，准备金余额利率"><a href="#多轮量化宽松后的利率走廊：-隔夜逆回购利率，准备金余额利率" class="headerlink" title="多轮量化宽松后的利率走廊：[隔夜逆回购利率，准备金余额利率]"></a>多轮量化宽松后的利率走廊：[隔夜逆回购利率，准备金余额利率]</h5><p>多轮量化宽松以后，市面上的<strong>非银行金融机构</strong>获得大量流动性，但却无法把钱存入美联储赚准备金的利息。因此他们倾向于以<strong>低利息</strong>贷给商业银行，商业银行则将钱存入美联储吃准备金利息的差价。</p>
<p>为了控制利率，美联储将利率走廊的上下限调整为<strong>隔夜逆回购利率</strong>和<strong>准备金余额利率</strong>。</p>
<ul>
<li>隔夜逆回购利率：<strong>放宽</strong>接受“存款”对象的范围，被授权的对象都可以通过被美联储隔夜逆回购的方式从美联储赚取利息。</li>
</ul>
<p>同样厘清一下逻辑：只有向同行借钱的利率<strong>低于</strong>向非银行金融机构借钱的利率，商业银行才愿意找同行借钱，而非银行金融机构只会向商业银行开出比存款准备金利率更低的利率（上界）；只有向商业银行借钱的利率<strong>高于</strong>隔夜逆回购利率，非银行金融机构才会乐意把钱借给商业银行（下界）。</p>
<h4 id="加息、降息与美元潮汐"><a href="#加息、降息与美元潮汐" class="headerlink" title="加息、降息与美元潮汐"></a>加息、降息与美元潮汐</h4><p>这部分相对就比较好理解了，当美联储降息时，存款和贷款利率下降，美国市场流动性增加，一部分资金就会离开美国去往世界上其他国家进行投资。当美联储加息时，存款和贷款利率增加，无论是还款的需要还是存款的需要都会驱使资金回流银行，继而回流到美联储。</p>
<p>在降息周期，美元投资流入各国市场，带动各国民众跟投，拉高各国实物资产价格。在加息周期，美元回流美国，导致各国投资下降，实物资产价格下跌，便于下一次美元降息时抄底。</p>
<h4 id="硅谷银行是如何破产的？"><a href="#硅谷银行是如何破产的？" class="headerlink" title="硅谷银行是如何破产的？"></a>硅谷银行是如何破产的？</h4><p>这里简要列一下导致雪崩的一片片雪花：</p>
<ul>
<li><p>2020年美联储降息，存款利率下降，硅谷银行的资金成本变得极低，可以进行投资</p>
</li>
<li><p>银行<strong>大量</strong>购买当时<strong>低利率</strong>的无风险国债作为投资，但很多是到期债券，不到时间收不回钱</p>
<blockquote>
<p>注意，按照上文的理论，降息时国债价格是会变高的。因为此时美联储会大量回购国债，释放流动性，国债供不应求，价格上涨。但债券价格和票面利率无关，这里说的是票面利率。</p>
</blockquote>
</li>
<li><p>存款准备金率低，银行抗风险能力很差，保险只能赔付每个客户不超过25万美元。</p>
</li>
<li><p>2022年美联储加息，存款利率上升，同时国债价格下降。硅谷银行的<strong>资金成本变高</strong>，之前的大量购买的低利率国债成为未实现亏损。</p>
</li>
<li><p>硅谷银行的客户主要是创业孵化公司、科技公司等，随着科技业寒冬的到来，这些公司开始取钱。</p>
</li>
<li><p>由于流动性不足，硅谷银行只能提前抛售到期国债，形成实际亏损。</p>
</li>
<li><p>亏损引发市场恐慌，进而造成挤兑，使得硅谷银行最终丧失偿付能力而破产。</p>
</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://zhuanlan.zhihu.com/p/51694345">美联储加息，加的到底是什么息？ - 知乎 (zhihu.com)</a></p>
<p><a href="https://xueqiu.com/4894511814/219096500">美联储的加息、缩表，是如何操作的？- 雪球 (xueqiu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/527815863">美联储加息，到底是如何操作的？ - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.zhihu.com/question/348184222">美国是如何“收割”全球财富的，有人能说得明白点吗？ - 知乎 (zhihu.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s/Ti1xuDewljtbrini17oHJw">刘润：硅谷银行48小时闪崩，你需要知道的10件事 (qq.com)</a></p>
]]></content>
      <categories>
        <category>杂谈点滴</category>
      </categories>
      <tags>
        <tag>Economy</tag>
      </tags>
  </entry>
  <entry>
    <title>关西游记</title>
    <url>/Blog/2024/04/18/%E5%85%B3%E8%A5%BF%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>计划了许久的第二次关西行终于提上了日程，两次赴日，心境却不尽相同，这次算是偷偷跑出来玩，心里还是没法完全放下本职工作等等负担。whatever，就在这里记录一下每天吧，不记下来的花就会和上次赴日一样，只剩下零碎的记忆了。</p>
<h4 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h4><p>通天阁前的商业街看起来还不错，但是说实话天王寺周边环境确实一言难尽。路面不是很干净，而且确实也有一些流浪汉。在动物园前站门口的自动售货机买了一瓶水，一大爷突然出现，然后非常热情地叽里咕噜说了一堆。我赶紧说I dont understand japanese. 中国人です. 然后他露出恍然大悟的表情，又拍着我的肩膀一直说頑張って，我做出要走的样子，他一个劲地说残念，我也只能はいはい、残念残念……</p>
<p>期待了很久的逛玉出超市，但是去了以后完全没有购买的念头……虽然看起来生鲜熟食确实不贵，但是感觉不是很新鲜的样子……</p>
<p>晚上步行去了道顿堀和心斋桥，在那里吃了たこ焼き，即便丸子已经装在盒子里了，被酱粘在丸子上的章鱼碎屑也因为滚烫的气流不停地颤动摇摆，就像真的章鱼足一样，初看还是有些掉san的。晚饭吃了天ぷら丼，价格很便宜，味道还不错，大虾的口感很好，不过还是感觉之前在富士山那边吃的要好吃一点。心斋桥的人很多，让我想起苏州的平江路，不过苏州古风浓一点，道顿堀这边这是市区街景味很足。桥上贴了很多不要跳下去的标识，这么浑的水居然也跳得下去……让我想起天津的跳水大爷。</p>
<h4 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h4><p>今天一早坐上了黑潮号特急列车，很巧刚好赶上了熊猫头的车次，可惜没有拍下照片。一开始把指定席座位的row看成了车厢，上了6号车以后急头白脸地去按车厢门，但是怎么也按不开。于是麻烦了旁边一个社畜小哥，他把开不了的标识指给我看。我直接懵逼，以为这趟列车是中间死死隔开的，直到旁边一堆老夫妻跟我说了一些日语，我倒是听到了ご、ろく之类的，但还是听不太全。后来我终于意识到我把排数看车车箱数了！然后赶紧跑到我该去的5号车厢了。</p>
<p>在列车连接处遇到一个白人女孩，和她用英语聊了一会。听起来她是直接用pass上了车，然后发现这趟车是全车指定席的。我和她说可以直接坐下，worker之后会找她收费……</p>
<p>C&#x2F;D座果然靠海，但是其实这条JR线大部分都是被树木或者两侧挡住，只有一小段能够看到海景。不过在行驶的列车中偶然能看见一角蔚蓝也足够惊艳了。下车以后买好一日巴士通票就直奔とれとれ市場，进去以后发现里面居然这么多人，安静的道路上根本看不出来白浜居然有这么多人。本来准备看的金枪鱼解体表演好像已经到了尾声，不过我看台面上也挺血腥的……当时就感觉这样直接吃刺身也有点吓人。走到一个柜台处看到小盒装的刺身，于是跳了一个最便宜的三文鱼刺身，600yen足足有六片三文鱼和一些鲑鱼籽。鱼肉很紧实也很新鲜，吃起来非常过瘾，啊此刻想起来还是让人流口水。午饭点了一份刺身丼——实际上是我没看懂假名的salmon，没有意识到这又是一份三文鱼……不过这份贵了很多的刺身吃起来鱼肉要嫩好多，明显是更好的部位，并且在海苔上画出来的とれとれ市場也很有趣~</p>
<p>下午沿着海岸散步，白良滨真是惊艳到我了，柔软的白色细沙、清澈的海水和深蓝色辽阔的远方。今天的天气实在是很适合海边，把鞋和袜子脱掉光脚踩在浪头里也一点感觉不到寒冷，而是很舒服的清凉。几个白人在白色的沙滩上躺下，享受日光浴，真是让我好羡慕，谁不想就这样躺在海边，让暖暖的阳光照拂全身，听着一浪一浪的拍打声闭眼休憩呢。在白良浜旁边冲洗好脚上的沙子以后泡了足汤，水差不多四十多度的样子，超乎我想象的清澈。白浜每个景点旁边都有厕所，巴士也是几分钟就有一班，让人感觉到这个海滨小镇对游客的诚意。</p>
<p>走在路上一不小心就错过了崎の汤，他没有开在大马路的两侧，我有什么办法，想着明天要去有马泡温泉，就放弃了这个行程，想来真是可惜。没过一会就到了千叠敷，在这个据说可以放下一千张榻榻米的海岸上，岩石被海浪侵蚀出一层层纹路。一些孔洞中长满了绿色丝状海草，海草的表面结了一层厚厚的盐霜。站在千叠敷临海的岸边，重重海浪不断拍打着岸边的礁石，拍出美丽的白色浪花，听着海浪的声音，看着浪花扬起飞溅而又落下，真是让人心中忍不住生出感慨——真美啊！</p>
<p>三段壁我并没有驻足太长的时间，这里只能从不远处的一个观景台看到全貌，而岩壁上方高出海面几十米的的黑色礁石上围了一圈围栏不让人更进一步。不过这里岩石的断裂显得更加明显，地壳运动所产生的整整齐齐上升与下降让岩石呈现出一段一段的效果，棱角分明。</p>
<p>回到とれとれ市場后又挑了另一家吃晚饭，点完以后想要个筷子，结果吧台小妹看起来并不明白什么是chopsticks，我看她愣在那里就用手指比划了一下，她也做出✌夹住的形状，让我没想到的是她递了一把西餐刀给我……可能是因为我点的是汉堡吧(捂脸)。</p>
<p>晚上原定计划要坐的黑潮号晚点了快30分钟，google map上说是阪和线上出现了人车相撞事件……所幸在站点遇到了一帮中国旅行的叔叔阿姨，和他们聊了一会也是解解闷。</p>
<h4 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h4><p>今天再次造访神户，美利坚公园旁边的高塔已经建完了，红色的外层钢筋还挺好看的。途中路过中华町，感慨在霓虹终于见到一家早点店了。三宫真是繁华，去到steak land点了一份3500yen的神户牛套餐和一份2800yen的大份嫩牛排套餐。因为是第一次这样吃现场做的牛排，师傅问我是要rare，median还是well done的时候我没听懂，把rare以为是hare……所以懵逼了，跟他说you can choose for me。后来看到师傅把牛排先初步煎熟外皮棕色内里还是红色的时候，我才意识到是在问我牛排的熟度。赶紧上网查了一下这些熟度的英文怎么念，然后跟师傅说了声median well(七分熟)。煎好的牛排味道很赞，配上小菜和米饭很完美地体验了一次神户牛。</p>
<p>下午在有马温泉的太阁之汤泡了温泉——好吧不是私汤的温泉其实就是大澡堂(毛巾不能放进池子，得在旁边的一个个的台子处洗)。金汤和银汤都泡了，金汤里一片浑浊，但是单独掬一捧水却又能看到清澈。银汤里乍看很脏，水里有很多随着水流动的漂浮物，但是哪些其实是气泡，银汤里含有碳酸，在泡的途中慢慢分解。出太阁之汤后在门口有被保安大叔拦下，一开始我还以为是不让拍照要让我们删除呢，没想到他重复了好几遍カメラ之后我才明白是要帮我们拍照，再一次狠狠被关西人的热情打动了。</p>
<p>晚上在玉出买了吃的……好吧果然是鄙视链最底层的超市，东西虽然很便宜，但是味道不怎么样，下次便当还是去便利店买有保障一点吧。</p>
<h4 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h4><p>本来打算今天下午去看u15的比赛，但是上午因为EPASS进不去大阪城来回耽误了一会，于是最终没能赶上。大阪城内部展出了一些丰成秀吉使用过的物品以及大阪城过去的布局样貌。但是个人感觉大阪城以及外面的御座船还是没有必要花钱去。到了梅田以后雨已经下了很久了，鬼知道tenki为什么预报降水量这么不准。阪急33番街和hep five都去了，被人流量吓住，大阪明明没啥好玩的怎么永远都有这么多人啊……真的就是购物买买买的天堂吗。在hep five的7楼坐上了摩天轮，可惜没能看到夜景，不过眺望大阪层层楼房的景色还是挺有趣的。早早地来到了京都进行了check in，酒店not bad。晚上去体验了一下松屋，点了一份鲑鱼套餐一份打分烤猪肉套餐，事实证明不该点烤猪肉套餐的，因为太咸了……这下真是体力活工地食堂了。不过松屋真的，对社恐特别友好，自己在机器上购买拿券，然后什么都不要做，找个位置坐下，等到屏幕上显示出自己的号牌后再去拿饭。闷头干完饭以后自己把盘子送过去就可以溜之大吉，实在是穷游首选啊。</p>
<p>和妈妈出去玩很开心，希望以后也能在空闲时间多陪陪父母。<br>后面的好像就没能有毅力写下去了……那么就这样先发着吧啊哈哈哈哈</p>
<h4 id="旅行计划"><a href="#旅行计划" class="headerlink" title="旅行计划"></a>旅行计划</h4><p>机酒信息</p>
<ul>
<li>4月17日 SC4662 17:20虹桥T2-18:50胶东 座位25E，25F</li>
<li>4月18日 SC4091 8:20胶东-11:25关西T1</li>
<li>4月24日 SC4094 17:20关西T1-19:00胶东 </li>
<li>4月25日 SC4661 7:30胶东-9:10虹桥 座位25E，25F</li>
<li>中转酒店：胶州市李哥庄镇香港大街226号，入住当天18:00前联系0532-88260888</li>
<li>4月18日-4月21日 日本、〒556-0015 大阪府大阪市浪速区敷津西２丁目７−２<ul>
<li>房间：当日下午13:30后<a href="https://www.onestayapp.com/v2/checkin/search?checkin_code=13851461&pin_code=mn9g3n&referral=email_from_auto_message">提取预定信息</a></li>
<li>密码：＊ → 1145 → 呼出</li>
</ul>
</li>
<li>4月21日-4月24日 日本、〒600-8451 京都府京都市下京区亀屋町<ul>
<li>[AHK302] Avenir Hotel Kyoto Room 302</li>
<li>入口密码：致电]-&gt;0-&gt;1-&gt;1-&gt;9</li>
<li>房间密码：2-&gt;8-&gt;2-&gt;3-&gt;E</li>
</ul>
</li>
</ul>
<p>行程安排</p>
<ul>
<li>4月18日 大阪半日 固定费用130yen&#x2F;人<ul>
<li>11:25到达关西国际机场，去往二楼，JR PASS 预约编号 47098</li>
<li>预计13:00左右，预约最近一班Haruka JR特急列车，前往人工柜台兑换好所有JR PASS票券 <a href="https://www.westjr.co.jp/global/sc/howto/train-reservation/receive/">取票方法│使用指南</a></li>
<li>13:14-13:53乘Haruka到天王寺转新今宫站</li>
<li>14:00左右步行到动物园前四号口Daikoku Locker寄存行李箱(130yen&#x2F;箱)</li>
<li>前往通天阁下的商业街&#x2F;阿倍野&#x2F;天王寺公园等地散步</li>
<li>15:30取行李，步行或JR前往民宿地入住&#x2F;安置行李</li>
<li>16:30左右出发依次前往 难波八坂神社-道顿崛-心斋桥</li>
</ul>
</li>
<li>4月19日 白浜一日 固定费用1100yen&#x2F;人<ul>
<li>7:30-7:34乘坐JR从今宫站到天王寺站</li>
<li>7:57-10:10乘坐黑潮号从天王寺至白浜  在白浜站门口购买一日巴士券1100yen&#x2F;人</li>
<li>11:00可在toretore市场看金枪鱼解体表演</li>
<li>中途可在千叠敷&#x2F;三段壁&#x2F;白良浜&#x2F;圆月岛&#x2F;番所山公园打卡  可以尝试直接去酒店泡汤 圆月岛最好日落时分去</li>
<li>17:20-19:33&#x2F;18:20-20:33乘坐黑潮号从白浜到天王寺</li>
</ul>
</li>
<li>4月20日 神户一日 固定费用5000yen&#x2F;人<ul>
<li>7:34-7:50乘坐JR今宫站到大阪站</li>
<li>8:00后在JR大阪站1F中央检票口前兑换大阪地铁一日PASS</li>
<li>乘坐JR前往JR三宫</li>
<li>在地铁三宫站购买有马温泉套票 2450yen&#x2F;人</li>
<li>在神户三宫port line进站口定期券办公室购买<strong>神户动物王国套票</strong> 2200yen&#x2F;人 仅现金(省来回公交费用)</li>
<li>9:00-11:00一路游览 南京町$\xrightarrow{10min}$美利坚公园$\xrightarrow{10min}$旧居留地$\xrightarrow{4min}$<a href="https://www.kobecitymuseum.jp/">神户市立博物馆</a>(9:30开馆) 2楼300yen&#x2F;人</li>
<li>11:00 午饭<ul>
<li>【可选】神户牛 steak land，150g普通牛&#x2F;嫩牛&#x2F;神户牛&#x2F;神户嫩牛价格分别为1700&#x2F;2800&#x2F;3500&#x2F;4500yen</li>
</ul>
</li>
<li>12:00-16:00神户port line前往神户动物王国游玩2h左右，公交时间单程半小时 喂食时间：海豹13:00海狗14:00水豚14:30猫头鹰15:15企鹅15:30</li>
<li>PLAN A：有马温泉 接驳车时间<ul>
<li>16:09-16:40三宫$\xrightarrow{地}$新神户$\xrightarrow{地}$谷上$\xrightarrow{私}$有马口$\xrightarrow{私}$有马温泉</li>
<li>16:48或17:10乘坐接驳车去往太阁之汤</li>
<li>19:00乘坐接驳车去往有马温泉站 返程</li>
</ul>
</li>
<li>PLAN B：尼崎</li>
</ul>
</li>
<li>4月21日 大阪一日 固定费用0yen&#x2F;人<ul>
<li>8:00地铁到达动物园前在Daikoku Locker寄存行李</li>
<li>8:30地铁到达四天王寺看中古市集</li>
<li>9:30地铁到达大阪城公园，预约1h后的大阪城御座船(15min一班)并入内参观</li>
<li>10:30乘坐大阪城御座船</li>
<li>11:00游览大阪历史博物馆</li>
<li>约12:00地铁到达梅田站 在梅田附近吃午饭 乘坐Hep Five摩天轮观赏(原价600yen)</li>
<li>在梅田商圈逛街购物或前往大阪国立国际美术馆</li>
<li>15:15-15:45乘坐地铁至大阪港站 16:00乘坐圣母玛利亚号观光帆船(原价1800yen)</li>
<li>晚上前往天王寺取行李乘坐JR前往京都入住</li>
</ul>
</li>
<li>4月22日 宇治&#x2F;奈良一日 固定费用 1600yen&#x2F;人<ul>
<li>8:30-9:00前往JR宇治站 240yen&#x2F;人</li>
<li>午前游览宇治 平等院(600yen&#x2F;人)&#x2F;宇治桥&#x2F;宇治川&#x2F;抹茶</li>
<li>13:00-14:00宇治到JR奈良站下车</li>
<li>乘坐巴士到奈良国立博物馆门口后开始散步</li>
<li>游览奈良公园&#x2F;若草山(150yen&#x2F;人)</li>
</ul>
</li>
<li>4月23日 京都一日 固定费用 2000yen&#x2F;人<ul>
<li>7:30-8:00从地铁五条站&#x2F;公交站经京都站到达JR稻荷站 230yen&#x2F;人 【可以提前半小时以获得最佳体验】</li>
<li>8:00-9:00在伏见稻荷大社&#x2F;千本鸟居处打卡</li>
<li>9:00-9:30乘坐京阪本线巴士前往七条，游玩三十三间堂寺庙 600yen&#x2F;人</li>
<li>午前游览三十三间堂对面的京都国立博物馆 700yen&#x2F;人</li>
<li>14:00-14:30乘坐206巴士到清水站</li>
<li>14:30-16:30游览清水寺&#x2F;三年坂&#x2F;二年坂 400yen&#x2F;人 【人可能会很多】</li>
<li>晚上步行前往八坂神社看夜景，可以逛花见小路&#x2F;四条等地</li>
</ul>
</li>
<li>4月24日 机场线 固定费用 2100yen&#x2F;人<ul>
<li>自由安排</li>
<li>14:00前乘坐JR到达关西机场T1 1900yen&#x2F;人</li>
</ul>
</li>
</ul>
<p>出行前花费</p>
<ul>
<li>电话卡，7天每天2G，2人73.2元</li>
<li>签证，飞猪新好游纯线上办理，2人468元</li>
<li>机票，上海往返大版(青岛中转)，2人2301元</li>
<li>酒店，爱彼迎，2人2574.8元<ul>
<li>日本、〒556-0015 大阪府大阪市浪速区敷津西２丁目７−２，4&#x2F;18-4&#x2F;21，1265.56元</li>
<li>日本、〒600-8451 京都府京都市下京区亀屋町，4&#x2F;21-4&#x2F;24，1309.24元</li>
</ul>
</li>
<li>通勤<ul>
<li>JR关西广域周游券5天PASS，2人1170.1元</li>
<li>大阪乐游券+地铁巴士一日券，klook购买，2人154元</li>
</ul>
</li>
</ul>
<p>JR铁路交通</p>
<ul>
<li><a href="https://www.westjr.co.jp/global/tc/timetable/pdf/ubn_tc.pdf">JR路线图</a></li>
<li>JR关西周游券<ul>
<li>线上购买预定(可提前一个月预定指定席)以及取票一系列流程可以参考视频<a href="https://www.bilibili.com/video/BV1ku411x7CP">自由行交通的最优解：JR PASS购买指南</a>，也可以第三方平台购买，线下取票预定</li>
<li><a href="https://www.westjr.co.jp/global/sc/ticket/">线上预定</a>页面中部选择购买不同周游券，需要<strong>国际</strong>信用卡VISA、Master等</li>
<li><a href="https://www.westjr.co.jp/global/sc/ticket/">线上预定</a>页面底部预约指定席或变更日期，在未发车之前都可以向前或向后变更首日生效日期</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>回顾2023</title>
    <url>/Blog/2024/02/19/%E5%9B%9E%E9%A1%BE2023/</url>
    <content><![CDATA[<p>2023年于我来说绝对算不上是成功的一年，学业上落下了很多，浪费了很多时间，也养成了很多不好的习惯。时常对自己有很多不满，但却又缺乏改正的决心与毅力，既迷茫，又无助。即便总是在感官全部消停放松之际感到懊悔与空虚，却在不久之后仍投入无营养但爽快的娱乐中。</p>
<p>很显著的感受就是记忆力的衰退和注意力的分散，从忘记别人的名字到忘记重要的事，大脑总是一片混沌，疲惫的同时却又难以有充足的睡眠时间，我想我真的需要一场改变。</p>
<p>在这里许下自己2024年的愿望吧，期待到2024年年末的时候能够从中划去每一项：</p>
<ul>
<li><p><input disabled="" type="checkbox"> 
投稿一次</p>
</li>
<li><p><input disabled="" type="checkbox"> 
背完1500+个日语单词</p>
</li>
<li><p><input disabled="" type="checkbox"> 
体重降低到62kg</p>
</li>
</ul>
]]></content>
      <categories>
        <category>杂谈点滴</category>
      </categories>
  </entry>
  <entry>
    <title>复旦校内Ubuntu主机配置：软件、网络</title>
    <url>/Blog/2023/10/18/%E5%A4%8D%E6%97%A6%E6%A0%A1%E5%86%85%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%EF%BC%9A%E8%BD%AF%E4%BB%B6%E3%80%81%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h4 id="重装操作系统"><a href="#重装操作系统" class="headerlink" title="重装操作系统"></a>重装操作系统</h4><p>使用具有PE功能的U盘，例如Ventoy U盘，搭载操作系统镜像文件。在电脑启动时按F2或F12进入BOIS界面，<strong>关闭安全启动</strong>，从U盘引导系统。Ubuntu安装时可以选择不保留之前的文件。</p>
<h4 id="无线网络配置"><a href="#无线网络配置" class="headerlink" title="无线网络配置"></a>无线网络配置</h4><p>参考<a href="http://ecampus.fudan.edu.cn/2262/list.htm">配置方法 (fudan.edu.cn)</a>连接学校校园网，确认可以<strong>访问校外网络</strong>。</p>
<p>注意：无线网络的IP无法通过校园网ping通，在校内无法被寻址通信。</p>
<h4 id="apt配置"><a href="#apt配置" class="headerlink" title="apt配置"></a>apt配置</h4><p>参考<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a>配置清华源。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">cp</span> /etc/apt/sources.list /etc/apt/sources.list.backup <span class="token comment">#备份旧的list</span>
<span class="token function">sudo</span> <span class="token function">rm</span> /etc/apt/sources.list
<span class="token function">sudo</span> <span class="token function">vi</span> /etc/apt/sources.list <span class="token comment">#使用系统自带的vi编辑器编辑，将上述url拷贝进来</span>
<span class="token function">sudo</span> <span class="token function">apt-get</span> update</code></pre>

<p>之后可以通过<code>sudo apt-get install</code>安装其他软件。</p>
<h4 id="有线网络配置"><a href="#有线网络配置" class="headerlink" title="有线网络配置"></a>有线网络配置</h4><h5 id="固定本机校园网IP"><a href="#固定本机校园网IP" class="headerlink" title="固定本机校园网IP"></a>固定本机校园网IP</h5><p>断开无线网络，确认有线网络已连接。通过有线网络的设置的图形界面，结合<code>ip addr</code>，<code>route -n</code>等命令拿到当前自动获取的<strong>IP,子网掩码和网关</strong>。用其他校园网内机器确认当前ip可以ping通。</p>
<p>在有线网络设置中将IPv4设为手动模式，然后填入上述数值。若Ubuntu没有图形化界面，则可以通过编辑负责有线连接的网卡的配置文件，在其中写入IP等信息以固定IP。</p>
<p>重启电脑或关闭一段时间后重启，确认IP已被固定。</p>
<h5 id="SSH连接"><a href="#SSH连接" class="headerlink" title="SSH连接"></a>SSH连接</h5><p><code>sudo apt-get install openssh-server</code>，然后可以<code>ssh 本机用户名@本机IP</code>测试是否可以接受SSH连接。若IP已经固定，可以记录当前IP，用于之后从其他机器SSH连接本机。</p>
<h5 id="访问外部网络"><a href="#访问外部网络" class="headerlink" title="访问外部网络"></a>访问外部网络</h5><p>默认有线连接无法访问外部网络，需要进行认证。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">--insecure</span> <span class="token parameter variable">--data</span> <span class="token string">"action=login&amp;username=<span class="token variable">$&#123;<span class="token environment constant">UID</span>&#125;</span>&amp;password=<span class="token variable">$&#123;PASSWD&#125;</span>&amp;ac_id=1&amp;user_ip=<span class="token variable">$&#123;IP&#125;</span>&amp;nas_ip=&amp;user_mac=&amp;save_me=1&amp;ajax=1"</span> https://10.250.3.66/include/auth_action.php</code></pre>

<blockquote>
<p>注意，根据<a href="https://ecampus.fudan.edu.cn/19/67/c33383a661863/page.htm">信息办通知</a>，有线网络认证客户端IP已经变更到<code>10.250.3.66</code></p>
</blockquote>
<p>将自己的学号和密码填入对应位置，IP填本机IP，然后在终端中运行。</p>
<p>显示登陆成功后尝试<code>ping 8.8.8.8</code>或<code>ping 114.114.114.114</code>，若能成功ping通，说明可以访问外部网络。</p>
<h5 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h5><p>若在终端中<code>ping www.baidu.com</code>失败，可以通过<code>nslookup</code>确认是否是由于DNS服务器未正确设置。</p>
<ul>
<li><p>临时修改DNS服务器：编辑<code>/etc/resolv.conf</code>，将nameserver设为<code>8.8.8.8</code>【国际通用DNS服务器】或<code>114.114.114.114</code>【国内通用DNS服务器】，重启后会复原</p>
</li>
<li><p>永久修改DNS服务器：编辑<code>/etc/systemd/resolvd.conf</code>，将DNS项修改为<code>8.8.8.8</code>或<code>114.114.114.114</code>，此时应该可以ping通外部网络域名，浏览器也可以正常访问。</p>
<p>注意：<code>resolvd.conf</code>会覆盖<code>resolv.conf</code>中的配置，所以访问<code>/etc/resolvd.conf</code>依然能看到不起作用的默认DNS。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术视野</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>大模型驱动的自动化日志分析</title>
    <url>/Blog/2023/12/04/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>贺品嘉 LOGPAI</p>
<h4 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h4><ul>
<li>高质量的规范日志——日志记录<ul>
<li>where to log? 15年工作：将问题限制在try catch块和return value check</li>
<li>挑战<ul>
<li>难以很好的完成总体任务，更多工作是聚焦于子任务的解决</li>
<li>粒度不够，业务代码的细节难以被理解</li>
<li>受限于方法本身的约束，假设太强的工作也难以投入实际应用</li>
</ul>
</li>
</ul>
</li>
<li>管理和保存大量日志——日志压缩</li>
<li>从日志中提取信息——日志解析<ul>
<li>解析半结构化的数据</li>
<li>挑战：<ul>
<li>难以跨日志系统泛化，利于基于文本生成的方法就要面对不同系统中词语含义不一样的问题</li>
<li>业界的日志比较复杂，多行日志与单行日志混合，现有的工作主要聚焦单行日志</li>
<li>受限于方法本身的约束，例如日志模板是定长的还是变长的</li>
</ul>
</li>
</ul>
</li>
<li>利用日志中挖掘的信息——日志挖掘<ul>
<li>例如一些机器学习的方法，聚类等等</li>
<li>挑战：<ul>
<li>难以挖掘语义，因为日志的上下文丢了</li>
<li>难以适应日志的迭代</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="近期工作"><a href="#近期工作" class="headerlink" title="近期工作"></a>近期工作</h4><p>ICSE’24 UniLog</p>
<p>prompt模板(一些example)+输入，直接生成行号+log语句，从而一步完成多个子任务</p>
<p>有warm up，先在prompt中给一些内容</p>
<p>？如何评价message的正确错误</p>
<p>ICSE’24 DivLog</p>
<p>人先label一些，200行，抽取时尽量正交</p>
<p>prompt：先任务，然后例子，最后log</p>
<p>看起来在单行日志解析任务上结果非常优异 ？能说说为什么其他模型不行吗，因为我不是很了解这些数据集</p>
<h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p>Q: 什么是好的日志生成</p>
<p>A: 要好的数据集，或者人工的label，和公司合作的数据</p>
<p>Q: 是否有必要自己构造一个属于日志领域的大语言模型</p>
<p>A: 基座模型难以训练(资源)，现在的也不错</p>
<p>Q: UniLog每次处理都是小的snippet，项目代码中有很多项目内部的内容，该如何更好的理解？</p>
<p>A: 有另一篇工作在投，引入一些静态分析方法加入prompt</p>
<p>Q: 大模型生成的内容无法保证？当前采用的方法是rethink再问</p>
<p>A: 可以把temperature设为0，大模型很难做到结果百分百正确</p>
<p>Q: 网络调用次数太多会有API Error，Network Error的问题。当前的做法是错误处理</p>
<p>A: 可以自己微调一个开源模型</p>
]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>大模型</tag>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title>美签B1/B2面签记录</title>
    <url>/Blog/2024/09/13/%E7%BE%8E%E7%AD%BEB1-B2%E9%9D%A2%E7%AD%BE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<ul>
<li>异地面签</li>
<li>学术会议</li>
<li>照片问题</li>
<li>时间安排</li>
</ul>
<p>8月底收到ASE’24 SRC的论文录用信，赶紧填完了DS160预约了面签时间。填DS160的时候选的地点是上海，但是交完面签预约费之后才发现上海已经排到了10月，万一被check了就来不及了。网上说可以选择其他地点面签，我就选了北京领馆，预约了9月13日上午9:45的场。酒店我定在使馆旁边，步行10min就可以到达使馆，提前一天入住。</p>
<p>我准备的面签材料有</p>
<ul>
<li>必带材料：<strong>DS160确认页</strong>，<strong>预约确认页</strong>，<strong>护照</strong>，<strong>身份证</strong></li>
<li>辅助材料：<strong>ACM提供的VISA support letter</strong>, <strong>完整论文</strong>, 会议介绍, 英文简历, 在读证明, 行程表</li>
<li>我没准备但是现场需要的辅助材料：<strong>资助证明</strong>，<strong>照片</strong></li>
</ul>
<p>当天早上我发现我DS160上传的照片尺寸并非美使馆要求的51mm*51mm，而是用的标准1寸证件照。所以我必须准备<strong>两张实体照片</strong>。有两个选择：1. 用使馆内的自助照相机拍 2. 找个附近的照相馆迅速拍完。我在附近一家照相馆缴费129元，在8:10左右拿到了照片（老板后来跟我说其实可以用自拍发给她后到领馆门口去等她送）实际上我面签进使馆以后发现自助相机处没啥人排队，不清楚要50还是100元现金，但是还是不建议冒险。【<strong>教训：一定要先自己准备好照片</strong>】</p>
<p>大约8:30打车到达了使馆对面的莱太存包处，单存手机10块，一个包30块。然后就拿着我的文件袋去领馆门口排队去了，在领馆门口排了一个多小时，进去以后又排了大半个小时，终于采录指纹、面谈。当天人比较少，队伍没有溢出使馆门口的闸道，但是高峰期可能会排1.5-2倍的人排到街对面去【<strong>教训：排队前记得上厕所</strong>】</p>
<p>面谈我的是个黑人女性，首先用中文问我去美国做什么，我说开学术会议，并且我表示可以用英文交谈。以下后续问题都是全英文交流：</p>
<ul>
<li>什么学历？读的是什么专业？</li>
<li>会议的内容？（递给她VISA support letter和paper，她拿起了我的paper）paper的内容？是研究什么的？有什么实际应用？这部分对话占比比较多，看的出来她在确认我足够了解自己的工作，真的问了好几个问题，满头大汗了((</li>
<li>费用谁来承担？有没有funding letter？因为我DS160填的是自费，所以没准备资助证明，但是我怕她找我要存款证明，所以跟面试官说是我导师承担开销，并且没有准备funding letter。她说没关系，然后就给我过了。</li>
</ul>
<p>出来的时候是10:50，总耗时2.5h。</p>
<p>一些其他观察</p>
<ul>
<li>整体出签率较高，基本符合70%出签，但是我出了领馆也看见有没过的</li>
<li>旅游签签证官很爱问有没有去过其他国家，但是我这边就没问，可能因为我不是去旅游的</li>
</ul>
]]></content>
      <categories>
        <category>杂谈点滴</category>
      </categories>
  </entry>
  <entry>
    <title>程序设计语言海外名家微型课程学习笔记</title>
    <url>/Blog/2023/10/09/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E6%B5%B7%E5%A4%96%E5%90%8D%E5%AE%B6%E5%BE%AE%E5%9E%8B%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>课程</th>
<th>主讲人</th>
</tr>
</thead>
<tbody><tr>
<td>Introduction to Functional Programming</td>
<td>Jeremy Gibbons</td>
</tr>
<tr>
<td>Introduction to Property Based Testing</td>
<td>John Hughes</td>
</tr>
</tbody></table>
<p>大纲：<a href="https://pl.cs.pku.edu.cn/info/1017/1839.htm">程序设计语言海外名家微型课程-北京大学程序设计语言研究室 (pku.edu.cn)</a></p>
<p>材料：<a href="https://github.com/jegi/Beijing-exercises">jegi&#x2F;Beijing-exercises: Exercises and other materials for the course on FP and QuickCheck at Peking University in October 2023 (github.com)</a></p>
<p>授课地点：北京大学</p>
<h3 id="第一讲"><a href="#第一讲" class="headerlink" title="第一讲"></a>第一讲</h3><h4 id="Functions-equations-recursion-reasoning-higher-order"><a href="#Functions-equations-recursion-reasoning-higher-order" class="headerlink" title="Functions, equations, recursion reasoning, higher-order."></a>Functions, equations, recursion reasoning, higher-order.</h4><p>传统的有语句statement和表达式expression，函数时可以理解为只涉及表达式，只操作value，这种视角可能回更加精简。</p>
<p>no side effects是expression的一个重要性质</p>
<ul>
<li>赋值操作(action)会破坏这样的性质</li>
</ul>
<p>Fortran将statement转化为一系列简单的机器操作，这在当时是一种创新，队expression的拓展</p>
<p>applicative order evaluation：先计算参数，再展开函数并带入【对于infinity之类的递归定义值不太好处理】</p>
<p>normal order evaluation：先展开函数定义，再考虑带入参数【call by need， lazy evaluation，Haskell用这个】</p>
<p>Haskell的函数类型定义类似$f::A\rightarrow B$，$f$是函数名，$A$和$B$是参数类型，调用函数的时候$f\ x$即可，例如<br>$$<br>square::Integer\rightarrow Integer\<br>square\ (3+4)<br>$$<br>用lambda表达式写square就是$\lambda x\rightarrow x\times x$</p>
<p>Haskell支持多种编程风格，declaration style和expression style</p>
<p>函数相等的含义是说对于任何输入的参数，函数都能输出相同的内容【当然计算机不能知道】</p>
<p>Currying：把结构化的参数替换为多个更简单的结构，函数的柯里化。例如把一个接受两个参数的函数转化为一个接受两个连续参数的函数。</p>
<p>所谓的接受两个连续参数，定义可以写成$f::Integer\rightarrow Integer\rightarrow Integer$，它等价于$f::Integer\rightarrow (Integer\rightarrow Integer)$【右结合性】，也就是先接受一个参数，返回一个函数，再由这个函数接受连续的第二个参数。实际调用的时候可以写成$fa\ b$</p>
<p>associative：可以随便加括号，例如+*等。而FP中函数类型定义的操作符$\rightarrow$是<strong>右结合</strong>的，函数调用则是<strong>左结合</strong>的，所以特别的顺序需要额外加括号</p>
<p>composition：函数复合，$f\circ g&#x3D;\lambda x\rightarrow f(g\ x)$，即先调用$g$再调用$f$,显然它是associative的</p>
<p>definitions：例如<br>$$<br>here::String\<br>here&#x3D;\text”Oxford\text”\<br>smaller::(Integer, Integer)\rightarrow Integer\<br>smaller\ (x,y)&#x3D;\bold{if}\ x\le y\ \bold{then}\ x\ \bold{else}\ y<br>$$<br>“&#x3D;”意味着pattern match，即等号左边的pattern可以替换为右边的内容。所以你可以定义特殊情况的替换规则。等号右侧的表达式中可以引入新变量，并在最后用where语句写local definition<br>$$<br>foo::Float\rightarrow Float\<br>foo\ x &#x3D; x + a\ \bold{where}\ a&#x3D;sqrt\ x<br>$$<br>也可以使用$\bold{let}\ definition\ \bold{in}\ expression$的形式</p>
<p>一些有趣的定义：<br>$$<br>curry::((a,b)\rightarrow c)\rightarrow(a\rightarrow b\rightarrow c)\<br>curry\ f&#x3D;\lambda a\ b\rightarrow f(a,b)<br>$$<br>根据定义，curry接受一个$((a,b)\rightarrow c)$函数，返回一个$(a\rightarrow b\rightarrow c)$的函数。对应到下面，$f$就是这个参数，而等号右边的$\lambda\cdots$就是返回的函数。这个返回的函数接受两个参数，返回参数$f$调用这两个函数的结果。<br>$$<br>iter::Int\rightarrow (Integer\rightarrow Integer)\rightarrow(Integer\rightarrow Integer)\<br>iter\ 0\ f&#x3D;id\<br>iter\ n\ f&#x3D;f\circ iter(n-1)\ f<br>$$</p>
<h4 id="Motivational-introduction-to-property-based-testing-with-stories-from-the-battlefield—using-Quviq-QuickCheck-for-Erlang"><a href="#Motivational-introduction-to-property-based-testing-with-stories-from-the-battlefield—using-Quviq-QuickCheck-for-Erlang" class="headerlink" title="Motivational introduction to property-based testing, with stories from the battlefield—using Quviq QuickCheck for Erlang"></a>Motivational introduction to property-based testing, with stories from the battlefield—using Quviq QuickCheck for Erlang</h4><p>generate tests but write them</p>
<p>Example：a Circular Buffer，一个用C实现的循环buffer，通过取模运算实现</p>
<p>property：size大小应该正确</p>
<p>计算size的时候需要%size，但是如果实占空间(input pointer - output pointer)&#x3D;&#x3D;size，那么结果是0&#x3D;&gt;不正确。</p>
<ul>
<li>解决方法：偷偷将size在分配时搞成n+1，这样实占n的时候n%(n+1)也能得到正确结果</li>
</ul>
<p>如果input pointer在output pointer之前，%会产生负数结果。</p>
<ul>
<li>解决方法：(input pointer - output pointer + size) % size</li>
</ul>
<p>有状态机器模型</p>
<p>每个API call有pre condition&#x2F;stste transition&#x2F;post condition，call完以后的post condition应该与对应model一致</p>
<ul>
<li>同一个property可以测出不同的bug</li>
<li>精简失败的测试样例可以使我们debug变得更简单</li>
</ul>
<p>CANbug的例子：底层由于ID的bit长度不够用而拓展长度，让最左边的bit作为标志版本位，结果软件工程师在比较priority时却从左边开始比。</p>
<p>state model machine该如何应对并发情况呢？可能结果太多了</p>
<blockquote>
<p>他的解释是以可能的sequence作为model，因为大多数的操作是原子的，可以这样干</p>
</blockquote>
<p>Q: dif between fuzzing and pbt?</p>
<p>A: 也有一些用coverage based 方法来做pbt的</p>
<h3 id="第二讲"><a href="#第二讲" class="headerlink" title="第二讲"></a>第二讲</h3><h4 id="Algebraic-datatypes"><a href="#Algebraic-datatypes" class="headerlink" title="Algebraic datatypes"></a>Algebraic datatypes</h4><p>list：</p>
<pre class="language-haskell" data-language="haskell"><code class="language-haskell"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span></code></pre>

<p>$[1,2,3],[]$，用$ele:list$表示ele后面接续的list。$[1,2,3]&#x3D;1:2:3:[]$</p>
<p>同一函数的多个pattern matching可以用case of语句结合起来</p>
<p>list操作符：$++::[Integer]\rightarrow[Integer]\rightarrow[Integer]$两个拼接，$concat::[[Integer]]\rightarrow[Integer]$，$reverse$</p>
<p>map：对每个ele执行操作<br>$$<br>map::(Intger\rightarrow Integer)\rightarrow [Integer]\rightarrow[Integer]\<br>map\ f(x:xs)&#x3D;f\ x:map\ f\ xs<br>$$<br>filter：<br>$$<br>\begin{align}<br>filter\ p(x:xs)\<br>&amp;|p\ x&amp;&#x3D;x:filter\ p\ xs\<br>&amp;|otherwise&amp;&#x3D;filter\ p\ xs<br>\end{align}<br>$$<br>list-generating expression: $[e|Qs]$，e是表达式，Qs是用”,”分割一系列qualifier，例如$x\leftarrow xs$这样的generator，或者其他条件</p>
<blockquote>
<p>x:xs这样的格式让haskell的列表更加适用于类似于动规那样可以分解为子问题的算法</p>
</blockquote>
<p>Fold right：类似sum x:xs&#x3D;x+sum xs这种，展开后从右向左合并</p>
<p>Fold left：foldl op e (x:xs) &#x3D; foldl op (e ‘op’ x) xs展开后(((e op x)op y) op x ……从左向右合并。即先提供一个初始值e，然后不停用op操作已有值与第一个值</p>
<p>【？？漏了】</p>
<p>algebraic datatypes：用代数形式表示的数据类型，例如一个接受A类型和B类型的函数C接受参数后可以视为一份Data，再例如一些类型的复合等等</p>
<h4 id="How-to-specify-it"><a href="#How-to-specify-it" class="headerlink" title="How to specify it!"></a>How to specify it!</h4><p>propert check函数可以使用&#x3D;&#x3D;&#x3D;才判断相等的同时展示相关信息</p>
<pre class="language-haskell" data-language="haskell"><code class="language-haskell"><span class="token import-statement"><span class="token keyword">import</span> Test<span class="token punctuation">.</span>QuickCheck</span>

<span class="token hvariable">prop_Reverse</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Integer</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token constant">Integer</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token constant">Integer</span><span class="token punctuation">]</span> <span class="token comment">--明确的类型告诉QuickCheck怎么生成test</span>
<span class="token hvariable">prop_Reverse</span> <span class="token hvariable">xs</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token builtin">reverse</span> <span class="token punctuation">(</span><span class="token hvariable">xs</span> <span class="token operator">++</span> <span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token builtin">reverse</span> <span class="token hvariable">ys</span> <span class="token operator">++</span> <span class="token builtin">reverse</span> <span class="token hvariable">xs</span></code></pre>

<p>ghci中quckCheck prop_Reverse</p>
<p>但是如果我们本身就不知道返回值的正确结果，如何写测试代码呢？</p>
<ul>
<li>可以用返回值的property继续处理 ppt p6</li>
<li>但是可能不够精确，导致测不出bug！ppt p7</li>
</ul>
<p>5 systematic ways of formulating properties</p>
<p>荐书：《How to Solve It》</p>
<p>RQs：</p>
<ul>
<li>invariant，不变的性质等等。可以将不变性套用到要测的相关操作上</li>
<li>postcondition，发生操作之后，condition可以用操作的参数以及原数据等表示。通过construct这些操作来确保相关性质一定成立(不涉及可能有问题的逻辑)</li>
<li>metamorphic tests，对测试进行变质，不同测试顺序达到相同结果or性质</li>
<li>inductive properties，可以归纳证明其他相关操作正确性的基础性质</li>
<li>model based properties，对程序状态建模model(自动生成)，需要确保模型正确，程序状态变迁的同时model自己变迁，比对新程序状态是否能转为新model</li>
</ul>
<h3 id="第三讲"><a href="#第三讲" class="headerlink" title="第三讲"></a>第三讲</h3><h4 id="Types-polymorphism-type-classes"><a href="#Types-polymorphism-type-classes" class="headerlink" title="Types, polymorphism, type classes"></a>Types, polymorphism, type classes</h4><p>Algebraic Data Type(ADT)：复合数据类型，例如$\bold{data}\ Person&#x3D;P\ Name\ Age$。这里$P$就可以看作一个constructor(类似$Just$等)，Person作为参数的时候，可以用$(P\ …\ …)$代替。</p>
<p>ADT也可以是递归的，例如$\bold{data}\ Expr&#x3D;Lit\ Integer|Add\ Expr\ Expr$</p>
<p>Nat和List的定义也是递归数据结构，可以参考ppt</p>
<p>Haskell是强类型语言，类型的检查在执行之前。所以即便False &amp;&amp; 1(短路)也是会报错的</p>
<p>多态：例如$fst::(x,y) \rightarrow x$中的x,y可以指代任何类型</p>
<p>如果函数$h::[a]\rightarrow[a]$不涉及其他元素，只会rearrange原本列表中的元素。这就带来了一个有趣的性质：$map\ f\circ h&#x3D;h\circ map\ f$【free theorem】</p>
<p>type classes：为泛型加上约束，类型一定要在这一组类里，例如$(+)::(Num\ a)&#x3D;&gt;(a\rightarrow a\rightarrow a)$</p>
<h4 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h4><p>QuickCheck的class Arbitrary a有两个属性(这里a是泛型)</p>
<ul>
<li><p>arbitrary：类型为Gen a，产生一个随机的a</p>
</li>
<li><p>shrink：根据生成的数据，产生shrinking的备选List::[a]。shringing时<strong>不停</strong>选用其中最靠前且能导致当前case仍然fail的元素替换x，如果没有，则将case设为shrunk case</p>
</li>
</ul>
<p>Type modifier：使用type约束参数以增加generate的效率，为了方便类型检查和可读性，可以使用new type</p>
<p>四个可用的Gen的Combinator：</p>
<ul>
<li>$choose\ (m,n)$</li>
<li>$element\ xs$</li>
<li>$onof\ [gen1,\cdots, genN]$</li>
<li>$frequency\ [(w1, gen1),\cdots,genN]$</li>
</ul>
<p>test Arbitary&#x2F;Shrink？generator和shrink可能使用了buggy code，所以要先保证generator的正确</p>
<p>sized generator，给generator加额外的参数，更加自定义化</p>
<p>如果树和k分别用Int生成的话，效率可能会很低，</p>
<p>generate Key in the same way P40</p>
<p>我们建立一个新的类型Key，从而Key的 Arbitrary生成遵循同一种方式，并且利用一些方法将范围尽可能的缩小，从而使效率尽可能地高</p>
<p>更加精细化的label设置，使样例的统计更加合理</p>
<p>如果对测试的占比有要求，可以使用cover算子 cover expected_percentage condition label</p>
<h3 id="第四讲"><a href="#第四讲" class="headerlink" title="第四讲"></a>第四讲</h3><h4 id="Monads-and-Applicative-Functors"><a href="#Monads-and-Applicative-Functors" class="headerlink" title="Monads and Applicative Functors"></a>Monads and Applicative Functors</h4><p>side effect？？和主计算逻辑关联不大的的一些事</p>
<p>Monad：模拟顺序执行的一种函数式hack，可以帮助实现IO等有副作用的执行</p>
<p>传统的方式会将副作用逻辑与值逻辑混合起来，造成程序结构的混乱<br>$$<br>\bold{class}\ Monad\ m\ \bold{where}\<br>return::a\rightarrow m\ a\<br>(&gt;&gt;&#x3D;)::m\ a\rightarrow(a\rightarrow m\ b)\rightarrow m\ b<br>$$<br>这里m可以理解为某种computation</p>
<p>bind：do this，用结果do that，然后得到一个结果</p>
<p>由于bind中有各步执行的结果，所以可以模拟顺序执行语言。</p>
<p>$\bold{do}$语法糖可以帮助自动生成bind等，在其中使用$\leftarrow$来表达<strong>类似</strong>赋值的语义(实际是赋予monad 内部的值)。</p>
<p>IO Monad：输入输出&#x2F;文件……</p>
<p>Applicative functors是弱一点的定义，Monad是Approach【licative的</p>
<p>Traversal</p>
<h4 id="State-machine-models-in-Haskell"><a href="#State-machine-models-in-Haskell" class="headerlink" title="State machine models in Haskell"></a>State machine models in Haskell</h4><p>程序的输入来自一个外部的复杂系统(OS&#x2F;DB……)，输出也输出到这个复杂系统。我们无法随时建模复杂系统，但是可以有初始状态</p>
<p>model&#x2F;action</p>
<p>needs：为了记录哪些step需要记录下来</p>
<p>然后perform以[Ret stat]作为一个参数来解决之前的问题</p>
<p>在test开始时清理系统保证test不会受之前的test影响</p>
<p>negative test：需要测试出故意设置的错误的样例</p>
<h3 id="第五讲"><a href="#第五讲" class="headerlink" title="第五讲"></a>第五讲</h3><h4 id="Laziness-and-Infinite-Data-Structures"><a href="#Laziness-and-Infinite-Data-Structures" class="headerlink" title="Laziness and Infinite Data Structures"></a>Laziness and Infinite Data Structures</h4><p>lazy evaluatiion：共享计算结果，而不是单纯的复制。即haskell先将函数展开，但是对于需要被计算出的值延迟到计算到这里的时候再算。从而可以在实现无限的数据结构的基础上，计算出优先结果(在有限步内)</p>
<h4 id="QuickSpec——Formal-Specifications-for-Free"><a href="#QuickSpec——Formal-Specifications-for-Free" class="headerlink" title="QuickSpec——Formal Specifications for Free"></a>QuickSpec——Formal Specifications for Free</h4><p>QuickSpec如何检测程序性质？枚举所有可能的等式，然后测试是否成立</p>
<p>对于可能有bug的程序，Quick Spec可以给出一种insight来揭示程序的性质。并且我们可以通过检查这些性质来查看程序设计是否符合我们的预期。</p>
]]></content>
      <categories>
        <category>技术视野</category>
      </categories>
      <tags>
        <tag>Programming Language</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机网络集群配置</title>
    <url>/Blog/2022/11/30/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>本文主要记录使用虚拟机搭建网络集群时的基本流程。所使用的环境为</p>
<ul>
<li>宿主机：Win11，amd芯片</li>
<li>软件：VirtualBox 6.1</li>
<li>虚拟机镜像：Centos 7.9，下载源</li>
</ul>
<h4 id="虚拟机网卡配置"><a href="#虚拟机网卡配置" class="headerlink" title="虚拟机网卡配置"></a>虚拟机网卡配置</h4><p>配置两块网卡，一块Host-Only，一块NAT。</p>
<style>.jgmvchfuthsm{zoom: 75%;}</style><img src="/Blog/2022/11/30/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/006g42Mjgy1h8n1rbfcuyj30tz0f0q8e.jpg" class="jgmvchfuthsm" alt="image.jpg">

<style>.dtjyiludfnmp{zoom:75%;}</style><img src="/Blog/2022/11/30/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/image-20221201105014036.png" class="dtjyiludfnmp" alt="image-20221201105014036">

<p>为Host-Only网络使用的适配器<code>VirtualBox Host-Only Ethernet Adapter</code>配置ip和子网掩码，以及DHCP服务器</p>
<style>.wrkjfoihcovp{zoom: 50%;}</style><img src="/Blog/2022/11/30/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221201110653.png" class="wrkjfoihcovp" alt="image-20221201110809813">

<style>.ygeekvkcfbft{zoom:67%;}</style><img src="/Blog/2022/11/30/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/image-20221201112503584.png" class="ygeekvkcfbft" alt="image-20221201112503584">

<p>同时可以在主机中使用<code>ipconfig</code>查看是否设置成功</p>
<style>.qnctsiddeqsv{zoom: 67%;}</style><img src="/Blog/2022/11/30/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/image-20221201111404548.png" class="qnctsiddeqsv" alt="image-20221201111404548">

<h4 id="虚拟机网络设置"><a href="#虚拟机网络设置" class="headerlink" title="虚拟机网络设置"></a>虚拟机网络设置</h4><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vi</span> /etc/sysconfig/network-scripts/ifcfg-enp0s3</code></pre>

<p>在文件中做如下修改，没有的话就加入【这步的目的是固定IP地址】</p>
<ul>
<li>BOOTPROTO&#x3D;static</li>
<li>ONBOOT&#x3D;yes【可以把enp0s8也设为这个，这样开机也可以启动连接外网的网卡了】</li>
<li>IPADDR&#x3D;192.168.56.x【这里x为1~255，除了前面适配器和DHCP服务器的ip】</li>
</ul>
<p>重启网络服务</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">systemctl restart network <span class="token comment"># 或service network restart</span></code></pre>

<p>查看本机ip是否被修改为<code>192.168.56.x</code></p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ip</span> addr</code></pre>

<p>可以看到ip已经被成功修改</p>
<img src="/Blog/2022/11/30/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/image-20221201113804519.png" class="" title="image-20221201113804519">

<p>尝试ping外界(之前设置的DHCP服务器)</p>
<img src="/Blog/2022/11/30/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/image-20221201113924629.png" class="" title="image-20221201113924629">

<p>从主机建立SSH连接</p>
<style>.wsfjujriemvz{zoom:50%;}</style><img src="/Blog/2022/11/30/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/image-20221201114005279.png" class="wsfjujriemvz" alt="image-20221201114005279">

<p>可以发现已经能连通主机和虚拟机</p>
<h3 id="踩坑实录"><a href="#踩坑实录" class="headerlink" title="踩坑实录"></a>踩坑实录</h3><p>若执行<code>ip addr</code>时发现NAT网卡没能拿到ip，可以通过<code>ifup NAT网卡名</code>来启动网卡服务。</p>
<p>例如负责连接外网的是<code>enp0s8</code>，只有mac地址而没有ip地址，说明该网卡没有启动，用<code>ifup enp0s8</code>启动网卡即可。</p>
]]></content>
      <categories>
        <category>技术视野</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title>行业、公司、工作</title>
    <url>/Blog/2023/07/31/%E8%A1%8C%E4%B8%9A%E3%80%81%E5%85%AC%E5%8F%B8%E3%80%81%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="如何快速了解一个行业"><a href="#如何快速了解一个行业" class="headerlink" title="如何快速了解一个行业"></a>如何快速了解一个行业</h3><p>参考资料：<a href="https://www.bilibili.com/video/BV1Vg411z7YN">如何快速了解一个行业｜5分钟方法论+资料库｜附思维导图_哔哩哔哩_bilibili</a></p>
<h4 id="如何界定行业"><a href="#如何界定行业" class="headerlink" title="如何界定行业"></a>如何界定行业</h4><style>.esrvcakdnhpz{zoom: 33%;}</style><img src="/Blog/2023/07/31/%E8%A1%8C%E4%B8%9A%E3%80%81%E5%85%AC%E5%8F%B8%E3%80%81%E5%B7%A5%E4%BD%9C/%E8%A1%8C%E4%B8%9A%E7%9A%84%E5%88%86%E7%B1%BB.jpg" class="esrvcakdnhpz" alt="image-20230731110053768">

<h4 id="行业分析框架"><a href="#行业分析框架" class="headerlink" title="行业分析框架"></a>行业分析框架</h4><img src="/Blog/2023/07/31/%E8%A1%8C%E4%B8%9A%E3%80%81%E5%85%AC%E5%8F%B8%E3%80%81%E5%B7%A5%E4%BD%9C/%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6%E4%B8%8E%E6%80%9D%E8%B7%AF.jpg" class="" title="image-20230731110323899">

<p>行业规模对公司的营收有一定参考价值，规模越大的行业，公司的营收一般会越高。行业生命周期则体现公司的发展前景。行业结构能够体现新玩家进入行业的难度，例如垄断行业对新人就很不友好。</p>
<p>行业的上下游业态、资本市场的表现往往预示着哪些行业是投资风口行业。</p>
<h3 id="行业报告与数据怎么找"><a href="#行业报告与数据怎么找" class="headerlink" title="行业报告与数据怎么找"></a>行业报告与数据怎么找</h3><ol>
<li><p>行业报告</p>
<ul>
<li><p>各大咨询公司官网&#x2F;公众号-&gt;行业关键词</p>
</li>
<li><p>萝卜投研-&gt;研报-&gt;行业研究</p>
</li>
<li><p>艾瑞网-&gt;行业关键词</p>
</li>
<li><p>IT桔子-&gt;报告库-&gt;桔子原创</p>
</li>
<li><p>前瞻产业研究院-&gt;资源-&gt;报告</p>
</li>
<li><p>CBN Data-&gt;消费行业报告</p>
</li>
</ul>
<p>不过行业报告由于撰写者的原因也存在良莠不齐的情况，因此可以多关注客观数据资料</p>
</li>
<li><p>年报和招股书</p>
<ul>
<li><p>看行业龙头公司的资料</p>
<style>.rgauofqegljd{zoom:50%;}</style><img src="/Blog/2023/07/31/%E8%A1%8C%E4%B8%9A%E3%80%81%E5%85%AC%E5%8F%B8%E3%80%81%E5%B7%A5%E4%BD%9C/%E5%B9%B4%E6%8A%A5%E6%80%8E%E4%B9%88%E6%89%BE.jpg" class="rgauofqegljd" alt="image-20230731111326492">
</li>
<li><p><strong>年报</strong>中<strong>市场回顾</strong>部分可以帮助快速地了解过去一年市场的变化</p>
</li>
<li><p><strong>招股书</strong>中<strong>行业概览</strong>模块会从市场规模、竞争格局、产业链等角度全面评述</p>
</li>
</ul>
</li>
<li><p>宏观数据</p>
<ul>
<li>国家统计局</li>
<li>地方统计局</li>
<li>工业和信息化部</li>
<li>中国海关–进出口数据</li>
<li>国家知识产权局</li>
</ul>
</li>
<li><p>关键词搜索</p>
</li>
</ol>
<h3 id="如何快速了解一家公司"><a href="#如何快速了解一家公司" class="headerlink" title="如何快速了解一家公司"></a>如何快速了解一家公司</h3><p>参考资料：<a href="https://www.bilibili.com/video/BV1q84y1r7fE">如何快速了解一家公司｜6分钟方法论+资料库｜附思维导图_哔哩哔哩_bilibili</a></p>
<h4 id="看业务"><a href="#看业务" class="headerlink" title="看业务"></a>看业务</h4><p>即商业模式</p>
<img src="/Blog/2023/07/31/%E8%A1%8C%E4%B8%9A%E3%80%81%E5%85%AC%E5%8F%B8%E3%80%81%E5%B7%A5%E4%BD%9C/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F.jpg" class="" title="image-20230731113035005">

<p>业务流程：产品如何从无到有直到交付到用户手上</p>
<h4 id="看赛道"><a href="#看赛道" class="headerlink" title="看赛道"></a>看赛道</h4><p>上市公司：二级市场-市值、市盈率</p>
<p>独角兽&#x2F;小型企业：一级市场-融资热度、估值情况</p>
<p>以及之前分析行业等使用到的数据</p>
<h4 id="看业绩"><a href="#看业绩" class="headerlink" title="看业绩"></a>看业绩</h4><img src="/Blog/2023/07/31/%E8%A1%8C%E4%B8%9A%E3%80%81%E5%85%AC%E5%8F%B8%E3%80%81%E5%B7%A5%E4%BD%9C/%E7%9C%8B%E4%B8%9A%E7%BB%A9.jpg" class="" title="image-20230731113411209">

<h4 id="看团队"><a href="#看团队" class="headerlink" title="看团队"></a>看团队</h4><img src="/Blog/2023/07/31/%E8%A1%8C%E4%B8%9A%E3%80%81%E5%85%AC%E5%8F%B8%E3%80%81%E5%B7%A5%E4%BD%9C/%E7%9C%8B%E5%9B%A2%E9%98%9F.jpg" class="" title="image-20230731113658176">

<p>如果公司的股东中有一些行业龙头或PE&#x2F;VC等，都会给公司一定的帮助</p>
<h3 id="如何找一个好工作"><a href="#如何找一个好工作" class="headerlink" title="如何找一个好工作"></a>如何找一个好工作</h3><h4 id="工作性价比"><a href="#工作性价比" class="headerlink" title="工作性价比"></a>工作性价比</h4><p>“具体思路是大行业里找小方向，比如chatgpt属于ai大行业里面的一个方向，这个方向之前没有挣钱最近挣钱了，这种从研究到产业化的过程就是前沿。具体寻找的过程需要你多做研究，多读文献。”</p>
]]></content>
      <categories>
        <category>杂谈点滴</category>
      </categories>
      <tags>
        <tag>商业</tag>
      </tags>
  </entry>
  <entry>
    <title>重新审视一下过去</title>
    <url>/Blog/2023/09/24/%E9%87%8D%E6%96%B0%E5%AE%A1%E8%A7%86%E4%B8%80%E4%B8%8B%E8%BF%87%E5%8E%BB/</url>
    <content><![CDATA[<p>今日听闻某人，这里就用X代替吧，X竟然除了我以外还吊着几个人，这几位甚至到了有点抑郁的程度，不禁哑然失言。写这篇文章的时候心里只剩下细弱游丝的哀伤。回想过去心如枯槁、泗泪横流的经历，那个自以为人生至暗时刻的下午和晚上，那个用表演式的自律掩饰自己痛苦的暑假，原来只是顾影自怜式的哀伤。心中很是后悔为什么当时的自己竟然如此愿意相信一些人和事，如今只剩下满怀的荒唐和无奈。</p>
<p>其实故事早该结束在那个“绝情谷”的午后，所有的一切在沉默的利剑中消弭于尘土，像许许多多没有结果的故事一样，沦为记忆里为数不多的谈资。后面本不该节外生枝出太多变奏，让人对过往的旋律难以忘怀。万幸现在知道了也还行，一切都还有转机——心不算太死，我也不算太老。</p>
<p>所以向前看吧，期待所期待的一切，放心大胆去爱。那个我以为“真正值得去爱的人”事实上从未来过，那些臆想出来的情愫、倾诉中的共鸣，实则只是晕轮的美化。该把珍贵的爱都留给值得的人，愿意爱我的人。</p>
<p>所以这次真的再见了，没有丝毫不舍——<br>可以毫无负担地爱人。</p>
]]></content>
      <categories>
        <category>杂谈点滴</category>
      </categories>
      <tags>
        <tag>Love</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Kubernetes</title>
    <url>/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/</url>
    <content><![CDATA[<p>深入理解Kubernetes   张磊著</p>
<h3 id="第一章-云原生大事记"><a href="#第一章-云原生大事记" class="headerlink" title="第一章 云原生大事记"></a>第一章 云原生大事记</h3><ul>
<li>CloudFoundry公司开辟了PaaS(Platform as a Service)的市场，已有容器、沙箱等实现</li>
<li>来自于dotCloud公司Docker项目的发布颠覆了CloudFoundary复杂的打包流程，以image的概念将操作系统与文件目录打包到一起，从而可以快速地在任意机器部署环境</li>
<li>Docker在短时间内吸引了大量开发者，出现了一批以Docker为核心的项目，一般自称为CaaS(Container as a service)。之后dotCloud更名为Docker公司，并开发了Swarm项目，试图回到PaaS(因为有更多的商业机会)</li>
<li>由于众多开发者不满意Docker公司越来越大的话语权，因此多方协同之下成立了<code>OCI</code>(Open Container Initiative)，意在将容器运行时和镜像的实现剥离出Docker，但效果不大。然后Google、Red Hat又牵头成立了<code>CNCF</code>(Cloud Native Computing Foundation)基金会，为Kubernetes的发展提供了良好条件：<ul>
<li>Red Hat的众多开发者为项目提供了足够大的人力</li>
<li>Kubernetes在构建之初就在各层开放了众多插件接口，从而快速引入了一大批之后发挥重要作用的项目</li>
</ul>
</li>
<li>试图将开源项目封闭与自己产品的Docker公司没能击败Kubernetes，最终进行了商业转型，并将容器运行时部分<code>Containerd</code>捐赠给CDCF。</li>
</ul>
<h3 id="第二章-容器技术基础"><a href="#第二章-容器技术基础" class="headerlink" title="第二章 容器技术基础"></a>第二章 容器技术基础</h3><h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><p>启动一个容器，并执行<code>/bin/sh</code></p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> busybox /bin/sh</code></pre>

<p>可以发现在容器中，&#x2F;bin&#x2F;sh是PID为1的进程。Docker借助Linux的<code>Namespace</code>来进行<strong>内核资源的隔离</strong>，构建单独的进程空间，因此一个PID Namepsace中的进程在计算自己的PID号时只会在本空间下计算。</p>
<blockquote>
<p>除了PID Namespace，还有Mount，UTS，IPC，Network，User等Namespace，从而实现对进程相关资源的隔离。实际上所有的计算和资源都是原来机器上的，根本不像虚拟机的Hypervisor还需要模拟一套硬件系统。</p>
</blockquote>
<p>当然这种os<strong>障眼法式</strong>的隔离在提供了敏捷和便利的同时也带来了非常大的安全问题，例如一些危险的系统调用等等。</p>
<h4 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h4><p>Docker借助Linux的<code>Cgroups</code>来<strong>限制容器进程组可用的资源</strong>，包括CPU、内存、磁盘、网络带宽等</p>
<p>Cgoups将资源限制以挂载文件的形式表示，一般在<code>/sys/fs/cgroup/xx</code>下，例如可以在<code>cpu</code>项下新建一个文件夹，在其中写入相关的配置，并将进程号写入对应<code>tasks</code>文件中。</p>
<p>这些资源限制在使用docker run命令时就可以指定，直接写入子系统文件中。</p>
<blockquote>
<p>Cgroups并未对<code>/proc</code>文件系统做限制，因此在容器中甚至可以读取其中文件查看宿主机的信息，这无疑是非常危险的。</p>
</blockquote>
<h4 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h4><p>在进程被<code>clone</code>之初，所有的信息，例如文件目录都继承于父进程(即便是有Mount Namespace也是继承了父进程的)，因此需要对其进程<strong>重挂载</strong>的操作。Linux提供了<code>chroot</code>命令来对进程启动时的根目录进行重新挂载(Docker实际会使用功能类似的<code>pivot_root</code>)</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">chroot</span> <span class="token variable">$new_path</span> /bin/bash</code></pre>

<p>而Mount Namespace就是根据chroot改进而来的。</p>
<p>所以一般来说，在容器启动时，会为其挂载一份完整的文件系统。但是操作系统的内核还是在机器启动时载入内存的，因此容器中的os文件<strong>只有外壳，而没有灵魂</strong>，实际上用的内核资源还是原来的。因此对内核的所有操作，实际上会影响所有共享这些资源的进程。</p>
<p>我们看到，一个容器实际上包含一整个rootfs，那么倘若需要对其做出少量有意义更改，是否需要另外打包出一份文件呢？实际上Docker利用<code>AuFS</code>(Advanced unionFS，在Linux UnionFS上改进的版本)来将不同的文件挂载到某个目录下，以实现<strong>layer</strong>的概念。增量更新只需要用挂载就可以实现不同版本的rootfs了！</p>
<p>实际实现时，Docker会将所有的增量联合挂载在<code>/var/lib/docker/aufs/mnt/&lt;ID&gt;</code>。</p>
<p>rootfs实际上分为多个层级</p>
<table>
<thead>
<tr>
<th>层</th>
<th>权限</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>可读写层</td>
<td>rw</td>
<td>可以增加文件或“删除”只读层的文件(增量式的遮挡)</td>
</tr>
<tr>
<td>Init层</td>
<td>ro+wh(write out)</td>
<td>Init容器时os中需要修改的一部分，例如<code>/ect/hosts</code>等，单独从只读层拿出来形成一层</td>
</tr>
<tr>
<td>只读层</td>
<td>ro+wh</td>
<td>5层(5个文件夹)增量os文件</td>
</tr>
</tbody></table>
<h4 id="Linux容器实战"><a href="#Linux容器实战" class="headerlink" title="Linux容器实战"></a>Linux容器实战</h4><blockquote>
<p>中国用户请为docker的deamon加上如下配置项实现换源：</p>
<pre class="language-json" data-language="json"><code class="language-json"><span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
   <span class="token string">"http://hub-mirror.c.163.com"</span><span class="token punctuation">,</span>
   <span class="token string">"https://docker.mirrors.ustc.edu.cn/"</span>
 <span class="token punctuation">]</span></code></pre>
</blockquote>
<p>Dockerfile原语</p>
<table>
<thead>
<tr>
<th>原语</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FROM …</td>
<td>使用某个基础镜像</td>
</tr>
<tr>
<td>ADD src dst</td>
<td>将<strong>容器外</strong>src目录下所有内容复制到<strong>容器中</strong>dst目录下</td>
</tr>
<tr>
<td>WORKDIR …</td>
<td>将工作目录切换到容器中的…目录，用RUN cd … 无法起到相同效果</td>
</tr>
<tr>
<td>RUN …</td>
<td>执行一条shell命令</td>
</tr>
<tr>
<td>EXPOSE …</td>
<td>向外界暴露容器端口</td>
</tr>
<tr>
<td>ENV … …</td>
<td>设置环境变量</td>
</tr>
<tr>
<td>CMD [“…”, “…”]</td>
<td>入口ENTRYPOINT的参数，默认ENTRYPOINT隐藏入口为<code>/bin/sh -c</code>。<br />可以将shell命令与参数放入列表，用于容器启动。如果没有CMD则需启动时指定要执行的进程。</td>
</tr>
</tbody></table>
<ul>
<li><p>规定好Dockerfile后，在目录下执行命令进行helloworld镜像的搭建</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> build <span class="token parameter variable">-t</span> helloworld <span class="token builtin class-name">.</span> </code></pre>
</li>
<li><p>用一个容器运行该镜像，并把本机5000端口映射到容器80端口</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token number">5000</span>:80 helloworld</code></pre>
</li>
<li><p>在容器内运行指令(比如&#x2F;bin&#x2F;sh)</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token variable">$&#123;container_id&#125;</span> /bin/sh</code></pre>

<p>  Docker如何实现进入容器呢？(即怎么使一个新的进程加入某个namespace)？在容器进程对应的<code>/proc/$&#123;pid&#125;/ns/...</code>有对应的ns文件，Linux提供<code>setns()</code>函数来打开一个ns文件并将当前进程加入对应Namespace。另外，也可以在run时指定<code>--net</code>来加入某个容器的net Namespace。</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--net</span> container:<span class="token variable">$&#123;container_id&#125;</span> <span class="token variable">$&#123;image_name&#125;</span> <span class="token variable">$&#123;cmd&#125;</span></code></pre>

<p>  当指定<code>--net=host</code>则会加入主机net Namespace。</p>
</li>
<li><p>将正在运行的容器打包更新某镜像</p>
  <pre class="language-shell'" data-language="shell'"><code class="language-shell'">docker commit $&#123;container_id&#125; helloworld</code></pre>
<p>  实际操作就是在可读写层进行写入和write out操作从而对镜像进行修改</p>
</li>
</ul>
<h4 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h4><p>docker可以利用volume将宿主机的目录挂载到容器中</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-v</span> /test <span class="token punctuation">..</span>. <span class="token comment"># 会在宿主机创建一个临时文件夹并挂载到容器/test</span>
<span class="token function">docker</span> run <span class="token parameter variable">-v</span> <span class="token punctuation">..</span>.:/test <span class="token punctuation">..</span>. <span class="token comment"># 会将宿主机的...目录挂载到容器/test</span></code></pre>

<p>上文讲过，虽然有Mount Namespace的存在，但是进程创建之初，文件系统的挂载与宿主机是一模一样的，因此在没有修改根目录之前，容器可以看到宿主机上所有文件和挂载，因此只需要在chroot之前使用Linux的<code>bind mount</code>机制将目录挂载即可(本质上就是指向同一个inode)，此时由于Mount Namespace的存在，宿主机并不会看到容器的挂载。</p>
<h3 id="第三章-Kubernetes设计与架构"><a href="#第三章-Kubernetes设计与架构" class="headerlink" title="第三章 Kubernetes设计与架构"></a>第三章 Kubernetes设计与架构</h3><style>.sfxbkdmeuqlu{zoom: 33%;}</style>

<p>Kubernetes起源于谷歌技术栈最底层的<code>Brog</code>，从设计之初就借鉴了Brog的经验。master节点负责调度，node节点负责计算。在master节点上，有三个核心部件：负责API的<code>kube-apiserver</code>、负责调度的<code>kube-scheduler</code>以及负责容器编排的<code>kube-controller-manager</code>。计算节点上，核心功能就是<code>kubelet</code>，它能够通过<code>CRI</code>(容器运行时接口)进行对容器的远程调用。</p>
<p>以统一的方式抽象底层基础设施能力(计算、存储、网络)，定义任务编排的各种关系(亲密关系，访问关系、代理关系)，将这些抽象以声明式API的方式对外暴露，从而允许平台构建者基于这些抽象进一步<strong>构建自己的PaaS乃至任何上层平台</strong>。</p>
<p>Kubernetes将需要频繁交互的容器划分进一个<code>Pod</code>，这些容器共享Network Namespace以及Volume，能够高效地交换信息。同时定义出了</p>
<ul>
<li>Pod，Job，CronJob等任务编排对象，描述试图管理的应用</li>
<li>Service，Ingress，Horizontal Pod Autoscalar等运维能力对象，进行具体的运维</li>
</ul>
<p>实际使用时仅仅需要编写配置文件，这就是<strong>声明式API</strong></p>
<h3 id="第四章-Kunernetes集群搭建与配置"><a href="#第四章-Kunernetes集群搭建与配置" class="headerlink" title="第四章 Kunernetes集群搭建与配置"></a>第四章 Kunernetes集群搭建与配置</h3><h4 id="kubeadm"><a href="#kubeadm" class="headerlink" title="kubeadm"></a>kubeadm</h4><blockquote>
<p>注：kubeadm在中国难以使用，推荐用kubeasz进行安装，详情请参考另一篇博客</p>
</blockquote>
<p>诞生于2017年，解决kubernetes在部署时需要编译出每个组件以及进行繁琐配置的问题。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">kubeadm init <span class="token comment"># 创建一个master节点</span>
kubeadm <span class="token function">join</span> <span class="token operator">&lt;</span>master节点的IP和端口<span class="token operator">></span> <span class="token comment"># 加入一个node节点</span></code></pre>

<p>为何不用容器部署kubernetes镜像呢？容器受限于Namespace创建的隔离景象，难以直接操作宿主机。</p>
<blockquote>
<p>中国用户如何安装kubeadm？</p>
<p>环境：ubuntu 22.04</p>
<ul>
<li><p>添加阿里源</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main"</span> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/apt/sources.list.d/kubernetes.list</code></pre>
</li>
<li><p>尝试<code>sudo apt-get update </code>，如果出现<code>GPG error,... No public key ...</code>错误，将此处公钥内容填写到下方命令中</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> gpg <span class="token parameter variable">--keyserver</span> keyserver.ubuntu.com <span class="token parameter variable">--recv</span> <span class="token variable">$&#123;public_key&#125;</span>
<span class="token function">sudo</span> gpg <span class="token parameter variable">--export</span> <span class="token parameter variable">--armor</span> <span class="token variable">$&#123;public_key&#125;</span> <span class="token operator">|</span> <span class="token function">sudo</span> apt-key <span class="token function">add</span> -</code></pre>
</li>
<li><p>再次尝试<code>sudo apt-get update</code>，成功后<code>sudo apt-get install kubeadm</code>(包含了kubeadm, kubelet和kubectl)</p>
</li>
</ul>
</blockquote>
<p>kubeadm的工作流程</p>
<ul>
<li><p><code>kubeadm init</code></p>
<ul>
<li>Preflight Check：检查内核等诸多依赖和资源是否可用</li>
<li>生成各种证书(位于master节点的<code>/ect/kubernetes/pki</code>下，用于Https通信等)和目录</li>
<li>生成其余组件访问kube-apiserver的配置文件(位于<code>/ect/kubernetes/xxx.conf</code>)</li>
<li>为master组件生成Pod配置文件，以<code>Static Pod</code>的方式被部署(将配置文件放入特定目录<code>/ect/kubernetes/manifests</code>，当<strong>kuberlet</strong>启动时会加载并启动目录中的容器)</li>
<li>master容器启动后，kubeadm检查<code>localhost:6443/healthz</code>组件的健康来检查URL</li>
<li>生成<code>booststrap token</code>供新节点加入集群</li>
</ul>
</li>
<li><p><code>kubeadm join</code></p>
<ul>
<li><p>为了和kube-apiserver进行交互，至少要进行一次不安全通信，此时为了自动化地建立可信连接，因此使用bootstrap token进行安全验证</p>
<blockquote>
<p>kubeadm join是由用户发起的，因此是可信的</p>
</blockquote>
</li>
<li><p>第一次通信后拿到了安全证书等等，新节点上的kubelet就可以与apiserver进行安全交互了</p>
</li>
</ul>
</li>
</ul>
<p>使用<code>kubeadm init --config xx.yaml</code>以自定义各个组件的参数配置等</p>
<h4 id="k8s应用"><a href="#k8s应用" class="headerlink" title="k8s应用"></a>k8s应用</h4><p>一个描述需要部署的容器的yaml样例</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment <span class="token comment">#该API对象的类型是Deployment，可以管理多个Pod副本并滚动更新应用</span>
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deployment
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span> <span class="token comment">#管理2个Pod副本，共3个Pod</span>
  <span class="token key atrule">template</span><span class="token punctuation">:</span>   <span class="token comment">#描述Pod副本的内容</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>
        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">containers</span><span class="token punctuation">:</span> <span class="token comment">#Pod所包含的容器列表</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.7.9 <span class="token comment">#容器所用的镜像</span>
        <span class="token key atrule">ports</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>
      <span class="token key atrule">volumes</span><span class="token punctuation">:</span> <span class="token comment">#Pod所包含的Volume列表</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>vol
        <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>
          <span class="token key atrule">path</span><span class="token punctuation">:</span> /var/data <span class="token comment">#宿主机将被使用的目录，可以在Pod中使用volumeMounts来挂载，以及mountPath来指定挂载路径</span></code></pre>

<p>可以通过<code>kubectl create -f 配置文件.yaml</code>进行API对象的创建，以及<code>kubectl replace -f 配置文件.yaml</code>进行API对象的更新。</p>
<p>推荐使用<code>kubectl apply -f 配置文件.yaml</code>统一处理</p>
<blockquote>
<p>因此当应用发生变化时更新镜像即可，当编排发生变化时更新配置文件即可</p>
</blockquote>
<p>使用<code>kubectl delete -f 配置文件.yaml</code>删除API对象</p>
<h3 id="第五章-Kubernetes编排原理"><a href="#第五章-Kubernetes编排原理" class="headerlink" title="第五章 Kubernetes编排原理"></a>第五章 Kubernetes编排原理</h3><h4 id="为什么需要Pod"><a href="#为什么需要Pod" class="headerlink" title="为什么需要Pod"></a>为什么需要Pod</h4><p>预先建立<strong>逻辑上</strong>的“组”，然后成组地调度容器，这样可以避免资源不足带来的死锁或者回滚机制带来的复杂度。</p>
<p>所谓逻辑上的组，有两点</p>
<ul>
<li>共享网络</li>
<li>共享Volume</li>
</ul>
<p>这可以通过加入Namespace的方式来实现。</p>
<p>为了体现Pod内容器的<strong>公平性</strong>，每个Pod先建立一个<strong>Infra容器</strong>，然后让其他容器加入它。</p>
<p>可以说，<strong>Pod就是Infra</strong>，生命周期、网络都与Infra无异</p>
<p>一个使用Pod来组合war程序包与tomcat服务器的例子：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> javaweb
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">initContainers</span><span class="token punctuation">:</span> <span class="token comment">#整体执行上先于后面containers包含的容器，里面包含的容器按照先后顺序依次执行</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> geektime/sample<span class="token punctuation">:</span>v2
    <span class="token key atrule">name</span><span class="token punctuation">:</span> war
    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"cp"</span><span class="token punctuation">,</span> <span class="token string">"/sample.war"</span><span class="token punctuation">,</span> <span class="token string">"/app"</span><span class="token punctuation">]</span> <span class="token comment">#将文件拷贝到app目录</span>
    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /app
      <span class="token key atrule">name</span><span class="token punctuation">:</span> app<span class="token punctuation">-</span>volume <span class="token comment">#将app-volume挂载到app目录上</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> geektime/tomcat<span class="token punctuation">:</span><span class="token number">7.0</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> tomcat
    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"/root/apache-tomcat-7.0.42-v2/bin/shart.sh"</span><span class="token punctuation">]</span>
    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /root/apache<span class="token punctuation">-</span>tomcat<span class="token punctuation">-</span>7.0.42<span class="token punctuation">-</span>v2/webapps
      <span class="token key atrule">name</span><span class="token punctuation">:</span> app<span class="token punctuation">-</span>volume <span class="token comment">#将app-volume挂载到webapps目录上，实现文件共享</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>
      <span class="token key atrule">hostPort</span><span class="token punctuation">:</span> <span class="token number">8081</span> 
  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> app<span class="token punctuation">-</span>volume
    <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">#用临时空文件夹初始化app-volume</span></code></pre>

<h4 id="深入解析Pod对象"><a href="#深入解析Pod对象" class="headerlink" title="深入解析Pod对象"></a>深入解析Pod对象</h4><p><code>spec</code>下一些重要的字段：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span> <span class="token comment">#只会被调度到携带了这对键值对标签的node上去</span>
    <span class="token key atrule">key</span><span class="token punctuation">:</span> value
  <span class="token key atrule">nodeName</span><span class="token punctuation">:</span> <span class="token punctuation">...</span> <span class="token comment">#默认由调度器来设置，如果设置了，调度时将会忽略该对象(y)</span>
  <span class="token key atrule">hostAliases</span><span class="token punctuation">:</span> <span class="token comment">#定义Pod的hosts文件的内容</span>
  <span class="token punctuation">-</span> <span class="token key atrule">ip</span><span class="token punctuation">:</span> <span class="token string">"...."</span>
    <span class="token key atrule">hostnames</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token string">"..."</span>
    <span class="token punctuation">-</span> <span class="token string">"..."</span>
  <span class="token key atrule">shareProcessNamespace</span><span class="token punctuation">:</span> true/false <span class="token comment">#是否Pod间共享PID Namespace</span>
  <span class="token key atrule">hostNetwork</span><span class="token punctuation">:</span> true/false <span class="token comment">#是否共享主机网络</span>
  <span class="token key atrule">hostIPC</span><span class="token punctuation">:</span> true/false <span class="token comment">#是否共享主机IPC</span>
  <span class="token key atrule">hostPID</span><span class="token punctuation">:</span> true/false <span class="token comment">#是否共享主机PID</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span> <span class="token comment">#定义包含的容器</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
    <span class="token key atrule">imagePullPolocy</span><span class="token punctuation">:</span> always <span class="token comment">#这是缺省值，可以改为never或ifNotPresent</span>
    <span class="token key atrule">lifecycle</span><span class="token punctuation">:</span> <span class="token comment">#定义容器状态变化时的hooks</span>
      <span class="token key atrule">postStart</span><span class="token punctuation">:</span> <span class="token comment">#容器被启动之后，但可能此时ENTRYPOINT还没有结束(异步)</span>
        <span class="token key atrule">exec</span><span class="token punctuation">:</span>
          <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">...</span><span class="token punctuation">]</span>
      <span class="token key atrule">preStop</span><span class="token punctuation">:</span> <span class="token comment">#一定在容器停止之前执行完毕(同步)</span>
        <span class="token punctuation">...</span></code></pre>

<h4 id="Pod对象使用进阶"><a href="#Pod对象使用进阶" class="headerlink" title="Pod对象使用进阶"></a>Pod对象使用进阶</h4><p><strong>Projected Volume</strong>：这种volume为容器提供预先定制的数据</p>
<ul>
<li><p>Secret</p>
<p>可以帮你把Pod要访问的加密数据<strong>存放到etcd中</strong></p>
<p>创建Secret对象：</p>
<ul>
<li><p><code>kubectl create secret generic $&#123;name&#125; --from-file=$&#123;filename&#125;</code>，将name对应的value放到filename中，这里的value是<strong>明文</strong></p>
</li>
<li><p>也可以使用yaml文件来创建</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret
<span class="token key atrule">type</span><span class="token punctuation">:</span> Opaque
<span class="token key atrule">data</span><span class="token punctuation">:</span>
  <span class="token key atrule">key</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>value<span class="token punctuation">&#125;</span> <span class="token comment">#这里是经过base64加密的密文</span>
  <span class="token punctuation">...</span></code></pre></li>
</ul>
<p>通过<code>kubectl get secrets</code>直接看到所有的Secret对象</p>
<p>使用Secret对象：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">volumes</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
  <span class="token key atrule">projected</span><span class="token punctuation">:</span> <span class="token comment">#类型不为emptyDir，也不为hostPath，而是projected</span>
    <span class="token key atrule">sources</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">secret</span><span class="token punctuation">:</span>
      <span class="token key atrule">name</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>name<span class="token punctuation">&#125;</span> <span class="token comment">#刚刚创建的secret的名称</span></code></pre>

<p>最后在挂载点会有name对应的文件，文件内容为value，并且是与etcd一致实时更新的</p>
</li>
<li><p>ConfigMap</p>
<p>和secret类似，但是是明文内容</p>
<p>创建ConfigMap对象：</p>
<ul>
<li><code>kubectl create configmap $&#123;name&#125; --from-file=$&#123;filename&#125;</code>，文件中每行为key&#x3D;value格式</li>
</ul>
<p>通过<code>kubectl get configmaps $&#123;name&#125; -o yaml</code>以yaml形式显示name的configmap</p>
</li>
<li><p>DownwardAPI</p>
<p>让Pod中的容器可以直接获取Pod的信息</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">volumes</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
  <span class="token key atrule">projected</span><span class="token punctuation">:</span>
    <span class="token key atrule">sources</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">downwardAPI</span><span class="token punctuation">:</span>
      <span class="token key atrule">items</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>path<span class="token punctuation">&#125;</span> <span class="token comment">#位于$&#123;挂载点&#125;/$&#123;path&#125;内</span>
        <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span> <span class="token comment">#还可以使用resourceFieldRef</span>
          <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> <span class="token punctuation">...</span> <span class="token comment">#具体条目请参考官方文档</span></code></pre>
</li>
<li><p>ServiceAccountToken</p>
<p>一个特殊的Secret。默认情况下，k8s为每一个Pod挂载了一个Secret Volume，存储Service Account Token用以操作k8s API本身，名字为**default-token-…**。service account是具有一定权限，例如get&#x2F;write的账户</p>
</li>
</ul>
<p><strong>restartPolocy</strong>：当<strong>容器</strong>出现异常后，Pod会重新创建这个容器</p>
<blockquote>
<p>只有Pod里的所有容器都出现异常以后，Pod才会出现异常，否则为Running，并在Ready字段显示可用容器数</p>
</blockquote>
<p>定义路径在pod.spec.restartPolicy，可选值为Always【默认】&#x2F;OnFailure&#x2F;Never</p>
<p>例如一次性执行的容器Pod就没必要设为always</p>
<blockquote>
<p>可以通过<code>kubectl describe pod ...</code>来查看Pod的信息，如果出现了fail&amp;restart等情况，在event字段里会有记录</p>
</blockquote>
<p><strong>PodPreset</strong>：用于预置一些Pod的配置，方便直接再预定义上直接修改</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> settings.k8s.io/v1alpha1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> PodPreset <span class="token comment">#PodPreset类型</span>
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> allow<span class="token punctuation">-</span>database
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
      $<span class="token punctuation">&#123;</span>label<span class="token punctuation">&#125;</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>value<span class="token punctuation">&#125;</span> <span class="token comment">#Preset要作用的Pod</span>
  <span class="token key atrule">env</span><span class="token punctuation">:</span> <span class="token comment">#定义一些环境变量</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> DB_PORT
    <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"6379"</span>
  <span class="token punctuation">...</span></code></pre>

<p>使用方式：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">kubectl create <span class="token parameter variable">-f</span> <span class="token variable">$&#123;preset file&#125;</span>
kubectl create <span class="token parameter variable">-f</span> <span class="token variable">$&#123;file&#125;</span> <span class="token comment">#label与preset的spec规定一致</span></code></pre>

<p>当同时使用多个preset后，后面的会拓展前面的，但不会覆盖相同字段</p>
<h4 id="“控制器”思想"><a href="#“控制器”思想" class="headerlink" title="“控制器”思想"></a>“控制器”思想</h4><p>控制器会执行一个循环，当发现相关Pod状态与预期不符时，会执行一些纠正操作。例如Deployment会按相关Pod的副本数是否为给定值，少则补充多则删除。其yaml文件大多为控制器定义+template的格式</p>
<h4 id="作业副本与水平拓展"><a href="#作业副本与水平拓展" class="headerlink" title="作业副本与水平拓展"></a>作业副本与水平拓展</h4><p>Deployment实际上控制的是ReplicaSet这个API对象(由deployment自动生成)，由它继而控制下属的Pod。</p>
<p>想要水平拓展的话，可以通过<code>kubectl scale deployment $&#123;name&#125; --replicas=$&#123;num&#125;</code>来修改Pod副本的个数</p>
<p>使用<code>kubectl edit deployment/$&#123;name&#125;</code>可以修改etcd中配置文件【例如Pod中容器的定义】，之后自动进行滚动更新</p>
<blockquote>
<p>背后的下载配置文件以及再次提交是自动完成的</p>
</blockquote>
<p>更新时，会生成一个新的ReplicaSet，老的里kill一个Pod，新的里创建一个Pod，如此滚动更新</p>
<p>可以配置允许离线的Pod数，默认值为总数目(replica+1)的25%</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>
  <span class="token key atrule">strategy</span><span class="token punctuation">:</span>
    <span class="token key atrule">type</span><span class="token punctuation">:</span> RollingUpdate
    <span class="token key atrule">roolingUpdate</span><span class="token punctuation">:</span>
      <span class="token key atrule">maxSurge</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment">#依次滚动更新可以创建的Pod数</span>
      <span class="token key atrule">maxUnavaliable</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment">#(3+1)的25%</span></code></pre>

<p>版本回滚：</p>
<ul>
<li><p>回滚当然也会创建新的ReplicaSet，所以如果不希望有很多新的set出现，可以使用<code>kubectl rollout pause</code>来暂停动态更新，修改完之后再执行<code>kubectl rollout resume</code>来恢复，最终只会执行一次动态更新</p>
<blockquote>
<p>可以通过<code>spec.revisionHistoryLimit</code>来设置历史保留的ReplicaSet的数目</p>
</blockquote>
</li>
<li><p>使用<code>kubectl rollout history</code>查看历史出现过的版本</p>
<blockquote>
<p>创建Deployment时加上–reocrd参数会记录导致版本变化的kubectl命令</p>
</blockquote>
</li>
<li><p>使用<code>kubectl rollout history deployment/$&#123;name&#125; --to-version=$&#123;version&#125;</code>回滚到某一版本</p>
</li>
</ul>
<h4 id="深入理解StatefulSet：拓扑状态"><a href="#深入理解StatefulSet：拓扑状态" class="headerlink" title="深入理解StatefulSet：拓扑状态"></a>深入理解StatefulSet：拓扑状态</h4><p>实例之间有<strong>不对等关系</strong>，实例对外部数据有<strong>依赖关系</strong>的应用称为<strong>有状态应用</strong></p>
<p>Service是k8s将一组Pod暴露给外界的一种方式，主要有这样几种</p>
<ul>
<li>VIP(virtual IP)的方式，访问ip后请求被转发到service的Pod</li>
<li>DNS方式<ul>
<li>解析为VIP</li>
<li>解析为Pod的IP</li>
</ul>
</li>
</ul>
<p>Headless Service：没有VIP头的Service</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> web
  <span class="token key atrule">clusterIP</span><span class="token punctuation">:</span> None <span class="token comment">#没有定义VIP</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx <span class="token comment">#Service为有这个label的Pod做代理</span></code></pre>

<p>然后所有被代理的Pod将会被绑定到DNS记录<code>$&#123;pod-name&#125;.$&#123;service-name&#125;.$&#123;namespace&#125;.svc.cluster.local</code>上【有时后面的cluster.local等等会被省略】</p>
<p>一个StatefulSet使用Service的例子，可以看到与deployment非常相似</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> StatefulSet
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> web
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> <span class="token string">"nginx"</span>
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx
  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token punctuation">...</span></code></pre>

<p>StatefulSet会为这些Pod分配编号，并且Pod的网络身份(hostname等)也与编号严格对应</p>
<blockquote>
<p>所以Pod有更新后，IP可能会变，但是DNS记录不会变。有状态应用都应该使用DNS记录或者hostname</p>
</blockquote>
<h4 id="深入理解StatefulSet：存储状态"><a href="#深入理解StatefulSet：存储状态" class="headerlink" title="深入理解StatefulSet：存储状态"></a>深入理解StatefulSet：存储状态</h4><p>将存储系统解耦合，分为接口和实现，一方面便于在不了解存储系统的情况下快速搭建集群应用，另一方面减少存储系统关键信息的暴露。</p>
<p>接口部分，使用PVC(Persistent Volume Claim)，描述需要的Volume的特征</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVokumeClaim
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv<span class="token punctuation">-</span>pod
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">accessMode</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> ReadWriteOnce <span class="token comment">#可读写权限，只能被挂载在一个节点上</span>
  <span class="token key atrule">resources</span><span class="token punctuation">:</span>
    <span class="token key atrule">requests</span><span class="token punctuation">:</span>
      <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi <span class="token comment">#Volume大小至少为1GiB</span></code></pre>

<p>实现部分，使用PV(Persistent Volume)</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv<span class="token punctuation">-</span>volume
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">type</span><span class="token punctuation">:</span> local
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">capacity</span><span class="token punctuation">:</span> 10Gi
  <span class="token punctuation">...</span> <span class="token comment">#具体的存储系统的信息，例如服务器地址，授权文件等等</span></code></pre>

<p>使用样例：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">volumes</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span> <span class="token comment">#自己起的，与上面volumeMount对应</span>
  <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span>
    <span class="token key atrule">claimName</span><span class="token punctuation">:</span> pv<span class="token punctuation">-</span>claim</code></pre>

<p>k8s为根据声明自动查找满足条件的PV进行挂载。</p>
<p>StatefulSet也可以定义PVC的template，从而为每个Pod配一个PVC【使用时也是Pod使用对应PVC】</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token key atrule">containers</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> www
        <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
  <span class="token key atrule">volumeClaimTemplates</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">name</span><span class="token punctuation">:</span> www
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token punctuation">...</span></code></pre>

<p>此时如果Pod异常挂了，新起起来的Pod依然会继承之前Pod的PVC，而那个PVC对应的PV也是之前的，所以存储内容会原原本本地继承下来</p>
<h4 id="容器化守护进程：DaemonSet"><a href="#容器化守护进程：DaemonSet" class="headerlink" title="容器化守护进程：DaemonSet"></a>容器化守护进程：DaemonSet</h4><p>每个节点上运行且只运行一个DeamonPod，Pod的生命周期与节点保持同步</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> app/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> DaemonSet
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
      <span class="token key atrule">name</span><span class="token punctuation">:</span> aaa
  <span class="token key atrule">template</span><span class="token punctuation">:</span> <span class="token comment">#定义Pod的内容</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>
        <span class="token key atrule">name</span><span class="token punctuation">:</span> aaa
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">tolerations</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span>role.kubernetes.io/master
        <span class="token key atrule">effect</span><span class="token punctuation">:</span> NoSchedule
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>
      <span class="token punctuation">...</span></code></pre>

<p>DaemonSet的API和Deployment很像，但是没有<strong>replicas</strong>字段，使用<code>selector</code>来管理携带指定label的Pod。</p>
<p>为了在<strong>指定节点</strong>上创建Pod(在其上删除很好做)，DaemonSet会自动在<strong>创建Pod时</strong>根据节点名字加上<code>nodeAffinity</code>属性(nodeSelector的进阶)，下面是一个单独使用nodeAffinity的样例</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kine</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>
    <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span>
      <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span> <span class="token comment">#在每次调度时考虑该affinity</span>
        <span class="token key atrule">nodeSelectorTerms</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> metadata.name
            <span class="token key atrule">operator</span><span class="token punctuation">:</span> in <span class="token comment">#操作符为部分匹配</span>
            <span class="token key atrule">values</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> bbb <span class="token comment">#用key来匹配这个value</span></code></pre>

<p>另外，DaemonSet也会为Pod加上指定的tolerations关键字来<strong>容忍</strong>带有<code>network-unavaliable</code>污点的节点，例如</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">tolerations</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> node.kubernetes.io/unschedulable <span class="token comment">#有unschedulable污点</span>
    <span class="token key atrule">operator</span><span class="token punctuation">:</span> Exists
    <span class="token key atrule">effect</span><span class="token punctuation">:</span> NoSchedule <span class="token comment">#调度规则，还有NoExecute等</span></code></pre>

<p>例如对于网络插件来说，在节点还没有被纳入网络时，仍然需要在该节点上建立用于控制的Pod，此时就需要容忍network-unavaliable的污点。</p>
<p>对于Deployment来说，其通过ReplicaSet来进行版本控制，而只有一个Pod的DaemonSet则通过<code>ControllerRevision</code>对象来进行版本控制。可以通过<code>kubectl get controllerVision</code>来看。实际上ContorllerRevision就是在其Data段记录了该版本的template。可以通过<code>kubectl rollout undo daemonset $&#123;name&#125; --to--revision=$&#123;version&#125; rolled back</code>。</p>
<p>回滚实际上做的是patch更新，一个新的ControllerRevision会被创建出来(版本号+1)。</p>
<h4 id="撬动离线业务：Job与CronJob"><a href="#撬动离线业务：Job与CronJob" class="headerlink" title="撬动离线业务：Job与CronJob"></a>撬动离线业务：Job与CronJob</h4><p>离线业务：也称为<strong>Batch</strong> Job(计算任务)，需要在计算结束以后自然退出。</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Job
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
        <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
        <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"..."</span><span class="token punctuation">]</span>
      <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never
  <span class="token key atrule">backOffLimit</span><span class="token punctuation">:</span> <span class="token number">4</span> <span class="token comment">#失败重启的最大次数</span>
  <span class="token key atrule">activeDeadlineSeconds</span><span class="token punctuation">:</span> <span class="token number">110</span> <span class="token comment">#运行时间不超过110秒</span></code></pre>

<p>通过describe可以看到Job对象的Pod模板被加上了一个controller-uid&#x3D;${随机字符串}的Label，而Job本身则有了一个该label的selector</p>
<p>Completed不会重启，Failed会重启。</p>
<p>也可以定义并行任务</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">parallelism</span><span class="token punctuation">:</span> <span class="token number">2</span> <span class="token comment">#最大并行数(同一时间有多少Pod可以同时运行，默认为1)</span>
      <span class="token key atrule">completions</span><span class="token punctuation">:</span> <span class="token number">4</span> <span class="token comment">#最小完成度(至少要完成的Pod数目)</span></code></pre>

<p>常用的使用方法：</p>
<ul>
<li><p>制定Job模板(在name部分使用变量)，然后使用外部管理器来指定变量从而创建Job</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># job-template.yaml</span>
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>$VAR
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token punctuation">...</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span></code></pre>

<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> a b c
<span class="token keyword">do</span>
  <span class="token function">cat</span> job-tempate.yaml <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">"s/\<span class="token variable">$VAR</span>/<span class="token variable">$i</span>"</span> <span class="token operator">></span> ./jobs/job-<span class="token variable">$i</span>.yaml <span class="token comment">#用sed命令将$var替换为这里的i</span>
<span class="token keyword">done</span>
kubectl create <span class="token parameter variable">-f</span> ./jobs <span class="token comment">#将文件夹内的yaml全部创建出来</span></code></pre>
</li>
<li><p>使用工作队列(例如使用外部程序作为生产者)进行任务分发，Job在指定并发度下进行消费，这种一般在completions固定的情况下使用</p>
</li>
<li><p>有并行度，但没有completions。这种需要为每个Pod制定退出的条件</p>
</li>
</ul>
<p><strong>CronJob</strong>：Job的控制器，定时任务</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v1beta1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> CronJob
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">schedule</span><span class="token punctuation">:</span> <span class="token string">"*/1 * * * *"</span> <span class="token comment">#空格分隔的五个部分分别代表分钟 小时 日 月 星期，/表示每，*表示0，1表示1个单位。意思是每一分钟执行一次</span>
  <span class="token key atrule">jobTemplate</span><span class="token punctuation">:</span>
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">template</span><span class="token punctuation">:</span>
        <span class="token key atrule">spec</span><span class="token punctuation">:</span>
          <span class="token punctuation">...</span>
  <span class="token key atrule">concurrencyPolicy</span><span class="token punctuation">:</span> Allow <span class="token comment">#Forbid跳过/Replace替换，表示上一次Job没结束，此次任务启动的策略</span>
  <span class="token key atrule">startingDeadlineSeconds</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span>interval<span class="token punctuation">&#125;</span> <span class="token comment">#interval秒内Job创建失败了100次，那么Job将不会再被创建</span></code></pre>

<h4 id="声明式API与Kubernetes编程范式"><a href="#声明式API与Kubernetes编程范式" class="headerlink" title="声明式API与Kubernetes编程范式"></a>声明式API与Kubernetes编程范式</h4><p>想要通过修改本地配置文件来修改一个对象，有两种方式，先编辑配置文件，然后</p>
<ul>
<li><p><code>kubectl replace -f $&#123;filename&#125;</code>：使用新的对象覆盖旧对象(命令式配置文件操作)</p>
<blockquote>
<p>对象之前是通过<code>kubectl create</code>创建出来的</p>
</blockquote>
</li>
<li><p><code>kubectl apply -f $&#123;filename&#125;</code>：对原对象执行了一次patch操作</p>
<blockquote>
<p>对象之前是通过<code>kubectl apply</code>创建出来的</p>
</blockquote>
</li>
</ul>
<p>patch操作(可以理解为merge地写)可以让对象有多个<strong>写</strong>端，从而能够并发地(k8s，插件，用户都有可能)进行修改。</p>
<p>以<code>Dynamic Admission Control</code>(<code>Initializer</code>)为例，它可以动态地做到对象在被k8s处理之前进行一些初始化工作：</p>
<ul>
<li><p>用configMap存储操作要用到的数据</p>
</li>
<li><p>先将一个编写好的initializer作为Pod</p>
</li>
<li><p>执行如下伪代码</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
    pod <span class="token operator">:=</span> <span class="token function">getLatestPod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">initialized</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        cm <span class="token operator">=</span> <span class="token function">getConfigMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        newPod <span class="token operator">=</span> <span class="token function">Pod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token function">change</span><span class="token punctuation">(</span>newPod<span class="token punctuation">,</span> cm<span class="token punctuation">)</span>
        
        patchBytes <span class="token operator">=</span> <span class="token function">CreateTwoWayMergePatch</span><span class="token punctuation">(</span>pod<span class="token punctuation">,</span> newPod<span class="token punctuation">)</span>
        client<span class="token punctuation">.</span><span class="token function">Patch</span><span class="token punctuation">(</span>patchBytes<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p>也可以自己配置操作对象的范围</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> admissionregisteration.k8s.io/v1alpha1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> InitializerConfiguration
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
<span class="token key atrule">initializer</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span> <span class="token comment">#名字至少需要包含两个.</span>
    <span class="token key atrule">rules</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> <span class="token string">""</span> <span class="token comment">#意思是Core API Group</span>
        <span class="token key atrule">apiVersions</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> v1
        <span class="token key atrule">resources</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> pods</code></pre>

<p>之后新的Pod会附带上metadata.initializers.pending，内容包含initializer的名字</p>
<blockquote>
<p>所以initializer根绝pending判断Pod有没有被初始化，以及初始化完之后要清除这个标志</p>
</blockquote>
<blockquote>
<p>当然也可以在Pod的metadata.annotations里著名initializer，例如</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>
   <span class="token key atrule">"initializer.kubernetes.io/envoy"</span><span class="token punctuation">:</span> <span class="token string">"true"</span>
   <span class="token punctuation">...</span></code></pre></blockquote>
</li>
</ul>
<h4 id="声明式API的工作原理"><a href="#声明式API的工作原理" class="headerlink" title="声明式API的工作原理"></a>声明式API的工作原理</h4><p>API对象在etcd中的完整路径由Group、Version和Resouce(API<strong>资源类型</strong>)三个部分组成，以树形结构组织，例如</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> batch/v2alpha
<span class="token key atrule">kind</span><span class="token punctuation">:</span> CronJob</code></pre>

<p>中，<code>batch</code>是Group，<code>v2alpha</code>是version，<code>CronJob</code>是Resource。对于Pod等核心api，直接按照version写的那样从&#x2F;api下面匹配即可(<code>/api/v1/pods</code>)，而对于其他非核心api，需要在&#x2F;apis下面匹配(<code>/apis/batch/v2alpha/cronjobs</code>)</p>
<p>POST请求创建API对象流程：</p>
<style>.pvdqcwryvoxu{zoom: 50%;}</style><img src="/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/86e52f8f403c4661a3dcdb1482b9ce1d.jpg" class="pvdqcwryvoxu">

<ol>
<li>经过过滤器过滤POST请求，完成授权等前置工作</li>
<li>经过MUX等，完成URL与Handler的绑定</li>
<li>处理该Post请求Handler的查找API对象的类型定义</li>
<li>将yaml文件<strong>转换</strong>为<code>Super Version</code>的对象(该API对象的所有版本的字段全集)，用来统一处理不同版本的yaml文件</li>
<li>Admission &amp; Validation(合法api对象被存入registry)</li>
<li>转换回原版本，序列化后存入etcd</li>
</ol>
<p>CRD的创建这部分书上代码不全且版本落后，具体例子可参考<a href="https://github.com/kubernetes/sample-controller">sample-controller</a></p>
<blockquote>
<p>apiextensions.k8s.io&#x2F;v1beata1 is deprecated in k8s v1.22.0 version.</p>
</blockquote>
<h4 id="API编程范式的具体原理"><a href="#API编程范式的具体原理" class="headerlink" title="API编程范式的具体原理"></a>API编程范式的具体原理</h4><img src="/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/8ea3266543164081af35dc4061d65cca.jpg" class="">

<p>控制器通过<code>Informer</code>获取它关心的对象。<code>Informer</code>通过<code>Reflector</code>包与APIServer建立链接，获取并监听对象的(增量)变化【例如增减对象就是通过Indexer控制的】，将其放入队列中。同时也不断从队列中读取对象【通过go routine建立若干个无限循环的协程】，根据增量类型<strong>修改informer的缓存</strong>，调用对应handler【使用neutron去修改真正的集群内容】。</p>
<blockquote>
<p>Informer往往响应迅速，而控制循环则可能会比较慢，因此用工作队列可以解耦二者</p>
</blockquote>
<h4 id="基于角色的权限控制：RBAC"><a href="#基于角色的权限控制：RBAC" class="headerlink" title="基于角色的权限控制：RBAC"></a>基于角色的权限控制：RBAC</h4><p>Role-based access control</p>
<ul>
<li>Role：角色，定义一组对API对象的操作权限</li>
<li>Subject：被作用者</li>
<li>RoleBinding：二者的绑定关系</li>
</ul>
<p>举例：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Role
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> mynamespace <span class="token comment">#通过namespace(逻辑上的管理单位，API对象默认为default)来指定产生作用的范围</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> example<span class="token punctuation">-</span>role
<span class="token key atrule">rules</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>
  <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"pods"</span><span class="token punctuation">]</span>
  <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">]</span> <span class="token comment">#还有create，update等等</span>
  <span class="token comment"># 需要指定某几个对象的话，可以用resourceNames: ["...", "..."]</span></code></pre>

<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> RoleBinding
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> mynamespace
  <span class="token key atrule">name</span><span class="token punctuation">:</span> example<span class="token punctuation">-</span>rolebinding
<span class="token key atrule">subjects</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> User <span class="token comment">#作用对象为User类型，即k8s的用户</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> exampe<span class="token punctuation">-</span>user
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io
<span class="token key atrule">roleRef</span><span class="token punctuation">:</span> <span class="token comment">#要绑定的Role</span>
  <span class="token key atrule">kind</span><span class="token punctuation">:</span> Role
  <span class="token key atrule">name</span><span class="token punctuation">:</span> example<span class="token punctuation">-</span>role <span class="token comment">#绑定之前定义的example-role</span>
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io</code></pre>

<p>对于非Namespaced的对象，比如Node等等，可以使用ClusterRole和ClusterRoleBinding，在metadata中不需要有namespace项</p>
<p>k8s的内置用户对象为<code>ServiceAccount</code>，更多时候我们直接使用它就可以了，而不需要使用<code>User</code></p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiversion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> mynamespace
  <span class="token key atrule">name</span><span class="token punctuation">:</span> example<span class="token punctuation">-</span>sa
<span class="token comment">#----------------------------</span>
<span class="token key atrule">kind</span><span class="token punctuation">:</span> RoleBinding
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> mynamespace
  <span class="token key atrule">name</span><span class="token punctuation">:</span> example<span class="token punctuation">-</span>rolebinding
<span class="token key atrule">subjects</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount
  <span class="token key atrule">name</span><span class="token punctuation">:</span> exampe<span class="token punctuation">-</span>sa
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> mynamespace
<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>
  <span class="token key atrule">kind</span><span class="token punctuation">:</span> Role
  <span class="token key atrule">name</span><span class="token punctuation">:</span> example<span class="token punctuation">-</span>role
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io</code></pre>

<p>创建完SA之后，k8s会自动生成一个secret对象。之后可以在Pod的<code>spec</code>中指定<code>serviceAccountName</code>，k8s会将证书文件挂载到容器内（namespace下没有声明SA的，会创建一个拥有大部分权限的default SA，因此生产环境中可以为default SA规定<strong>只读</strong>权限）。</p>
<p>同样，SA也有用户组的概念。SA在k8s中对应用户的名字为<code>system:serviceaccount:$&#123;name&#125;</code>，对应的用户组名字为<code>system:serviceaccounts:$&#123;namespace&#125;</code>。因此可以</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">subjects</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> Group
  <span class="token key atrule">name</span><span class="token punctuation">:</span> system<span class="token punctuation">:</span>serviceaccounts<span class="token punctuation">:</span>mynamespace <span class="token comment">#如果仅有system:serviceaccounts就是针对所有namespace</span>
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io</code></pre>

<p>四个内置ClusterRole：<code>cluster-admin</code>，<code>admin</code>，<code>edit</code>，<code>view</code></p>
<h4 id="聪明的微创新：Operator工作原理解读"><a href="#聪明的微创新：Operator工作原理解读" class="headerlink" title="聪明的微创新：Operator工作原理解读"></a>聪明的微创新：Operator工作原理解读</h4><p>Operator可以利用k8s的<strong>CRD</strong>来描述想要部署的<strong>有状态应用</strong>，然后在自定义控制器中定义具体的部署和运维工作。</p>
<h3 id="Kubernetes存储原理"><a href="#Kubernetes存储原理" class="headerlink" title="Kubernetes存储原理"></a>Kubernetes存储原理</h3><h4 id="持久化存储：PV和PVC的设计与实现原理"><a href="#持久化存储：PV和PVC的设计与实现原理" class="headerlink" title="持久化存储：PV和PVC的设计与实现原理"></a>持久化存储：PV和PVC的设计与实现原理</h4><p>PV和PVC和“面向对象”的思想非常类似，PVC就是<strong>接口</strong>，而具体的PV则是<strong>实现</strong></p>
<p>k8s内部的PersistentVolumeController会不断查看每个PVC是否处于Bound状态，并为未绑定的PVC遍历所有PV尝试绑定。</p>
<p>持久化Volume的目录<strong>不会因为容器的删除而被清理</strong>，也<strong>不会跟宿主机绑定</strong>，因此其实现往往依赖一个远程存储服务，例如NFS等等</p>
<blockquote>
<p>hostpath和emptyDir不具有这个特征，既可能被清理，也不能迁移到其他节点上</p>
</blockquote>
<p>一般来说，k8s准备持久化目录PV的过程分为两个阶段</p>
<table>
<thead>
<tr>
<th></th>
<th>远程块存储</th>
<th>远程文件存储</th>
</tr>
</thead>
<tbody><tr>
<td>阶段一(<strong>Attach</strong>)</td>
<td>在宿主机上挂载磁盘</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>阶段二(<strong>Mount</strong>)</td>
<td>将磁盘格式化后挂载到宿主机volume目录</td>
<td>将远程目录挂载到宿主机volume目录</td>
</tr>
</tbody></table>
<blockquote>
<p>PV的路径为<code>/var/lib/kubelet/pods/$&#123;pod id&#125;/volumes/kubernetes.io-$&#123;volume type&#125;/$&#123;name&#125;</code></p>
</blockquote>
<p>k8s也提供了可以自动创建PV的机制：<code>Dynamic Provisioning</code>(之前是<code>Static Provisioning</code>)，通过<code>StorageClass</code>来自动创建PV模板。</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> storage.k8s.io/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> StorageClass
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> block<span class="token punctuation">-</span>service
<span class="token key atrule">provisioner</span><span class="token punctuation">:</span> kubernetes.io/gce<span class="token punctuation">-</span>pd <span class="token comment">#要使用的存储插件，实际上PV是由存储插件生成的</span>
<span class="token key atrule">parameters</span><span class="token punctuation">:</span> <span class="token comment">#PV的相关属性</span>
  <span class="token key atrule">type</span><span class="token punctuation">:</span> pd<span class="token punctuation">-</span>ssd
<span class="token comment">#-----------------------------------------------</span>
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> claim1
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> ReadWriteOnce
  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> block<span class="token punctuation">-</span>service <span class="token comment">#由于StorageClass生成的PV也带有SC的name，所以让PVC和PV匹配是个容易的事情</span>
  <span class="token key atrule">resources</span><span class="token punctuation">:</span>
    <span class="token key atrule">requests</span><span class="token punctuation">:</span>
      <span class="token key atrule">storage</span><span class="token punctuation">:</span> 30Gi</code></pre>

<p>StorageClass并不仅仅用于Dynamic Provisioning，因为直接声明PV时给其StorageName属性赋一个不存在的Class也是可以的，这样是Static Provisioning，只要后面PVC也带有相同的属性，那还是可以匹配的。</p>
<h4 id="深入理解本地持久化数据"><a href="#深入理解本地持久化数据" class="headerlink" title="深入理解本地持久化数据"></a>深入理解本地持久化数据</h4><p>LocalPV(本地的持久化存储)的难点</p>
<ul>
<li><p>如何把本地磁盘抽象为PV？</p>
<p>宿主机目录不应该作为PV，因为无法保证磁盘空间不被其他应用争用导致空间不足。PV需要的一定是一块<strong>额外挂载</strong>在宿主机上的磁盘或者块设备</p>
<blockquote>
<p>Linux上可以使用<code>mount -t tmpfs $&#123;device name&#125; $&#123;dir like /mnt/...&#125;</code>来使用tmpfs临时挂载出一个磁盘设备</p>
</blockquote>
</li>
<li><p>如何保证Pod被调度到正确的node上去？</p>
<p>LocalPV强调local，那就一定和具体的node关联。因此调度Pod时需要知道这些信息</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume
<span class="token punctuation">...</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span>
  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> local<span class="token punctuation">-</span>storage
  <span class="token key atrule">local</span><span class="token punctuation">:</span>
    <span class="token key atrule">path</span><span class="token punctuation">:</span> /mnt/disks/vol1 <span class="token comment">#PV的路径</span>
  <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span>
    <span class="token key atrule">required</span><span class="token punctuation">:</span>
      <span class="token key atrule">nodeSelectorTerms</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> kubernetes.io/hostname
          <span class="token key atrule">operator</span><span class="token punctuation">:</span> In
          <span class="token key atrule">values</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> node<span class="token punctuation">-</span><span class="token number">1</span> <span class="token comment">#规定Pod一定要在node-1上</span></code></pre>

<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> storageClass
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> storage.k8s.io/v1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> local<span class="token punctuation">-</span>storage
<span class="token key atrule">provisioner</span><span class="token punctuation">:</span> kubernetes.io/no<span class="token punctuation">-</span>provisioner <span class="token comment">#没有插件来生产PV</span>
<span class="token key atrule">volumeBindingMode</span><span class="token punctuation">:</span> WaitForFirstConsumer <span class="token comment">#延迟绑定特性，等到某个使用该PVC的Pod出现在调度器以后再尝试与PV绑定，这样可以让调度器综合考虑所有调度要求</span></code></pre></li>
</ul>
<p>删除local PV的过程</p>
<ol>
<li>删除Pod</li>
<li>宿主机移除该硬盘(例如<code>umount</code>)</li>
<li>删除PVC</li>
<li>删除PV</li>
</ol>
<p>另外k8s也提供了<strong>Static Provisioner</strong>插件来帮助将<code>/mnt/disks/</code>下每一个挂载都创建一个PV对象</p>
<h4 id="开发自己的存储插件：FlexVolume与CSI"><a href="#开发自己的存储插件：FlexVolume与CSI" class="headerlink" title="开发自己的存储插件：FlexVolume与CSI"></a>开发自己的存储插件：FlexVolume与CSI</h4><p>CSI的原理：</p>
<style>.spwbqxjyafzm{zoom: 75%;}</style><img src="/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/image-20230209140836991.jpg" class="spwbqxjyafzm" alt="image-20230209140836991">

<ul>
<li><code>Driver Registar</code>将插件注册到kubelet中，它需要请求<code>CSI Identity</code>的信息</li>
<li><code>External Provisioner</code>负责provision，它监听PVC对象的创建，并调用<code>CSI Controller</code>的CreateVolume方法创建PV</li>
<li><code>External Attacher</code>负责attach，它监听VolumeAttachment(确认volume可以进入attach阶段的标志)的变化</li>
<li>Mount时直接调用<code>CSI Node</code>完成，不需要外部组件</li>
</ul>
<blockquote>
<p>实际使用时将三个外部组件和CSI放在同一个Pod中</p>
</blockquote>
<h3 id="Kubernetes网络原理"><a href="#Kubernetes网络原理" class="headerlink" title="Kubernetes网络原理"></a>Kubernetes网络原理</h3><h4 id="单机容器网络的实现原理"><a href="#单机容器网络的实现原理" class="headerlink" title="单机容器网络的实现原理"></a>单机容器网络的实现原理</h4><p>容器看见的网络栈(包括网卡，回环设备，路由表和iptables规则)隔离在它自己的Network Namespace中。容器的默认网关是docker0，所以外部的网络请求会经过docker0送往宿主机，对于处于同一网段的IP，容器的网关是0.0.0.0(即直连)，此时通过MAC寻址来通信。</p>
<p>有关docker0网桥的更多内容见本站另一篇博客：Docker网络虚拟化</p>
<h4 id="深入解析容器跨主机网络"><a href="#深入解析容器跨主机网络" class="headerlink" title="深入解析容器跨主机网络"></a>深入解析容器跨主机网络</h4><p>Flannel的三种后端实现</p>
<ul>
<li><p>UDP，性能最差，已被弃用</p>
<p>每个宿主机和其容器构成一个<strong>子网</strong>，每个节点有一个fannel0的TUN(tunnel)设备，它可以在内核和用户应用程序fanneld之间传递IP包。因此数据流为容器-&gt;docker0-&gt;flanneld-&gt;eth0-&gt;…(对称)。从flanneld到宿主机的过程中使用UDP封装，并且flannel通过检测目标容器的IP得到目标宿主机的IP，从而达到网络连接的目的。</p>
<style>.hilbzeswfydq{zoom:50%;}</style><img src="/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/image-20230211101318181.jpg" class="hilbzeswfydq" alt="image-20230211101442521">

<blockquote>
<p>用户态容器-&gt;内核态docker0-&gt;用户态flanneld-&gt;内核态eth0，一次发包经历三次不同态之间的复制，消耗很大</p>
</blockquote>
</li>
<li><p>VXLAN(virtual extensible LAN)，Linux内核支持的网络虚拟化技术</p>
<p>在传统三层网络之上覆盖二层网络，以VTEP设备作为隧道的两端，VTEP具有独立的IP和MAC</p>
<style>.ptvyrikqppwc{zoom:50%;}</style><img src="/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/image-20230211101442521.jpg" class="ptvyrikqppwc" alt="image-20230211101442521">

<p>当一个新的node加入集群后，flannel会为其他node加上发往该网段的包必须经由flannel.1设备发送的路由规则。VTEP收到原始IP报后，会用目的VTEP的MAC封装一个二层数据报，然后为了让Linux识别再加上一个VLAN Header，最后交给宿主机以UDP的形式发出去。由于宿主机的FDB转发数据库也是由flannel.1维护的，所以它也可以知道目的宿主机的IP。</p>
<table>
<thead>
<tr>
<th>外部以太网头</th>
<th>外部IP头</th>
<th>外部UDP头</th>
<th>VXLAN Header</th>
<th>内部以太网头</th>
<th>目的容器地址</th>
<th>$\cdots$</th>
</tr>
</thead>
<tbody><tr>
<td>目的主机的MAC</td>
<td>目的主机的IP</td>
<td>$\cdots$</td>
<td>一些标志位</td>
<td><strong>目的VTEP</strong>的MAC</td>
<td>目的容器的IP</td>
<td>$\cdots$</td>
</tr>
</tbody></table>
</li>
<li><p>host-gw</p>
</li>
</ul>
<h4 id="Kubernetes网络模型与CNI网络插件"><a href="#Kubernetes网络模型与CNI网络插件" class="headerlink" title="Kubernetes网络模型与CNI网络插件"></a>Kubernetes网络模型与CNI网络插件</h4><p>kubernetes用<code>CNI</code>接口维护了一个单独的cni网桥来替代docker0，名字叫cni0，node1路由表的规则</p>
<ul>
<li>发往本网段内的包由cni0处理</li>
<li>发往集群外部某node网段的包由flannel.1设备处理</li>
<li>发往docker网段的包由docker0处理</li>
</ul>
<p>CNI的设计思想就是Kubernetes在启动Infra容器之后能够直接调用CNI网络插件来配置网络栈</p>
<p>CNI插件分为如下几类(<code>kubeasz</code>安装的话都在<code>/opt/kube/bin/</code>中)：</p>
<ul>
<li>Main插件，用于创建具体网络设备，例如bridge、ipvlan等</li>
<li>IPAM插件，ip address management，例如dhcp、host-local</li>
<li>内置插件，例如flannel</li>
</ul>
<p>Pod网络构建流程：</p>
<ol>
<li>flanneld在每台宿主机上生成CNI配置文件</li>
<li>kubelet主干代码不负责容器网络，而是交由CRI(Container Runtime Interface)进行，docker的CRI是dockershim，它来加载上述配置文件</li>
<li>dockershim调用Docker API创建Infra容器，然后调用CNI插件配置网络。参数第一部分来自dockershim主动设置的环境变量，包括容器里网卡的名字(rth0)，Pod Namespace文件的路径，以及<code>CNI_ARGS</code>这一自定义参数等；第二部分来自CNI配置。</li>
<li>flannel的CNI配置中<code>delegate</code>字段表明这个插件实际工作的交付者。因此Flannel CNI插件的作用就是简单地在delegate中补充一些配置信息，同时保存在<code>/var/lib/cni/flannel</code>下</li>
<li>创建cni0网桥(如果没有的话)，进入network namespace创建veth pair设备，将这端的名字设为参数中容器网卡的名字，将另一端归属于cni0网桥(可能要设置Hairpin Mode来允许同一个包从这个端口进来又出去，因此如果设置了容器的端口转发，容器内部访问宿主机哪个端口时实际上会回到容器里)</li>
</ol>
<blockquote>
<p>因此在k8s中，所有的容器之间都是可以“通”的，容器看到的ip与真实ip是一致的</p>
</blockquote>
<h4 id="解读Kubernetes三层网络方案"><a href="#解读Kubernetes三层网络方案" class="headerlink" title="解读Kubernetes三层网络方案"></a>解读Kubernetes三层网络方案</h4><p>即只使用原来的三层网络</p>
<ul>
<li><p>host-gw(host-gateway)</p>
<p>给node1的路由表设置node2网段IP对应的<strong>下一跳IP</strong>为node2的IP并且通过eth0设备发送，由于设置了下一跳IP，此时数据链路层就会用下一跳IP查出的MAC地址封装数据包。到达node2后，发现目的IP为子网中容器的IP，此时交由cni0处理</p>
<table>
<thead>
<tr>
<th>目的MAC</th>
<th>目的IP</th>
</tr>
</thead>
<tbody><tr>
<td>node2的MAC</td>
<td>node2中容器的IP</td>
</tr>
</tbody></table>
<blockquote>
<p>由于需要node1知道node2的MAC，因此host-gw要求集群之间是<strong>二层可达的</strong></p>
<p>但也由此相比VXLAN<strong>减少了性能损耗</strong></p>
</blockquote>
</li>
<li><p>Calico</p>
<p>原理大致与host-gw相同，但是使用了<code>BGP</code>协议来在集群中分发路由信息。Calico项目由以下三个部分组成</p>
<ul>
<li><p>CNI插件</p>
</li>
<li><p>Felix，负责在宿主机上插入路由规则的DaemonSet</p>
</li>
<li><p>BIRD，BGP客户端，负责在集群中分发路由信息</p>
</li>
</ul>
<p>另外Calico<strong>不会在集群中创建任何的网桥设备</strong>，而是直接为每个容器创建连到宿主机上的veth pair(由于没有网桥，因此宿主机路由规则里也要写明去本网段xx容器IP得经由xxveth设备)</p>
<p>默认情况下Calico维护的网络遵循Node-toNode Mesh模式，$N^2$量级，因此推荐100以下用。大规模集群推荐使用Route Reflector模式，即指定若干节点来学习全局路由信息，其余节点仅跟这几个节点交换信息。</p>
<p>开启<code>IPIP</code>模式以后，Calico可以突破二层网络的限制。具体做法是将node1上到node2子网下一跳的eth0设备替换为tunl0设备(IP隧道设备)，然后在外面封装一层IP报头，伪装成node1到node2的IP包</p>
<table>
<thead>
<tr>
<th>目的MAC</th>
<th>目的IP</th>
<th>payload</th>
</tr>
</thead>
<tbody><tr>
<td>下一跳路由器的MAC</td>
<td>node2的IP</td>
<td>原IP数据报</td>
</tr>
</tbody></table>
<p>不扩展host-gw给中间路由器也指定网段下一跳mac的原因是公有云环境下用户肯定不能随意更改服务器配置</p>
</li>
</ul>
<h4 id="Kubernetes中的网络隔离：NetworkPolicy"><a href="#Kubernetes中的网络隔离：NetworkPolicy" class="headerlink" title="Kubernetes中的网络隔离：NetworkPolicy"></a>Kubernetes中的网络隔离：NetworkPolicy</h4><p>Calico、Weave均实现了NetworkPolicy，Flannel需要额外安装前述二者中一个</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/vl
<span class="token key atrule">kind</span><span class="token punctuation">:</span> NetworkPolicy
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>network<span class="token punctuation">-</span>policy
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">podselector</span><span class="token punctuation">:</span> <span class="token comment">#如果设为&#123;&#125;，那就是对Namespace下所有Pod起作用</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
      <span class="token key atrule">role</span><span class="token punctuation">:</span> db <span class="token comment">#所有携带了role=db的Pod</span>
  <span class="token key atrule">policyTypes</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> Ingress
  <span class="token punctuation">-</span> Egress
  <span class="token key atrule">ingress</span><span class="token punctuation">:</span> <span class="token comment">#流入白名单</span>
  <span class="token punctuation">-</span> <span class="token key atrule">from</span><span class="token punctuation">:</span> <span class="token comment">#下方列表项间是“或”关系，列表项内才是与关系，因此可以在列表项内定义并列的(同一缩进层级)ipBlock和namespaceSelector规则</span>
    <span class="token punctuation">-</span> <span class="token key atrule">ipBlock</span><span class="token punctuation">:</span> <span class="token comment">#源地址属于172.17.0.0/16且不属于172.17.1.0/24</span>
        <span class="token key atrule">cidr</span><span class="token punctuation">:</span> 172.17.0.0/16
        <span class="token key atrule">except</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> 172.17.1.0/24
    <span class="token punctuation">-</span> <span class="token key atrule">namespaceSelector</span><span class="token punctuation">:</span>
        <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
          <span class="token key atrule">project</span><span class="token punctuation">:</span> myproject
    <span class="token punctuation">-</span> <span class="token key atrule">podSelector</span><span class="token punctuation">:</span>
        <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
          <span class="token key atrule">role</span><span class="token punctuation">:</span> frontend
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP
      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>
  <span class="token key atrule">egress</span><span class="token punctuation">:</span> <span class="token comment">#流出白名单</span>
  <span class="token punctuation">-</span> <span class="token key atrule">to</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">ipBlock</span><span class="token punctuation">:</span>
        <span class="token key atrule">cidr</span><span class="token punctuation">:</span> 10.0.0.0/24
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">protocal</span><span class="token punctuation">:</span> TCP
      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5978</span></code></pre>

<p>NetworkPolicy通过iptables规则来实现隔离，而iptables实际上操作的是Linux的Netfilter</p>
<img src="/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/netfilter.jpg" class="" title="img">

<h4 id="找到容器不容易：Service、DNS与服务发现"><a href="#找到容器不容易：Service、DNS与服务发现" class="headerlink" title="找到容器不容易：Service、DNS与服务发现"></a>找到容器不容易：Service、DNS与服务发现</h4><p>Service也通过iptables设置转发规则，通过对转发目的的概率设置，从而实现deployment下Pod的负载均衡</p>
<p>但是这样也造成大量Pod存在时，iptables不断更新带来性能的损耗，因此推荐开启kube-proxy的IPVS模式，大致就是搞一个虚拟网卡，把VIP分配给他以后设置多台虚拟主机，每台直接代理一个Pod，然后它们以轮询规则作为负载均衡策略。因为IPVS在内核态，所以无需频繁切换到内核态维护iptables。</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>DNS记录</th>
</tr>
</thead>
<tbody><tr>
<td>ClusterIP模式的Service</td>
<td><code>$&#123;service-name&#125;.$&#123;namespace&#125;.svc.cluster.local</code></td>
</tr>
<tr>
<td>ClusterIP&#x3D;None模式的Headless Service</td>
<td>同上，但返回的是所有被代理的Pod的IP地址的集合</td>
</tr>
<tr>
<td>ClusterIP模式Service代理的Pod</td>
<td><code>$&#123;pod-name&#125;.$&#123;service-name&#125;.$&#123;namespace&#125;.svc.cluster.local</code></td>
</tr>
<tr>
<td>Headless Service代理的声明了hostname和subdomain的Pod</td>
<td><code>$&#123;hostname&#125;.$&#123;subdomain&#125;.$&#123;namespace&#125;.svc.cluster.local</code></td>
</tr>
</tbody></table>
<h4 id="从外界连通Service与Service调试“三板斧”"><a href="#从外界连通Service与Service调试“三板斧”" class="headerlink" title="从外界连通Service与Service调试“三板斧”"></a>从外界连通Service与Service调试“三板斧”</h4><p>由于Service依赖宿主机上kube-proxy生成的iptables规则和DNS记录，因此离开集群后这些信息是无用的。</p>
<p>从外部访问Service主要有如下方式：</p>
<ul>
<li><p>使用NodePort</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">nodePort</span><span class="token punctuation">:</span> <span class="token number">8080</span> <span class="token comment">#暴露给外部的端口</span>
    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">30080</span> <span class="token comment">#暴露在Cluster IP的端口，集群内部访问Service</span>
    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span> <span class="token comment">#代理的Pod的端口，实际访问Pod:这个端口</span>
    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP
    <span class="token key atrule">name</span><span class="token punctuation">:</span> http</code></pre>

<p>Kuberetes会对离开宿主机的IP包(仅限于因为Service而被转发的，可以通过DNAT过程加上去的0x4000标志检测)做SNAT，将源IP换成自己的IP或者自己网桥的IP。这也很容易理解，例如client-&gt;node2，但是node2因为负载均衡把包转给了node1，此时如果node1收到的包src是client的话，那回复给client会造成client的收发不一致。因此需要node2给node1转发时把src IP换成自己的，组hi后再从自己这回client。</p>
<p>如果需要明确知道具体是哪个Pod在负责处理请求，那这样是不行的，可以开启spec.externalTrafficPolicy&#x3D;local，让请求只会被转发到自己node上的Pod。</p>
</li>
<li><p>使用LoadBalancer，适用于公有云服务</p>
</li>
<li><p>使用ExternalName，相当于在kube-dns添加了一条CNAME别名记录，访问xxx.cluster.local和访问externalName效果相同</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">type</span><span class="token punctuation">:</span> ExternalName
  <span class="token key atrule">externalName</span><span class="token punctuation">:</span> my.database.example.com</code></pre>
</li>
<li><p>使用externalIP来代理Pod，这个IP得是你能够路由到的在集群中的一个节点</p>
</li>
</ul>
<h4 id="Kubernetes中的Ingress对象"><a href="#Kubernetes中的Ingress对象" class="headerlink" title="Kubernetes中的Ingress对象"></a>Kubernetes中的Ingress对象</h4><p>Ingress相当于Service的”Service”</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">tls</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> cafe.example.com
    <span class="token key atrule">secretName</span><span class="token punctuation">:</span> cafe<span class="token punctuation">-</span>secret
  <span class="token key atrule">rules</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> cafe.example.com <span class="token comment">#必须是标准的域名格式字符串，不能是IP地址</span>
    <span class="token key atrule">http</span><span class="token punctuation">:</span>
      <span class="token key atrule">paths</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /tea <span class="token comment">#域名下不同的路径交给不同的service</span>
        <span class="token key atrule">backend</span><span class="token punctuation">:</span>
          <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> tea<span class="token punctuation">-</span>svc
          <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">80</span>
      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /coffee
        <span class="token key atrule">backend</span><span class="token punctuation">:</span>
          <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> coffee<span class="token punctuation">-</span>svc
          <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre>

<p>可以使用Nginx Ingress Controller等等Ingress Controller来检测Ingress对象的创建，自动创建相关负载均衡服务，之后这可以用一个Service对外暴露这个服务即可。</p>
<blockquote>
<p>使用到的yaml文件需要查阅相关controller提供的资料</p>
</blockquote>
<h3 id="Kubernetes的资源模型与资源管理"><a href="#Kubernetes的资源模型与资源管理" class="headerlink" title="Kubernetes的资源模型与资源管理"></a>Kubernetes的资源模型与资源管理</h3><h4 id="Kubernetes的资源模型与资源管理-1"><a href="#Kubernetes的资源模型与资源管理-1" class="headerlink" title="Kubernetes的资源模型与资源管理"></a>Kubernetes的资源模型与资源管理</h4><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> db
    <span class="token punctuation">...</span>
    <span class="token key atrule">resources</span><span class="token punctuation">:</span>
      <span class="token key atrule">requests</span><span class="token punctuation">:</span>
        <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"64Mi"</span> <span class="token comment">#64MB内存，单位可以是Mi，M，Ki，K……</span>
        <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"250m"</span> <span class="token comment">#250millicpu，即0.25个CPU的计算能力，这里写0.25也可以</span>
      <span class="token key atrule">limits</span><span class="token punctuation">:</span>
        <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"128Mi"</span>
        <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"500m"</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
  <span class="token comment">#最终Pod占用的资源是容器占用资源的总和，其中内存资源不可压缩，缺失会造成Out-Of-Memory从而被内核终止，CPU资源可压缩，缺失仅会造成一定程度的饥饿</span></code></pre>

<p><code>requests</code>是调度时使用的资源量，即Pod<strong>一开始</strong>会申请这么多资源以供调度，limits则是Cgroups中设立的最大资源量。当node不满足Pod的requests时，Pod会被调度到其他节点(失败重启)</p>
<p>若requests和limits中cpu的值为<strong>相等的整数n</strong>，那么会使其<strong>绑定到n个cpu</strong>上</p>
<blockquote>
<p>类似于cpuset功能，减少cpu之间的上下文切换</p>
</blockquote>
<p>Pod的三种QoS(Quality-Of-Service)级别：</p>
<ul>
<li>Guaranteed：每个容器都同时设置了requests和limits(只有limits时requests与其一致，因此也是该情况)</li>
<li>Burstable：至少有一个容器设置了requests</li>
<li>BestEffort：啥也没有</li>
</ul>
<p>当整个kubernetes宿主机的资源发生不足，例如内存、文件系统可用空间低于阈值，会触发Eviction即资源回收，回收优先级依次为：</p>
<ol>
<li>BestEffort</li>
<li>Burstable且对象处于饥饿且资源使用量超过requests</li>
<li>Guaranteed且资源使用量超过limits或宿主机memory pressure</li>
</ol>
<blockquote>
<p>因此建议将DaemonSet的Pod都设为Guaranteed类型，否则其被回收之后会立刻创建，从而造成回收的失效</p>
</blockquote>
<h4 id="Kubernetes的默认调度器"><a href="#Kubernetes的默认调度器" class="headerlink" title="Kubernetes的默认调度器"></a>Kubernetes的默认调度器</h4><style>.jtyncdzwejng{zoom:40%;}</style><img src="/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/image-20230214135305115.jpg" class="jtyncdzwejng" alt="image-20230214135305115">

<p>两个控制循环：</p>
<ul>
<li><p>Informer负责监听Pod的变化，更新调度器缓存以及维护优先队列</p>
</li>
<li><p>主循环</p>
<ul>
<li><p>从队列中Pop出Pod</p>
</li>
<li><p>进行Predicate操作，选出潜在的node</p>
</li>
<li><p>进行Priorities操作，对潜在node进行打分</p>
</li>
<li><p>Bind操作只更新缓存，称为Assume，乐观</p>
<blockquote>
<p>失败不要紧，同步操作最终会让现实与调度器缓存一致</p>
</blockquote>
</li>
<li><p>发起Goroutine联系API server发起异步请求</p>
<blockquote>
<p>实际Pod开始执行时，也会再跑一次Predicates进行二次确认</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="Kubernetes默认调度器调度策略解析"><a href="#Kubernetes默认调度器调度策略解析" class="headerlink" title="Kubernetes默认调度器调度策略解析"></a>Kubernetes默认调度器调度策略解析</h4><p>Predicates预选主要有四种</p>
<ol>
<li><p>GeneralPredicates，简单地考察node的资源是否够Pod的requests</p>
</li>
<li><p>Volume相关</p>
<ul>
<li>NoDiskConflict：多个Pod声明挂载的PV是否有冲突(不允许被共享之类)</li>
<li>MaxPDVolumeCountPredicate：检查一个节点上某个类型的PV是否超过了一定数目</li>
<li>VolumeZonePredicate：检查Zone标签(高可用域)是否匹配</li>
<li>VolumeBindingPredicate：nodeAffinity字段是否匹配</li>
</ul>
</li>
<li><p>宿主机相关，比如PodToleratesNodeTaints，只有污点被允许时才能调度，NodeMemoryPressurePredicate，内存是否足够</p>
</li>
<li><p>Pod相关，大多和general重合，另外有考察Pod和已有的Pod之间affinity(亲密度)和anti-affinity的关系</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>
    <span class="token key atrule">podAntiAffinity</span><span class="token punctuation">:</span> <span class="token comment">#反亲密度</span>
      <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span> <span class="token comment">#调度时必须考虑</span>
      <span class="token punctuation">-</span> <span class="token key atrule">weight</span><span class="token punctuation">:</span> <span class="token number">100</span>
        <span class="token key atrule">podAffinityTerm</span><span class="token punctuation">:</span>
          <span class="token key atrule">labelSelector</span><span class="token punctuation">:</span>
            <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span> <span class="token comment">#不与携带有security=S2的Pod在一个节点上</span>
            <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> security
              <span class="token key atrule">operator</span><span class="token punctuation">:</span> in
              <span class="token key atrule">values</span><span class="token punctuation">:</span>
              <span class="token punctuation">-</span> S2
          <span class="token key atrule">topologyKey</span><span class="token punctuation">:</span> kubernetes.io/hostname <span class="token comment">#作用域为那些携带了kubernetes.io/hostname标签的节点</span></code></pre></li>
</ol>
<p>实际会并发16个Goroutine，为所有node计算shi否合适</p>
<p>Priorities优选策略</p>
<p>最常用的是LeastRequestedPriority(空闲资源最多)和BanlancedResourceAllocation(分配最平均)等</p>
<h4 id="Kubernetes默认调度器的优先级和抢占机制"><a href="#Kubernetes默认调度器的优先级和抢占机制" class="headerlink" title="Kubernetes默认调度器的优先级和抢占机制"></a>Kubernetes默认调度器的优先级和抢占机制</h4><p><code>PriorityClass</code>示例：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> scheduling.k8s.io/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> PriorityClass
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> high<span class="token punctuation">-</span>priority
<span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token number">1000000</span> <span class="token comment">#不大于1e9的整数</span>
<span class="token key atrule">globalDefault</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment">#为true则成为系统默认值，false则只作用于这个PriorityClass</span>
<span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"..."</span></code></pre>

<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span>
  <span class="token key atrule">priorityClassName</span><span class="token punctuation">:</span> high<span class="token punctuation">-</span>priority</code></pre>

<p>这个value就体现在默认调度器的优先队列中</p>
<p>当高优先级Pod调度失败时，发生抢占事件。此时并不会立刻抢占，而是将抢占者的<code>spec.nominatedNodeName</code>设为将被抢占的节点名字，等到被抢占者_优雅退出_以后才被调度。在此期间给更高优先级抢占者的到来留下了充足的时间。</p>
<p>抢占算法使用了两个队列</p>
<ul>
<li><p>activeQ：下一个调度周期需要调度的对象</p>
<blockquote>
<p>Pop出队发生在这个队列中</p>
</blockquote>
</li>
<li><p>unschedulableQ：调度失败的对象</p>
<blockquote>
<p>unschedulableQ中Pod更新以后，会被挪到activeQ中重新<strong>给予机会</strong></p>
</blockquote>
</li>
</ul>
<p>抢占流程：</p>
<ol>
<li><p>检查调度失败原因，<strong>确认抢占可以找到新节点</strong></p>
</li>
<li><p>复制一份缓存中的节点信息，用副本来模拟找出最佳结果，得出牺牲者列表</p>
<ol>
<li><p>清理牺牲者列表中的<code>nominatedNodeName</code></p>
</li>
<li><p>设置抢占者的<code>nominatedNodeName</code> &gt; 进入activeQ</p>
<blockquote>
<p>如果其优先级很低，那可能还不如普通高优先级Pod</p>
</blockquote>
</li>
<li><p>向API server逐一删除牺牲者</p>
</li>
</ol>
</li>
</ol>
<p>由于有抢占者的存在，因此一对Pod和节点之间进行预选时其实要运行两次预选算法，第一次是假设潜在抢占者在节点上运行(防止有InterPodAntiAffinity)，第二次假设不在，只有<strong>两次都通过了</strong>才会将Pod和节点视为可绑定</p>
<h4 id="Kubernetes-GPU管理与Device-Plugin机制"><a href="#Kubernetes-GPU管理与Device-Plugin机制" class="headerlink" title="Kubernetes GPU管理与Device Plugin机制"></a>Kubernetes GPU管理与Device Plugin机制</h4><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">...</span>
    <span class="token key atrule">resources</span><span class="token punctuation">:</span>
      <span class="token key atrule">limits</span><span class="token punctuation">:</span>
        <span class="token key atrule">nvida.com/gpu</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment">#k8s并不在乎这个key的含义是什么，它只管计算value是否超出了容量</span></code></pre>

<p>在kubernetes中，资源可用量来自于Node对象的<code>Status</code></p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Node
<span class="token punctuation">...</span>
<span class="token key atrule">Status</span><span class="token punctuation">:</span>
  <span class="token key atrule">Capacity</span><span class="token punctuation">:</span>
    <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token number">2</span>
    <span class="token key atrule">memory</span><span class="token punctuation">:</span> 2049008Ki</code></pre>

<p>因此可以用PATCH操作来增加自定义资源量的记录</p>
<p>实际上这样的工作可以交给Device Plugin来管理。</p>
<style>.xpiglvnewnvn{zoom: 50%;}</style><img src="/Blog/2022/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kubernetes/image-20230214161132561.jpg" class="xpiglvnewnvn" alt="image-20230214161132561">

<p>Device Plugin通过gRPC的方式与kubelet通信，ListAndWatch接口负责定时汇报GPU列表，Allocate接口负责分配一个可用GPU，返回设备路径和驱动路径。</p>
]]></content>
      <categories>
        <category>技术视野</category>
      </categories>
      <tags>
        <tag>Container</tag>
      </tags>
  </entry>
  <entry>
    <title>面向大模型训练的新型数据中心智算网络体系</title>
    <url>/Blog/2024/01/05/%E9%9D%A2%E5%90%91%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E7%9A%84%E6%96%B0%E5%9E%8B%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E6%99%BA%E7%AE%97%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>分享人：翟恩男</p>
<p>阿里云网络研究复杂人</p>
<p>29个主干数据中心(足球场大小)，3000个左右边缘云(机房大小)提供服务</p>
<p>把数据面等计算的负载从CPU offload到可编程芯片上从而提高业务计算能力</p>
<p>网络的技术挑战来自于<strong>规模化</strong></p>
<p>DNS</p>
<ul>
<li>正确性：SOSP’23 形式化验证</li>
<li>虚拟化可扩展</li>
</ul>
<p>广域网</p>
<ul>
<li>可靠性<ul>
<li>网络故障原因：<ul>
<li><strong>软件</strong>，路由器软件bug</li>
<li>硬件——现在冗余提高了可靠性</li>
<li><strong>配置</strong></li>
</ul>
</li>
</ul>
</li>
<li>运营效率</li>
<li>流量调度</li>
</ul>
<p>可编程边缘云网关</p>
<ul>
<li>编程效率</li>
<li>程序交换性</li>
</ul>
<p>数据中心里拓扑比较规整，基本都是软硬件问题(靠监控解决)，配置问题很少</p>
<p>大模型时代的数据中心的改变：</p>
<ul>
<li>算力非常关键(例如 GPU number)</li>
<li>大模型<strong>训练</strong>过程中，网络是瓶颈<ul>
<li>大模型是脉冲式的网络占用(无法提供给那么多租户)，通用计算则网络占用比较稳定。因此传统的ECMP&#x2F;流控&#x2F;网络监控不再适用</li>
<li>大模型对网络故障、带宽损失极其敏感</li>
</ul>
</li>
</ul>
<p>传统网络尽力而为，对应用是黑盒，如果能网络适应应用，那么就可以获得一个白盒的视角。阿里目前自研交换机差不多覆盖了60-70%，约10w台</p>
<p>交换机芯片大部分供货来自博通</p>
<p>NCCL开源库有很多问题，自研ACCL库</p>
<p>拥塞控制HCPP方法，选路担保</p>
<p>……</p>
<p>核心竞争力(壁垒性)↑</p>
<ul>
<li>弱：各种创新技术(paper一发就能被学过去)</li>
<li>中：架构建设与交付的工具&#x2F;管理；全自动化的交付流程</li>
<li>强：芯片和数据集；芯片生产工艺；数据集清洗</li>
</ul>
<p>大模型的盈利模式在于结合各种软件吸引用，SaaS，因此推理很重要</p>
<ul>
<li>如何网络+推理</li>
</ul>
<p>AI for network management</p>
<p>发展硬核技术，实现能落地的创新</p>
]]></content>
      <categories>
        <category>技术视野</category>
      </categories>
      <tags>
        <tag>System</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>造血干细胞捐献日记</title>
    <url>/Blog/2023/02/06/%E9%80%A0%E8%A1%80%E5%B9%B2%E7%BB%86%E8%83%9E%E6%8D%90%E7%8C%AE%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>以下是我个人造血干细胞的捐献流程，记录下来以供参考</p>
<h5 id="2021年3月21日——入库报名"><a href="#2021年3月21日——入库报名" class="headerlink" title="2021年3月21日——入库报名"></a>2021年3月21日——入库报名</h5><p>在朋友圈看到复旦红会的干细胞入库推送，现在捐献造血干细胞不需要进行骨髓穿刺而是进行外周血过滤的介绍极大地减少了我对捐献造血干细胞的恐惧。小学时学校组织为罹患白血病的同学募捐，自那时起我便模模糊糊地感觉血液病是一种类似“绝症”的东西。捐献造血干细胞能够挽救一个生命，我的父母也多次献血，况且这次活动只是简单地入个库，并不代表着一定要捐献，对我来说报名活动入个库是个很自然的事情。</p>
<h5 id="2021年4月6日——资料入库"><a href="#2021年4月6日——资料入库" class="headerlink" title="2021年4月6日——资料入库"></a>2021年4月6日——资料入库</h5><p>活动在工会南204开展，期间遇到了一起上羽毛球课的医学院朋友，还是挺开心的。红会的老师给我们介绍了捐献造血干细胞的流程还有一些注意点等等。比如尽量留稳定可靠的联系方式，因为匹配到以后可能就是很多年以后了……</p>
<p>采集信息入库用的是口拭子，没有抽血。</p>
<p>当天下午感觉自己还算做了一件有意义的事情，想到可能未来十年八年后的一天突然接到一个配型成功的电话，不禁有些忐忑。从工会一路走到南区，时值暖春，生机勃勃，顺手拍下的一张照片刚好记下了我那时的心情。</p>
<style>.gdlbqglaqlbh{zoom:50%;}</style><img src="/Blog/2023/02/06/%E9%80%A0%E8%A1%80%E5%B9%B2%E7%BB%86%E8%83%9E%E6%8D%90%E7%8C%AE%E6%97%A5%E8%AE%B0/image-20230206232731357.jpg" class="gdlbqglaqlbh" alt="image-20230206232731357">

<h5 id="2022年10月31日——初配成功"><a href="#2022年10月31日——初配成功" class="headerlink" title="2022年10月31日——初配成功"></a>2022年10月31日——初配成功</h5><p>接到电话的时候我刚到西辅楼准备去自习，电话里一个女声平静地跟我说：“您好，我是……这把显示您和一个白血病患者配型成功，请问您现在还有捐献的意愿吗……”听明白她的意思，那一瞬间很多种情绪一起向我涌来。多小的几率啊就给我给赶上了，我甚至没感觉到眼角突然的湿润——那是身体产生的应激反应。然后就是难以置信，说好的五六年七八年的呢，怎么我入库才一年半就配上了！再接着就是不安了，这通电话让“捐献”从一个不确定的幻影一下子变得沉甸甸的而有质量。我说，我和家里人再商量一下。</p>
<p>其实说商量也用不着商量，其实从我入库的时候我就已经知道，无论什么时候打电话给我，我的回答都是同意。做了决定以后，我便给家里人打了个电话，语气当然也很强硬，诸如这是告知云云——家人总归是要担心的，不过再怎么说他们也还是会遵从我的意见。</p>
<p>两点多的时候我回了个电话给中华骨髓库上海分库，表达了自己同意捐献的个人意愿。对方告诉我这边只是初配成功，之后还需要进行高分辨率检测，约好之后再聊。</p>
<p>当天看了一下午的相关报导，还有B站上别人拍的捐献造血干细胞的vlog。我刻意找了一些白血病患者的视频，想让我自己的意志坚定点。当然也看到了那个“临捐反悔典型案例”的视频，深感同意捐献就相当于背上了重重的责任。临捐之时，自己的手中也紧握着他人的生命。同时也有点担心自己初配成功高配失败——知乎上好像有好几个这样的案例，不过看到别人说最近几年技术进步，初配成功了高配也往往会成功，也稍微安了一点心。</p>
<h5 id="2022年11月3日——高分辨率检测"><a href="#2022年11月3日——高分辨率检测" class="headerlink" title="2022年11月3日——高分辨率检测"></a>2022年11月3日——高分辨率检测</h5><p>11月2日骨髓库通知我去做高分辨率检测，因为要报备出校也和辅导员简单聊了一下，在这里也感谢汪导的关心。</p>
<p>3日去了成都北路的爱心献血屋，同一直电话联系的石老师见了面，同时她也带过来一份高分辨率检测的知情同意书，我签字同意。之后去到二楼，一位护士姐姐给我采了两管血。</p>
<h5 id="2022年11月18日——全面体检"><a href="#2022年11月18日——全面体检" class="headerlink" title="2022年11月18日——全面体检"></a>2022年11月18日——全面体检</h5><p>15日骨髓库告诉我高分辨检测通过了，和我约了周五体检。在市一院和学校附属的华山医院里我选择了近一点的市一院。18日早晨空腹前往市一院的国际医疗保健中心，在那里采血差不多有十管(其实也还好，没啥感觉)，做了影像检查等等，也没有花费太多时间。</p>
<p>12月16日我临走之前收到了寄过来的体检报告单，各项指标正常。</p>
<h5 id="2023年1月29日——约定捐献时间"><a href="#2023年1月29日——约定捐献时间" class="headerlink" title="2023年1月29日——约定捐献时间"></a>2023年1月29日——约定捐献时间</h5><p>接到骨髓库的电话，由于我是在校大学生，那边还需要我提供一份家长的知情同意书。家长说不上同意，但也并不反对，材料发给对方过后，初步约定在3月7日进行捐献。另外由于体检只有三个月有效期，因此在2月10日在进行一次体检。</p>
<h5 id="2023年3月3日——第一天"><a href="#2023年3月3日——第一天" class="headerlink" title="2023年3月3日——第一天"></a>2023年3月3日——第一天</h5><p>上午10点左右入院，下午4点出头打了一针动员剂，晚上9点左右打了第二针动员剂。我在入院之前有点感冒，当晚睡觉时感觉头部有点胀痛，然后背部也有酸胀感。</p>
<h5 id="2023年3月4日——第二天"><a href="#2023年3月4日——第二天" class="headerlink" title="2023年3月4日——第二天"></a>2023年3月4日——第二天</h5><p>早上6点左右抽血，然后打了一针动员剂，下午两点左右打了第二针动员剂。一整天都有点头晕脑胀，明显腰酸。</p>
<h5 id="2023年3月5日——第三天"><a href="#2023年3月5日——第三天" class="headerlink" title="2023年3月5日——第三天"></a>2023年3月5日——第三天</h5><p>打针，头晕，晚上睡觉有点头疼</p>
<h5 id="2023年3月6日——第四天"><a href="#2023年3月6日——第四天" class="headerlink" title="2023年3月6日——第四天"></a>2023年3月6日——第四天</h5><p>最后一天早晚针，晚上头疼，凌晨三点睡醒难以入睡，稍微坐了一会以后睡着</p>
<h5 id="2023年3月7日——第五天"><a href="#2023年3月7日——第五天" class="headerlink" title="2023年3月7日——第五天"></a>2023年3月7日——第五天</h5><p>早上6点打完针以后，9点左右机器基本就位。9点十五左右左右手臂打入留置针，不是很疼，机器启动。由于操作原因，到10点45左右猜排除了故障开始正常运转。中途手臂因为无法弯曲，肘部肌肉比较酸痛。到1点左右机器已采集200多毫升，可能软管出现破损，机器不停报错。医护人员计算得出干细胞浊液量基本已经足够，决定暂停分离。由于软管内有一点气泡，血液回流不是很安全，所以体外的几十毫升血液最终没有回流。</p>
<p>管子拔掉以后主要还是手臂比较酸痛，当天不可以洗澡。但是头痛症状当天明显消失。</p>
<h5 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h5><p>之后基本就没有什么不适感了，和平时无异。医生和红会工作人员祝福回去要好好休息，一个月以内不要进行激烈的体育运动。这次经历对我来说也是非常难得的人生体验吧，自己也因此而有了更多的成就感。以后面对我的孩子，我可以骄傲地说：我也做过英雄。</p>
]]></content>
      <categories>
        <category>杂谈点滴</category>
      </categories>
  </entry>
</search>
